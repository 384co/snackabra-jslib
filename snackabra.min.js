!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>ee,ChannelSocket:()=>ne,MessageBus:()=>o,SB:()=>ae,SB384:()=>q,SBCrypto:()=>J,SBFile:()=>Q,SBMessage:()=>Y,Snackabra:()=>oe,_appendBuffer:()=>E,_assertBase64:()=>u,_sb_assert:()=>h,_sb_exception:()=>c,_sb_resolve:()=>l,arrayBufferToBase64:()=>j,assemblePayload:()=>B,base64ToArrayBuffer:()=>O,cleanBase32mi:()=>x,compareBuffers:()=>P,decodeB64Url:()=>U,encodeB64Url:()=>L,encryptedContentsMakeBinary:()=>s,extractPayload:()=>$,extractPayloadV1:()=>T,getRandomValues:()=>d,jsonParseWrapper:()=>D,partition:()=>M,simpleRand256:()=>R,simpleRandomString:()=>N});var n=function(e,t,n,r){var s,o=arguments.length,a=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(a=(o<3?s(a):o>3?s(t,n,a):s(t,n))||a);return o>3&&a&&Object.defineProperty(t,n,a),a};const r=[{channel_server:"https://channel.384co.workers.dev",channel_ws:"wss://channel.384co.workers.dev",storage_server:"https://storage.384co.workers.dev"},{channel_server:"https://r.384co.workers.dev",channel_ws:"wss://r.384co.workers.dev",storage_server:"https://s.384co.workers.dev"}];function s(e){let t,n;if("string"==typeof e.content)t=O(decodeURIComponent(e.content));else{const n=e.content.constructor.name;h("ArrayBuffer"===n||"Uint8Array"===n,"undetermined content type in EncryptedContents object"),t=e.content}if("string"==typeof e.iv)n=O(decodeURIComponent(e.iv));else if("Uint8Array"===e.iv.constructor.name||"ArrayBuffer"===e.iv.constructor.name)n=new Uint8Array(e.iv);else try{n=new Uint8Array(Object.values(e.iv))}catch(e){h(!1,"undetermined iv (nonce) type, see console")}return h(12==n.length,`unwrap(): nonce should be 12 bytes but is not (${n.length})`),{content:t,iv:n}}class o{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function a(e,t){return!1===navigator.onLine&&console.info("Note: you are offline, according to the browser"),t?fetch(e,t):fetch(e,{method:"GET"})}function i(e){return e instanceof Error?e:new Error(String(e))}function c(e,t){throw new Error("<< SB lib error ("+e+": "+t+") >>")}function l(e){return e.then?e:new Promise((t=>t(e)))}function h(e,t){if(!e)throw new Error(`<< SB assertion error: ${t} >>`)}function d(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{h(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}const y=/([A-Za-z0-9+/_\-=]{64})([01]{42})/,g=/^([A-Za-z0-9+/_\-=]*)$/;function u(e){const t=g.exec(e);return!!t&&t[0]===e}function p(e){const t=g.exec(e);return h(t&&t[0]===e,"ensureSafe() tripped: something is not URI safe"),e}const w=[],f=[],m=[],b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",v=b+"+/",k=b+"-_",S="=",K=16383;for(let e=0,t=v.length;e<t;++e)w[e]=v[e],f[e]=k[e],m[v.charCodeAt(e)]=e;function O(e){if(!u(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,r]=function(e){const t=e.length;let n=e.indexOf(S);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),s=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,r));let o=0;const a=r>0?n-4:n;let i;for(i=0;i<a;i+=4)t=m[e.charCodeAt(i)]<<18|m[e.charCodeAt(i+1)]<<12|m[e.charCodeAt(i+2)]<<6|m[e.charCodeAt(i+3)],s[o++]=t>>16&255,s[o++]=t>>8&255,s[o++]=255&t;return 2===r&&(t=m[e.charCodeAt(i)]<<2|m[e.charCodeAt(i+1)]>>4,s[o++]=255&t),1===r&&(t=m[e.charCodeAt(i)]<<10|m[e.charCodeAt(i+1)]<<4|m[e.charCodeAt(i+2)]>>2,s[o++]=t>>8&255,s[o++]=255&t),s}function C(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function _(e,t,n,r){let s;const o=new Array((r-n)/3);for(let a=n,i=0;a<r;a+=3,i++)s=(t.getUint8(a)<<16&16711680)+(t.getUint8(a+1)<<8&65280)+(255&t.getUint8(a+2)),o[i]=C(e,s);return o.join("")}m["-".charCodeAt(0)]=62,m["_".charCodeAt(0)]=63;const A=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function P(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=A(e),r=A(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function j(e,t="url"){if(null==e)return c("L509","arrayBufferToBase64() -> null paramater"),"";{const n=A(e),r=n.byteLength,s=r%3,o=r-s,a=new Array(Math.floor(o/K)+Math.sign(s)),i="url"==t?f:w,c="";let l=0;for(let e=0;e<o;e+=K)a[l++]=_(i,n,e,e+K>o?o:e+K);if(1===s){const e=n.getUint8(r-1);a[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===s){const e=(n.getUint8(r-2)<<8)+n.getUint8(r-1);a[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return a.join("")}}function E(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function R(){return crypto.getRandomValues(new Uint8Array(1))[0]}const I="0123456789abcdefyhEjkLmNHpFrRTUW";function N(e,t){if("base32mi"==t){const t=crypto.getRandomValues(new Uint8Array(e));let n="";for(let r=0;r<e;r++)n+=I[31&t[r]];return n}return c("simpleRandomString","code "+t+" not supported"),""}function x(e){return e.replace(/[OoQD]/g,"0").replace(/[lIiJ]/g,"1").replace(/[Zz]/g,"2").replace(/[A]/g,"4").replace(/[Ss]/g,"5").replace(/[G]/g,"6").replace(/[t]/g,"7").replace(/[B]/g,"8").replace(/[gq]/g,"9").replace(/[C]/g,"c").replace(/[Y]/g,"y").replace(/[KxX]/g,"k").replace(/[M]/g,"m").replace(/[n]/g,"N").replace(/[P]/g,"p").replace(/[uvV]/g,"U").replace(/[w]/g,"w")}function M(e,t){throw`partition() not tested on TS yet - (${e}, ${t})`}function D(e,t){try{return JSON.parse(e)}catch(n){try{let t="",n="",r=e;for(;r!=(n=t,t=r,r=r?.match(/^(['"])(.*)\1$/m)?.[2]);)return JSON.parse(`'${n}'`)}catch{try{return JSON.parse(e.slice(1,-1))}catch{throw new Error(`JSON.parse() error at ${t} (tried eval and slice)\nString was: ${e}`)}}}}function T(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=D((new TextDecoder).decode(e.slice(4,4+t)),"L476");let r=4+t;const s={};for(const t in n)s.key&&(s[t]=e.slice(r,r+n[t]),r+=n[t]);return s}catch(e){return console.error(e),{}}}function B(e){try{const t={version:"002"};let n=0,r=0;for(const s in e)n++,t[n.toString()]={name:s,start:r,size:e[s].byteLength},r+=e[s].byteLength;const s=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([s.byteLength]);let a=E(new Uint8Array(o.buffer),new Uint8Array(s));for(const t in e)a=E(new Uint8Array(a),e[t]);return a}catch(e){return console.error(e),null}}function $(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=D((new TextDecoder).decode(e.slice(4,4+t)),"L533"),r=4+t;switch(n.version||(n.version="001"),n.version){case"001":return T(e);case"002":{const t=[];for(let s=1;s<Object.keys(n).length;s++){const o=s.toString();if(n[o]){const s=n[o].start,a=n[o].size;t[n[o].name]=e.slice(r+s,r+s+a)}else console.log(`found nothing for index ${s}`)}return t}default:throw new Error("Unsupported payload version ("+n.version+") - fatal")}}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function L(e){return e.replaceAll("+","-").replaceAll("/","_")}function U(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;if(t){if(1===t)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");e+=new Array(5-t).join("=")}return e}class J{extractPubKey(e){try{const t={...e};return delete t.d,delete t.dp,delete t.dq,delete t.q,delete t.qi,t.key_ops=[],t}catch(e){return console.error(e),null}}generateKeys(){return new Promise((async(e,t)=>{try{e(await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]))}catch(e){t(e)}}))}importKey(e,t,n,r,s){const o={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};return"jwk"===e?window.crypto.subtle.importKey("jwk",t,o[n],r,s):window.crypto.subtle.importKey(e,t,o[n],r,s)}deriveKey(e,t,n,r,s){return new Promise((async(o,a)=>{const i={AES:{name:"AES-GCM",length:256},HMAC:{name:"HMAC",hash:"SHA-256",length:256}};try{o(await crypto.subtle.deriveKey({name:"ECDH",public:t},e,i[n],r,s))}catch(o){console.error(o,e,t,n,r,s),a(o)}}))}encrypt(e,t,n,r="encryptedContents"){return new Promise((async(s,o)=>{try{null===e&&o(new Error("no contents"));const a=n&&null!==n?n:crypto.getRandomValues(new Uint8Array(12));"string"==typeof e&&(e=(new TextEncoder).encode(e)),crypto.subtle.encrypt({name:"AES-GCM",iv:a},t,e).then((e=>{s("encryptedContents"===r?{content:p(j(e)),iv:p(j(a))}:e)}))}catch(e){o(e)}}))}wrap(e,t,n){return new Promise((r=>{let s;s="string"===n?H.str2ab(t):t,H.encrypt(s,e).then((e=>{r(e)}))}))}unwrap(e,t,n){return new Promise((async(r,o)=>{try{const{content:a,iv:i}=s(t);crypto.subtle.decrypt({name:"AES-GCM",iv:i},e,a).then((e=>{"string"===n?r((new TextDecoder).decode(e)):"arrayBuffer"===n&&r(e)})).catch((e=>{console.error(`unwrap(): failed to decrypt - rejecting: ${e}`),console.trace(),o(e)}))}catch(e){console.error(`unwrap(): unknown issue - rejecting: ${e}`),console.trace(),o(e)}}))}sign(e,t){return new Promise((async(n,r)=>{try{const s=(new TextEncoder).encode(t);let o;try{o=await crypto.subtle.sign("HMAC",e,s),n(p(j(o)))}catch(e){r(e)}}catch(e){r(e)}}))}verify(e,t,n){return new Promise(((r,s)=>{try{crypto.subtle.verify("HMAC",e,O(t),H.str2ab(n)).then((e=>{r(e)}))}catch(e){s(i(e))}}))}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}compareKeys(e,t){return null!=e&&null!=t&&"object"==typeof e&&"object"==typeof t&&e.x===t.x&&e.y===t.y}}const H=new J;function F(e,t,n){if(n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function G(e,t,n){if(n.get){let r=n.get;n.get=function(){const n=e.constructor.name;`${n}ReadyFlag`in this&&h(this.readyFlag,`${t} getter accessed but object ${n} not ready (fatal)`);const s=r.call(this);return h(null!=s,`${t} getter accessed in object type ${n} but returns NULL (fatal)`),s}}}function V(e,t,n){const r=n.value;n.value=function(...e){for(let n of e){const e=n.constructor.name;"string"==typeof(t=e)&&z.includes(t)&&h(Z(n,e),`invalid parameter: ${n} (expecting ${e})`)}var t;return r.call(this,...e)}}class q{ready;sb384Ready;#t=!1;#n=null;#r=null;#s=null;#o=null;#a=null;constructor(e){this.ready=new Promise(((t,n)=>{try{if(e){this.#r=e;const n=H.extractPubKey(e);h(n,"unable to extract public key"),this.#n=n,H.importKey("jwk",e,"ECDH",!0,["deriveKey"]).then((e=>{this.#s=e,this.#i(this.#n.x,this.#n.y).then((e=>{this.#o=e,this.#t=!0,t(this)}))}))}else H.generateKeys().then((e=>{this.#s=e.privateKey,this.#a=e,Promise.all([crypto.subtle.exportKey("jwk",e.publicKey),crypto.subtle.exportKey("jwk",e.privateKey)]).then((e=>{this.#n=e[0],this.#r=e[1],this.#i(this.#n.x,this.#n.y).then((e=>{this.#o=e,this.#t=!0,t(this)}))}))}))}catch(e){n(`failed to create Identity(): ${e}`)}})),this.sb384Ready=this.ready}#c(e){return new Promise(((t,n)=>{crypto.subtle.digest("SHA-384",e).then((e=>{const n=L(j(e));n.includes("-")?t(this.#c(e)):t(n)}))}))}#i(e,t){return new Promise(((n,r)=>{const s=E(O(U(e)),O(U(t)));n(this.#c(s))}))}get readyFlag(){return this.#t}get exportable_pubKey(){return this.#n}get exportable_privateKey(){return this.#r}get privateKey(){return this.#s}get keyPair(){return this.#a}get _id(){return JSON.stringify(this.exportable_pubKey)}get ownerChannelId(){return this.#o}}n([F],q.prototype,"readyFlag",null),n([F,G],q.prototype,"exportable_pubKey",null),n([F,G],q.prototype,"exportable_privateKey",null),n([F,G],q.prototype,"privateKey",null),n([F,G],q.prototype,"keyPair",null),n([F,G],q.prototype,"_id",null),n([F,G],q.prototype,"ownerChannelId",null);const z=["SBMessage","SBObjectHandle"],W=Symbol.for("SBMessage"),X=Symbol.for("SBObjectHandle");function Z(e,t){switch(t){case"SBMessage":return W in e;case"SBObjectHandle":return X in e}}class Y{ready;channel;contents;[W]=!0;MAX_SB_BODY_SIZE=65536;constructor(e,t=""){h(t.length<this.MAX_SB_BODY_SIZE,"SBMessage(): body must be smaller than 64 KiB"),this.channel=e,this.contents={encrypted:!1,isVerfied:!1,contents:t,sign:"",image:"",imageMetaData:{}},this.ready=new Promise((n=>{e.ready.then((()=>{this.contents.sender_pubKey=this.channel.exportable_pubKey,e.userName&&(this.contents.sender_username=e.userName);const r=this.channel.keys.channelSignKey,s=H.sign(r,t),o=H.sign(r,this.contents.image),a=H.sign(r,JSON.stringify(this.contents.imageMetaData));Promise.all([s,o,a]).then((e=>{this.contents.sign=e[0],this.contents.image_sign=e[1],this.contents.imageMetadata_sign=e[2],n(this)}))}))}))}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}class Q extends Y{data={previewImage:"",fullImage:""};image="";image_sign="";imageMetaData={};constructor(e,t){throw new Error("working on SBFile()!")}async#l(e,t){throw new Error(`#asImage() needs carryover from SBImage etc (${e}, ${t})`)}}class ee extends q{ready;channelReady;#h=!1;#d;motd="";locked=!1;owner=!1;admin=!1;verifiedGuest=!1;userName="";#y;#g;constructor(e,t,n){super(t),this.#d=e,this.#g=new se(this),this.ready=new Promise((e=>{n?(this.#y=n,this.#h=!0,e(this)):this.sb384Ready.then((t=>{this.#y=this.ownerChannelId,this.#h=!0,e(this)}))})),this.channelReady=this.ready}get api(){return this.#g}get sbServer(){return this.#d}get channelId(){return this.#y}get readyFlag(){return this.#h}}function te(e,t,n){return new Promise(((r,o)=>{const a=y.exec(e),i=n.encryptionKey;if(a){let e={type:"encrypted",channelID:a[1],timestampPrefix:a[2],_id:a[1]+a[2],encrypted_contents:s(t)};H.unwrap(i,e.encrypted_contents,"string").then((t=>{let s={...e,...JSON.parse(t)};s.contents&&(s.text=s.contents),s.user={name:s.sender_username?s.sender_username:"Unknown",_id:s.sender_pubKey},s.verificationToken&&!s.sender_pubKey?console.info("WARNING: message with verification token is lacking sender identity.\n         This may not be allowed in the future."):H.importKey("jwk",s.sender_pubKey,"ECDH",!0,[]).then((e=>{H.deriveKey(n.signKey,e,"HMAC",!1,["sign","verify"]).then((e=>{H.verify(e,s.sign,s.contents).then((t=>{t||(console.log("***** signature is NOT correct message (rejecting)"),console.log("verifyKey:"),console.log(Object.assign({},e)),console.log("m2.sign"),console.log(Object.assign({},s.sign)),console.log("m2.contents"),console.log(structuredClone(s.contents)),console.log("Message:"),console.log(Object.assign({},s)),console.trace(),o(null)),r(s)}))}))}))}))}else console.log("++++++++ #processMessage: ERROR - cannot parse channel ID / timestamp, invalid message"),console.log(Object.assign({},e)),console.log(Object.assign({},t)),o(null)}))}n([F,G],ee.prototype,"channelId",null);class ne extends ee{ready;#u=!1;#p;#w;#f=null;#d;adminData;#m;#b=[];#v=!1;constructor(e,t,n,r){super(e,n,r),h(e.channel_ws,"ChannelSocket(): no websocket server name provided");const s=e.channel_ws+"/api/room/"+r+"/websocket";this.#m=t,this.#d=e,this.#p={url:s,ready:!1,closed:!1,timeout:2e3},this.ready=this.#k()}close=()=>{if(this.#p.websocket)return this.#p.websocket.close()};#S(e){this.#v&&(console.log("got raw message (string):"),console.log(structuredClone(e)));const t=D(e,"L1489");if(this.#v&&(console.log("... json unwrapped version of raw message:"),console.log(Object.assign({},t))),t.ack){const e=this.#b[t._id];e&&(console.log(`++++++++ found matching ack for id ${t._id} (on first check?)`),delete this.#b[t._id],e("success"))}else if(t.nack)console.error("Nack received"),this.#p.closed=!0;else if("function"==typeof this.#m){const e=t;try{let n=Object.entries(e)[0][1];if("encrypted_contents"===Object.keys(n)[0]){const e=Object.entries(t)[0][0],r=n.encrypted_contents.iv;r&&u(r)&&16==r.length?n.encrypted_contents.iv=O(r):console.error("processMessage() - iv is malformed, should be 16-char b64 string (ignoring)"),this.#v&&(console.log("vvvvvv - calling deCryptChannelMessage() with arg1, arg2, arg3:"),console.log(structuredClone(e)),console.log(structuredClone(n.encrypted_contents)),console.log(structuredClone(this.keys)),console.log("^^^^^^ - (end parameter list)")),te(e,n.encrypted_contents,this.keys).then((e=>{this.#v&&console.log(Object.assign({},e)),this.#m(e)})).catch((()=>{console.log("Error processing message, dropping it")}))}else if("ack"===n.type){this.#v&&console.log("++++++++ Received 'ack'");const e=n._id,t=this.#b[e];t?(this.#v&&console.log(`++++++++ found matching ack for id ${e}`),delete this.#b[e],t("success")):console.info(`WARNING: did not find matching ack for id ${e}`)}else console.log("++++++++ #processMessage: can't decipher message, passing along unchanged:"),console.log(Object.assign({},e)),this.#m(e)}catch(t){console.log(`++++++++ #processMessage: caught exception while decyphering (${t}), passing it along unchanged`),this.#m(e)}}else c("ChannelSocket","received message but there is no handler")}checkServerStatus(e,t,n){const r=new XMLHttpRequest;r.onreadystatechange=()=>{r.readyState===XMLHttpRequest.DONE&&(200===r.status?n(!0):n(!1))},r.open("HEAD",e),r.timeout=t,r.send()}#k(){const e=this.#p.url;let t=[],n=!1;return new Promise(((r,s)=>{try{console.log("++++++++ readyPromise() has url:"),console.log(e),this.#p.websocket||(this.#p.websocket=new WebSocket(this.#p.url)),3===this.#p.websocket.readyState?this.#p.websocket=new WebSocket(e):2===this.#p.websocket.readyState&&(console.log("STRANGE - trying to use a ChannelSocket that is in the process of closing ..."),this.#p.websocket=new WebSocket(e)),this.#p.websocket.addEventListener("open",(()=>{this.#p.closed=!1,this.channelReady.then((()=>{this.#p.init={name:JSON.stringify(this.exportable_pubKey)},this.#p.websocket.send(JSON.stringify(this.#p.init))}))})),this.#p.websocket.addEventListener("message",(e=>{if(n)return void t.push(e.data);n=!0;const s=JSON.parse(e.data);h(s.ready,"got roomKeys but channel reports it is not ready (?)"),this.motd=s.motd,this.locked=s.roomLocked;const o=JSON.parse(s.keys.ownerKey);this.#f=o,Promise.all([H.importKey("jwk",JSON.parse(s.keys.ownerKey),"ECDH",!1,[]),H.importKey("jwk",JSON.parse(s.keys.encryptionKey),"AES",!1,["encrypt","decrypt"]),H.importKey("jwk",JSON.parse(s.keys.signKey),"ECDH",!0,["deriveKey"]),H.importKey("jwk",H.extractPubKey(JSON.parse(s.keys.signKey)),"ECDH",!0,[])]).then((e=>{const n=e[0],s=e[1],a=e[2],i=e[3],c=this.privateKey;Promise.all([H.deriveKey(c,i,"HMAC",!1,["sign","verify"])]).then((e=>{const i=e[0];this.#w={ownerKey:n,encryptionKey:s,signKey:a,channelSignKey:i,privateKey:this.privateKey};const c=this.api.getAdminData();this.owner=H.compareKeys(o,this.exportable_pubKey),Promise.all([c]).then((e=>{this.adminData=e[0],this.admin=this.owner,t.length>0&&queueMicrotask((()=>{console.log("++++++++ readyPromise() inside micro task");for(let e in t)this.#S(e)})),this.#p.websocket.addEventListener("message",(e=>{this.#S(e.data)})),this.#u=!0,r(this)}))}))}))})),this.#p.websocket.addEventListener("close",(e=>{this.#p.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?s(`No such channel on this server (${this.#d.channel_server})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.#d.channel_server}`),s("wbSocket() closed before it was opened (?)")})),this.#p.websocket.addEventListener("error",(e=>{this.#p.closed=!0,console.log("ChannelSocket() error: ",e),s("ChannelSocket creation error (see log)")}))}catch(e){this.#p.closed=!0,s(`failed to create ChannelSocket, see log ${i(e)}`)}}))}get status(){if(!this.#p.websocket)return"CLOSED";switch(this.#p.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#m=e}get onMessage(){return this.#m}set enableTrace(e){this.#v=e,console.log(`Tracing ${e?"en":"dis"}abled`)}get keys(){return this.#w||h(!1,"ChannelSocket.keys: not initialized (?)"),this.#w}async sendSbObject(e){return this.send(e)}send(e){let t="string"==typeof e?new Y(this,e):e;return h(this.#p.websocket,"ChannelSocket.send() called before ready"),this.#p.closed&&(this.#v&&console.info("send() triggered reset of #readyPromise() (normal)"),this.ready=this.#k()),new Promise(((e,n)=>{t.ready.then((t=>{this.ready.then((()=>{switch(this.#v&&(console.log("++++++++ ChannelSocket.send() this message (cloned): "),console.log(Object.assign({},t))),this.#u||n("ChannelSocket.send() is confused - ready or not?"),this.#p.websocket.readyState){case 1:this.#v&&(console.log("Wrapping message contents:"),console.log(Object.assign({},t.contents))),H.wrap(this.keys.encryptionKey,JSON.stringify(t.contents),"string").then((t=>{this.#v&&(console.log("ChannelSocket.send():"),console.log(Object.assign({},t)));const r=JSON.stringify({encrypted_contents:t});this.#v&&(console.log("++++++++ ChannelSocket.send() got this from wrap:"),console.log(structuredClone(r)),console.log("++++++++ ChannelSocket.send() then got this from JSON.stringify:"),console.log(Object.assign({},t))),crypto.subtle.digest("SHA-256",(new TextEncoder).encode(r)).then((t=>{const s=j(t),o={timestamp:Date.now(),type:"ack",_id:s};this.#b[s]=e,this.#v&&(console.log("++++++++ ChannelSocket.send() this message:"),console.log(structuredClone(r))),this.#p.websocket.send(r),this.#p.websocket.send(JSON.stringify(o)),setTimeout((()=>{if(this.#b[s]){delete this.#b[s];const e=`Websocket request timed out (no ack) after ${this.#p.timeout}ms (${s})`;console.error(e),n(e)}else this.#v&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#p.timeout)}))}));break;case 3:case 0:case 2:const r="socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING";c("ChannelSocket",r),n(r)}}))}))}))}get exportable_owner_pubKey(){return this.#f}}n([V],ne.prototype,"send",null),n([F,G],ne.prototype,"exportable_owner_pubKey",null);class re{server;channelServer;constructor(e,t){this.server=e+"/api/v1",this.channelServer=t+"/api/room/"}#K(e){return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({id:p(j(n)),key:p(j(r))})}))}catch(e){n(e)}}))}#O(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=E(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),r}#C(e){const t=new DataView(e.slice(-4)).getUint32(0);return e.slice(0,t)}#_(e,t){return new Promise(((n,r)=>{try{H.importKey("raw",O(decodeURIComponent(e)),"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{console.log(e),n(e)}))}))}catch(e){r(e)}}))}#A(e,t){return new Promise(((n,r)=>{a(this.server+"/storeRequest?name="+e+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=$(e);n({salt:new Uint8Array(t.salt),iv:new Uint8Array(t.iv)})})).catch((e=>{console.log(`ERROR: ${e}`),r(e)}))}))}#P(e,t,n,r,s,o,i){return new Promise(((c,l)=>{this.#_(n,i).then((n=>{H.encrypt(e,n,o,"arrayBuffer").then((e=>{a(this.channelServer+s+"/storageRequest?size="+e.byteLength).then((e=>e.json())).then((n=>{n.hasOwnProperty("error")&&l("storage token request error");let s=JSON.stringify(n);this.storeData(r,t,o,i,s,e).then((e=>{e.error&&l(`storeObject() failed: ${e.error}`),e.image_id!=t&&l(`received imageId ${e.image_id} but expected ${t}`),c(e.verification_token)})).catch((e=>{console.log("ERROR in _storeObject(): ${e}"),l(e)}))}))}))}))}))}getObjectMetadata(e,t){return new Promise(((n,r)=>{const s=this.#O(e);this.#K(s).then((e=>{this.#A(e.id,t).then((r=>{const o={[X]:!0,version:"1",type:t,id:e.id,key:e.key,iv:r.iv,salt:r.salt,paddedBuffer:s};n(o)})).catch((e=>r(e)))}))}))}storeObject(e,t,n,r){return new Promise(((s,o)=>{e instanceof ArrayBuffer||o("buf must be an ArrayBuffer");const a=e.byteLength;if(r){const e={[X]:!0,version:"1",type:t,id:r.id,key:r.key,iv:r.iv,salt:r.salt,actualSize:a,verification:this.#P(r.paddedBuffer,r.id,r.key,t,n,r.iv,r.salt)};s(e)}else{const r=this.#O(e);this.#K(r).then((e=>{this.#A(e.id,t).then((o=>{const i={[X]:!0,version:"1",type:t,id:e.id,key:e.key,iv:o.iv,salt:o.salt,actualSize:a,verification:this.#P(r,e.id,e.key,t,n,o.iv,o.salt)};s(i)})).catch((e=>o(e)))}))}}))}saveFile(e,t){console.log("saveFile()");const n=t.imageMetaData,r=this.storeImage(t.data.fullImage,n.imageId,n.imageKey,"f"),s=this.storeImage(t.data.previewImage,n.previewId,n.previewKey,"p");Promise.all([r,s]).then((n=>{n.forEach((t=>{e.sendSbObject({...t,control:!0})})),e.send(t)}))}storeRequest(e){return new Promise(((t,n)=>{a(this.server+"/storeRequest?name="+e).then((e=>(e.ok||n(new Error("Network response was not OK")),e.arrayBuffer()))).then((e=>{t(e)})).catch((e=>{n(e)}))}))}storeData(e,t,n,r,s,o){return new Promise(((i,c)=>{a(this.server+"/storeData?type="+e+"&key="+p(t),{method:"POST",body:B({iv:n,salt:r,image:o,storageToken:(new TextEncoder).encode(s),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||c("response from storage server was not OK"),e.json()))).then((e=>{i(e)})).catch((e=>{c(e)}))}))}storeImage(e,t,n,r){throw new Error("StorageApi.storeImate() needs TS version")}#j(e,t){return new Promise(((n,r)=>{console.log("#processData()"),console.log(e),console.log(t);try{let t=JSON.parse(H.ab2str(new Uint8Array(e)));t.error&&r(`#processData() error: ${t.error}`)}catch(e){}finally{const r=$(e);console.log(r);const s=new Uint8Array(r.iv);t.iv&&!P(s,t.iv)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${j(t.iv)}`),console.log(`server iv: ${j(r.iv)}`));const o=new Uint8Array(r.salt);t.salt&&h(P(o,t.salt),"salt differs"),console.log("will use nonce and salt of:"),console.log(`iv: ${j(s)}`),console.log(`salt : ${j(o)}`),this.#_(t.key,o).then((e=>{const t=H.ab2str(new Uint8Array(r.image));console.log("image_key: "),console.log(e),H.unwrap(e,{content:t,iv:s},"arrayBuffer").then((e=>{const t=this.#C(e);n(t)}))}))}}))}fetchData(e){return new Promise(((t,n)=>{try{e||n("invalid"),"string"==typeof e.verification&&(e.verification=new Promise((t=>{t(e.verification)}))),e.verification.then((r=>{h(r,"fetchData(): missing verification token (?)"),a(this.server+"/fetchData?id="+p(e.id)+"&type="+e.type+"&verification_token="+r,{method:"GET"}).then((e=>(e.ok||n(new Error("Network response was not OK")),e.arrayBuffer()))).then((n=>{t(this.#j(n,e))}))}))}catch(e){n(e)}}))}async retrieveImage(e,t,n,r,s){console.trace("retrieveImage()"),console.log(e);const o=n||e.previewId,a=r||e.previewKey,i=s||"p",c=t.find((e=>e.id&&e.id==o));if(console.log(c),c){h(c.verificationToken,"retrieveImage(): verificationToken missing (?)"),h(c.id,"retrieveImage(): id missing (?)");const e={[X]:!0,version:"1",type:i,id:c.id,key:a,verification:new Promise(((e,t)=>{c.verificationToken?e(c.verificationToken):t("retrieveImage(): verificationToken missing (?)")}))},t=await this.fetchData(e);return console.log(t),{url:"data:image/jpeg;base64,"+j(t,"b64")}}return{error:"Failed to fetch data - missing control message for that image"}}}n([V],re.prototype,"fetchData",null);class se{#d;#E;#R;#I;#N;constructor(e){this.#R=e,this.#d=this.#R.sbServer,this.#E=this.#d.channel_server,this.#I=this.#E+"/api/",this.#N=this.#E+"/api/room/"}getLastMessageTimes(){return new Promise(((e,t)=>{a(this.#I+"/getLastMessageTimes",{method:"POST",body:JSON.stringify([this.#R.channelId])}).then((e=>(e.ok||t(new Error("Network response was not OK")),e.json()))).then((t=>{e(t[this.#R.channelId])})).catch((e=>{t(e)}))}))}getOldMessages(e){return new Promise(((t,n)=>{a(this.#N+this.#R.channelId+"/oldMessages?currentMessagesLength="+e,{method:"GET"}).then((e=>(e.ok||n(new Error("Network response was not OK")),e.json()))).then((e=>{Promise.all(Object.keys(e).filter((t=>e[t].hasOwnProperty("encrypted_contents"))).map((t=>te(t,e[t].encrypted_contents,this.#R.keys)))).then((e=>{t(e)}))})).catch((e=>{n(e)}))}))}#x(e,t){return console.log(e),t&&console.log(t),new Promise(((n,r)=>{try{a(this.#N+this.#R.channelId+e,t).then((e=>(e.ok||r(new Error("Network response was not OK")),e.json()))).then((e=>{e.error&&r(new Error(e.error)),n(e)})).catch((e=>{r("ChannelApi Error [1]: "+i(e))}))}catch(e){r("ChannelApi Error [2]: "+i(e))}}))}updateCapacity(e){return this.#x("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.#x("/getRoomCapacity")}getJoinRequests(){return this.#x("/getJoinRequests")}isLocked(){return new Promise((e=>this.#x("/roomLocked").then((t=>{console.log(t),e(!0===t.locked)}))))}setMOTD(e){return this.#x("/motd",{method:"POST",body:JSON.stringify({motd:e}),headers:{"Content-Type":"application/json"}})}getAdminData(){return new Promise((async(e,t)=>{const n=(new Date).getTime().toString();H.sign(this.#R.keys.channelSignKey,n).then((e=>this.#x("/getAdminData",{method:"GET",credentials:"include",headers:{authorization:n+"."+e,"Content-Type":"application/json"}})))}))}downloadData(){return new Promise(((e,t)=>{a(this.#N+this.#R.channelId+"/downloadData",{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>(e.ok||t(new Error("Network response was not OK")),e.json()))).then((t=>{Promise.all(Object.keys(t).filter((e=>{const n=new RegExp(this.#R.channelId);if(e.match(n)){const n=D(t[e],"L3318");if(n.hasOwnProperty("encrypted_contents"))return console.log(n),n}})).map((e=>{const n=D(t[e],"L3327");return console.log(e,n.encrypted_contents,this.#R.keys),te(e,n.encrypted_contents,this.#R.keys)}))).then((n=>{let r={};n.forEach((e=>{if(!e.control&&e.imageMetaData.imageId){const t=n.find((t=>t.id&&t.id==e.imageMetaData.imageId)),s=n.find((t=>t.id&&t.id==e.imageMetaData.previewId));r[`${e.imageMetaData.imageId}.f`]=t?.verificationToken,r[`${e.imageMetaData.previewId}.p`]=s?.verificationToken}})),e({storage:r,channel:t})}))})).catch((e=>{t(e)}))}))}uploadChannel(e){return new Promise(((t,n)=>{a(this.#N+this.#R.channelId+"/uploadRoom",{method:"POST",body:JSON.stringify(e),headers:{"Content-Type":"application/json"}}).then((e=>(e.ok||n(new Error("Network response was not OK")),e.json()))).then((e=>{t(e)})).catch((e=>{n(e)}))}))}authorize(e,t){return this.#x("/authorizeRoom",{method:"POST",body:JSON.stringify({roomId:this.#R.channelId,SERVER_SECRET:t,ownerKey:e})})}postPubKey(e){return this.#x("/postPubKey?type=guestKey",{method:"POST",body:JSON.stringify(e),headers:{"Content-Type":"application/json"}})}storageRequest(e){return this.#x("/storageRequest?size="+e,{method:"GET",credentials:"include",headers:{"Content-Type":"application/json"}})}lock(){return console.trace("WARNING: lock() on channel api has not been tested/debugged fully .."),new Promise((async(e,t)=>{if(null==this.#R.keys.lockedKey&&this.#R.admin){const n=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),r=await crypto.subtle.exportKey("jwk",n);this.#x("lockRoom").then((t=>{t.locked&&this.acceptVisitor(JSON.stringify(this.#R.exportable_pubKey)).then((()=>{e({locked:t.locked,lockedKey:r})}))})).catch((e=>{t(e)}))}else t(new Error("no lock key or not admin"))}))}acceptVisitor(e){return console.trace("WARNING: acceptVisitor() on channel api has not been tested/debugged fully .."),new Promise((async(t,n)=>{const r=await H.deriveKey(this.#R.keys.privateKey,await H.importKey("jwk",D(e,"L2276"),"ECDH",!1,[]),"AES",!1,["encrypt","decrypt"]),s=await H.encrypt(H.str2ab(JSON.stringify(this.#R.keys.lockedKey)),r);a(this.#N+this.#R.channelId+"/acceptVisitor",{method:"POST",body:JSON.stringify({pubKey:e,lockedKey:JSON.stringify(s)}),headers:{"Content-Type":"application/json"}}).then((e=>(e.ok||n(new Error("Network response was not OK")),e.json()))).then((e=>{t(e)})).catch((e=>{n(e)}))}))}ownerKeyRotation(){return console.trace("WARNING: ownerKeyRotation() on channel api has not been tested/debugged fully .."),new Promise(((e,t)=>{a(this.#N+this.#R.channelId+"/ownerKeyRotation",{method:"GET",credentials:"include",headers:{"Content-Type":"application/json"}}).then((e=>(e.ok||t(new Error("Network response was not OK")),e.json()))).then((t=>{e(t)})).catch((e=>{t(e)}))}))}}n([function(e,t,n){const r=n.value;n.value=function(...s){try{return r.call(this,...s)}catch(r){return console.log(`ExceptionReject: ${i(r)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${i(r)}`)))}}}],se.prototype,"isLocked",null);class oe{#M;#R;#D;constructor(e){e&&(this.#D=Object.assign({},e),this.#M=new re(e.storage_server,e.channel_server))}connect(e,t,n){return t&&console.log(t),n&&console.log(n),new Promise(((s,o)=>{if(!this.#D)return Promise.any(r.map((r=>new ne(r,e,t,n).ready)));s(new ne(this.#D,e,t,n))}))}create(e,t,n){return new Promise((async(r,s)=>{try{const o=new q(n),i=await o.ready.then((e=>e.keyPair)),c=await crypto.subtle.exportKey("jwk",i.privateKey),l=await crypto.subtle.exportKey("jwk",i.publicKey),h=o.ownerChannelId,d=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),y=await crypto.subtle.exportKey("jwk",d),g=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]),u=await crypto.subtle.exportKey("jwk",g.privateKey),p={roomId:h,ownerKey:JSON.stringify(l),encryptionKey:JSON.stringify(y),signKey:JSON.stringify(u),SERVER_SECRET:t},w=(new TextEncoder).encode(JSON.stringify(p));let f=await a(e.channel_server+"/api/room/"+h+"/uploadRoom",{method:"POST",body:w});f=await f.json(),f.success?r({channelId:h,key:c}):s(JSON.stringify(f))}catch(e){s(e)}}))}get channel(){return this.#R}get storage(){return this.#M}get crypto(){return H}sendFile(e){this.storage.saveFile(this.#R,e)}}var ae={Snackabra:oe,SBMessage:Y,Channel:ee,SBCrypto:J,SB384:q};return t})()));