!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>Be,ChannelSocket:()=>Ce,KeyPrefix:()=>ce,MessageBus:()=>u,NEW_CHANNEL_MINIMUM_BUDGET:()=>s,SB:()=>Ie,SB384:()=>Se,SBChannelKeys:()=>ke,SBCrypto:()=>le,SBMessage:()=>Ke,SBObjectHandle:()=>Ee,Snackabra:()=>Re,StorageApi:()=>Pe,arrayBuffer32ToBase62:()=>G,arrayBufferToBase62:()=>N,arrayBufferToBase64:()=>x,assemblePayload:()=>te,assemblePayload2:()=>X,base62ToArrayBuffer:()=>H,base62ToArrayBuffer32:()=>V,base62ToBase64:()=>q,base64ToArrayBuffer:()=>P,base64ToBase62:()=>z,compareBuffers:()=>j,decodeB64Url:()=>ie,encodeB64Url:()=>oe,extractPayload:()=>se,extractPayload2:()=>ne,getRandomValues:()=>g,isBase62Encoded:()=>W,jsonParseWrapper:()=>Z,msgTtlToSeconds:()=>h,msgTtlToString:()=>y,partition:()=>Y,sbCrypto:()=>me,validate_ChannelApiBody:()=>o,validate_ChannelMessage:()=>i,version:()=>a});var n,r=function(e,t,n,r){var a,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(a=e[i])&&(o=(s<3?a(o):s>3?a(t,n,o):a(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};const a="2.0.0-alpha.5 (build 30)",s=33554432;function o(e){if(e){if(e[pe])return e;if(e.channelId&&43===e.channelId.length&&e.path&&"string"==typeof e.path&&e.path.length>0&&e.userId&&"string"==typeof e.userId&&43===e.userId.length&&e.userPublicKey&&e.userPublicKey.length>0&&(!e.isOwner||"boolean"==typeof e.isOwner)&&(!e.apiPayload||e.apiPayload instanceof ArrayBuffer)&&e.timestamp&&"number"==typeof e.timestamp&&e.sign&&e.sign instanceof ArrayBuffer)return{...e,[pe]:!0};throw c&&console.error("invalid ChannelApiBody ... trying to ingest:\n",e),new Error("invalid ChannelApiBody")}throw new Error("invalid ChannelApiBody (null or undefined)")}function i(e){if(e){if(e[fe])return e;if(e._id&&("string"!=typeof e._id||86!==e._id.length)||e.ready&&"boolean"!=typeof e.ready||e.timestampPrefix&&("string"!=typeof e.timestampPrefix||26!==e.timestampPrefix.length)||e.channelId&&("string"!=typeof e.channelId||43!==e.channelId.length)||e.contents&&!(e.contents instanceof ArrayBuffer)||e.sender&&("string"!=typeof e.sender||43!==e.sender.length)||e.encryptedContents&&!(e.encryptedContents instanceof ArrayBuffer)||e.timestamp&&"number"!=typeof e.timestamp||e.ttl&&"number"!=typeof e.ttl||e.iv&&!(e.iv instanceof ArrayBuffer)||e.sign&&!(e.sign instanceof ArrayBuffer))throw c&&console.error("invalid ChannelMessage ... trying to ingest:\n",e),new Error("invalid ChannelMessage");return{...e,[fe]:!0}}throw new Error("invalid ChannelMessage (null or undefined)")}var c=!0,l=!1;const h=[0,60,300,1200,3600,14400,64800,259200,1036800,4147200,31622400,0,0,0,0,1/0],y=["Ephemeral","One minute","Five minutes","Twenty minutes","One hour","4 hours","18 hours","72 hours","12 days","48 days","One year","<reserved>","<reserved>","<reserved>","<reserved>","Permastore (no limit)"];class u{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function d(e,t){return new Promise(((n,r)=>{try{fetch(e,t??{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>{n(e)})).catch((e=>{throw e}))}catch(e){const t=`[SBFetch] Error (fetch exception, might be normal operation): ${e}`;console.warn(t),r(t)}}))}function f(e){return e instanceof Error?e:new Error(String(e))}function p(e,t){if(!e){const e=`[_sb_assert] << SB assertion error: ${t} >>`;throw c&&console.trace(e),new Error(e)}}function g(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{p(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}const w=/^([A-Za-z0-9+/_\-=]*)$/;function b(e){return w.test(e)}const v=b,m=[],S=[],k=[],A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",K=A+"+/",B=A+"-_",C="=",E=16383;for(let e=0,t=K.length;e<t;++e)m[e]=K[e],S[e]=B[e],k[K.charCodeAt(e)]=e;function P(e){if(!b(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,r]=function(e){const t=e.length;let n=e.indexOf(C);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),a=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,r));let s=0;const o=r>0?n-4:n;let i;for(i=0;i<o;i+=4)t=k[e.charCodeAt(i)]<<18|k[e.charCodeAt(i+1)]<<12|k[e.charCodeAt(i+2)]<<6|k[e.charCodeAt(i+3)],a[s++]=t>>16&255,a[s++]=t>>8&255,a[s++]=255&t;return 2===r&&(t=k[e.charCodeAt(i)]<<2|k[e.charCodeAt(i+1)]>>4,a[s++]=255&t),1===r&&(t=k[e.charCodeAt(i)]<<10|k[e.charCodeAt(i+1)]<<4|k[e.charCodeAt(i+2)]>>2,a[s++]=t>>8&255,a[s++]=255&t),a}function R(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function I(e,t,n,r){let a;const s=new Array((r-n)/3);for(let o=n,i=0;o<r;o+=3,i++)a=(t.getUint8(o)<<16&16711680)+(t.getUint8(o+1)<<8&65280)+(255&t.getUint8(o+2)),s[i]=R(e,a);return s.join("")}k["-".charCodeAt(0)]=62,k["_".charCodeAt(0)]=63;const O=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function j(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=O(e),r=O(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function x(e,t="url"){if(null==e)return function(e,t){throw new Error("[_sb_exception] << SB lib error (L893: arrayBufferToBase64() -> null paramater) >>")}(),"";{const n=O(e),r=n.byteLength,a=r%3,s=r-a,o=new Array(Math.floor(s/E)+Math.sign(a)),i="url"==t?S:m,c="";let l=0;for(let e=0;e<s;e+=E)o[l++]=I(i,n,e,e+E>s?s:e+E);if(1===a){const e=n.getUint8(r-1);o[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===a){const e=(n.getUint8(r-2)<<8)+n.getUint8(r-1);o[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return o.join("")}}const D="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",_=/^(a32\.)?[0-9A-Za-z]{43}$/,T=/^[0-9a-zA-Z]*$/,M=new Map([[32,43],[16,22],[8,11],[4,6]]),U=new Map(Array.from(M,(([e,t])=>[t,e]))),L=Array.from(U.keys()).sort(((e,t)=>e-t));function $(e,t){if(e.byteLength!==t||!M.has(t))throw new Error("[arrayBufferToBase62] Decoding error");let n="";for(let t=BigInt("0x"+Array.from(new Uint8Array(e)).map((e=>e.toString(16).padStart(2,"0"))).join(""));t>0n;t/=62n)n=D[Number(t%62n)]+n;return n.padStart(M.get(t),"0")}function N(e){let t=e.byteLength;if(t%4!=0)throw new Error("[arrayBufferToBase62] Must be multiple of 4 bytes (32 bits).");let n=0,r="";for(;t>0;){let a=2**Math.min(Math.floor(Math.log2(t)),5);r+=$(e.slice(n,n+a),a),n+=a,t-=a}return r}function F(e,t){let n=0n;try{for(let t=0;t<e.length;t++)n=62n*n+BigInt(D.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new Error(`base62ToArrayBuffer: value exceeds ${8*t} bits.`);const r=new ArrayBuffer(t),a=new DataView(r);for(let e=0;e<t/4;e++){const r=Number(BigInt.asUintN(32,n));a.setUint32(4*(t/4-e-1),r),n>>=32n}return r}catch(e){throw console.error("[_base62ToArrayBuffer] Error: ",e),e}}function H(e){if(!T.test(e))throw new Error("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");let t,n=0,r=0,a=43,s=new Uint8Array(e.length);try{for(;n<e.length;){if(t=L.filter((t=>t<=e.length-n)).pop(),a<43&&t>=a)throw new Error("cannot decypher b62 string (incorrect length)");a=t;let o=e.slice(n,n+t);const i=new Uint8Array(F(o,U.get(t)));s.set(i,r),n+=t,r+=i.byteLength}return s.buffer.slice(0,r)}catch(e){throw console.error("[base62ToArrayBuffer] Error:",e),e}}function V(e){if(!_.test(e))throw new Error(`base62ToArrayBuffer32: string must match: ${_}, value provided was ${e}`);return H(e)}function G(e){if(32!==e.byteLength)throw new Error("arrayBufferToBase62: buffer must be exactly 32 bytes (256 bits).");return N(e)}function q(e){return x(V(e))}function z(e){return N(P(e))}function W(e){return _.test(e)}function J(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function Y(e,t){throw`partition() not tested on TS yet - (${e}, ${t})`}function Z(e,t,n){for(;e&&"string"==typeof e;)try{e=JSON.parse(e,n)}catch(n){throw new Error(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}function X(e){try{const t={version:"002"};let n=0,r=0;for(const a in e)n++,t[n.toString()]={name:a,start:r,size:e[a].byteLength},r+=e[a].byteLength;const a=(new TextEncoder).encode(JSON.stringify(t)),s=new Uint32Array([a.byteLength]);let o=J(new Uint8Array(s.buffer),new Uint8Array(a));for(const t in e)o=J(new Uint8Array(o),e[t]);return o}catch(e){return console.error(e),null}}function Q(e){return null===e?"0":void 0===e?"u":Array.isArray(e)?"a":e instanceof ArrayBuffer?"x":"boolean"==typeof e?"b":e instanceof DataView?"v":e instanceof Date?"d":e instanceof Map?"m":"number"==typeof e?"number"==typeof(t=e)&&t>=-2147483648&&t<=2147483647&&t%1==0?"i":"n":null!==e&&"object"==typeof e&&e.constructor===Object?"o":e instanceof Set?"t":"string"==typeof e?"s":!ArrayBuffer.isView(e)||e instanceof DataView?(console.error("[getType] Unsupported for object:",e),"<unsupported>"):"Uint8Array"===e.constructor.name?"8":(console.error("[getType] Unsupported typed array:",e.constructor.name),"<unsupported>");var t}function ee(e){try{const t={};let n=0,r=0,a=[];for(const s in e)if(e.hasOwnProperty(s)){const o=e[s],i=Q(o);switch(i){case"o":const e=ee(o);if(!e)throw new Error(`Failed to assemble payload for ${s}`);a.push(e);break;case"n":const t=new Uint8Array(8);new DataView(t.buffer).setFloat64(0,o),a.push(t.buffer);break;case"i":const n=new Uint8Array(4);new DataView(n.buffer).setInt32(0,o),a.push(n.buffer);break;case"d":const r=new Uint8Array(8);new DataView(r.buffer).setFloat64(0,o.getTime()),a.push(r.buffer);break;case"b":const c=new Uint8Array(1);c[0]=o?1:0,a.push(c.buffer);break;case"s":const l=(new TextEncoder).encode(o);a.push(l);break;case"x":a.push(o);break;case"8":a.push(o.buffer);break;case"m":const h=new Array;o.forEach(((e,t)=>{h.push([t,e])}));const y=ee(h);if(!y)throw new Error(`Failed to assemble payload for ${s}`);a.push(y);break;case"a":const u=new Array;o.forEach((e=>{u.push(e)}));const d=ee(u);if(!d)throw new Error(`Failed to assemble payload for ${s}`);a.push(d);break;case"t":const f=new Array;o.forEach((e=>{f.push(e)}));const p=ee(f);if(!p)throw new Error(`Failed to assemble payload for ${s}`);a.push(p);break;case"0":case"u":a.push(new ArrayBuffer(0));break;default:throw console.error(`[assemblePayload] Unsupported type: ${i}`),new Error(`Unsupported type: ${i}`)}const c=a[a.length-1].byteLength;n++,t[n.toString()]={n:s,s:r,z:c,t:i},r+=c}const s=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([s.byteLength]);let i=J(new Uint8Array(o.buffer),new Uint8Array(s));for(let e=0;e<a.length;e++)i=J(new Uint8Array(i),a[e]);return i}catch(e){return console.error(e),null}}function te(e){return ee({ver003:!0,payload:e})}function ne(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=Z((new TextDecoder).decode(e.slice(4,4+t)),"L533"),r=4+t;switch(n.version||(n.version="001"),n.version){case"001":throw new Error("extractPayload() exception: version 001 is no longer supported");case"002":{const t=[];for(let a=1;a<Object.keys(n).length;a++){const s=a.toString();if(n[s]){const a=n[s].start,o=n[s].size;t[n[s].name]=e.slice(r+a,r+a+o)}else console.log(`found nothing for index ${a}`)}return t}default:throw new Error("Unsupported payload version ("+n.version+") - fatal")}}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function re(e,t){switch(t){case"o":return ae(e);case"n":return new DataView(e).getFloat64(0);case"i":return new DataView(e).getInt32(0);case"d":return new Date(new DataView(e).getFloat64(0));case"b":return 1===new Uint8Array(e)[0];case"s":return(new TextDecoder).decode(e);case"a":const n=ae(e);if(!n)throw new Error(`Failed to assemble payload for ${t}`);return Object.values(n);case"m":const r=ae(e);if(!r)throw new Error(`Failed to assemble payload for ${t}`);const a=new Map;for(const e in r)a.set(r[e][0],r[e][1]);return a;case"t":const s=ae(e);if(!s)throw new Error(`Failed to assemble payload for ${t}`);const o=new Set;for(const e in s)o.add(s[e]);return o;case"x":return e;case"8":return new Uint8Array(e);case"0":return null;case"u":return;default:throw new Error(`Unsupported type: ${t}`)}}function ae(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=Z((new TextDecoder).decode(e.slice(4,4+t)),"L1308"),r=4+t,a={};for(let t=1;t<=Object.keys(n).length;t++){const s=t.toString();if(n[s]){const t=n[s],o=t.s,i=t.z,c=t.t,l=e.slice(r+o,r+o+i);a[t.n]=re(l,c)}else console.log(`found nothing for index ${t}`)}return a}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function se(e){return ae(e)}function oe(e){return e.replaceAll("+","-").replaceAll("/","_")}function ie(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;return t&&(p(1!==t,"InvalidLengthError: Input base64url string is the wrong length to determine padding"),e+=new Array(5-t).join("=")),e}var ce;!function(e){e.SBPublicKey="PNk2",e.SBPrivateKey="Xj3p"}(ce||(ce={}));class le{generateIdKey(e){return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({id_binary:n,key_material:r})}))}catch(e){n(e)}}))}extractPubKey(e){try{const t={...e};return delete t.d,delete t.dp,delete t.dq,delete t.q,delete t.qi,t.key_ops=[],t}catch(e){return console.error(e),null}}async#t(e,t){let n=0,r=x(e);for(;r!==t;){if(n++>160)return!1;r=x(e=await crypto.subtle.digest("SHA-384",e))}return!0}async compareHashWithKey(e,t){if(!e||!t)return!1;let n=t.x,r=t.y;if(!n||!r)try{const e=Z(t,"L1787");e.x&&(n=e.x),e.y&&(r=e.y)}catch{return!1}const a=J(P(ie(n)),P(ie(r)));return N(await crypto.subtle.digest("SHA-256",a))===e||await this.#t(a,e)}async verifyChannelId(e,t){return await this.compareHashWithKey(t,e)}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new Error("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,a){try{let s;const o={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new Error("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),s=await crypto.subtle.importKey("jwk",e,o[n],r,a)}else s=await crypto.subtle.importKey(e,t,o[n],r,a);return s}catch(s){const o=`... importKey() error: ${s}:`;throw c&&(console.error(o),console.log(e),console.log(t),console.log(n),console.log(r),console.log(a)),new Error(o)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{c&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}deriveKey(e,t,n,r,a){return new Promise((async(s,o)=>{let i;switch(n){case"AES-GCM":i={name:"AES-GCM",length:256};break;case"HMAC":i={name:"HMAC",hash:"SHA-256",length:256};break;default:throw new Error(`deriveKey() - unknown type: ${n}`)}let c=t;if("private"===c.type){const e=await this.exportKey("jwk",c);p(e,"INTERNAL (L1878)"),delete e.d,delete e.alg,c=await this.importKey("jwk",e,"ECDH",!0,[]),p(c,"INTERNAL (L1882)")}p("public"===c.type,"INTERNAL (L1884)");try{s(await crypto.subtle.deriveKey({name:"ECDH",public:c},e,i,r,a))}catch(s){console.error(s,e,t,n,r,a),o(s)}}))}async encrypt(e,t,n){if(null===e)throw new Error("no contents");if(!n.iv)throw new Error("no nonce");return n.name?p("AES-GCM"===n.name,"Must be AES-GCM (L1951)"):n.name="AES-GCM",crypto.subtle.encrypt(n,t,e)}async wrap(e,t,n,r){const a=te(e);p(a,"wrapMessage(): failed to assemble payload"),p(a.byteLength<Ae,`wrapMessage(): body must be smaller than ${Ae/1024} KiB (we got ${a.byteLength/1024} KiB)})`);const s=crypto.getRandomValues(new Uint8Array(12)),o=25*Math.round(Date.now()/25),i=new DataView(new ArrayBuffer(8));return i.setFloat64(0,o),{contents:a,encryptedContents:await me.encrypt(a,n,{iv:s,additionalData:i}),iv:s,sender:t,sign:await me.sign(r,a),timestamp:o}}unwrap(e,t){return new Promise((async(n,r)=>{try{if(!t.timestamp)throw new Error("unwrap() - no timestamp in encrypted message");const{encryptedContents:r,iv:a}=t;p(r,"no contents in encrypted message");const s=new DataView(new ArrayBuffer(8));s.setFloat64(0,t.timestamp),n(await crypto.subtle.decrypt({name:"AES-GCM",iv:a,additionalData:s},e,r))}catch(e){c&&console.error(`unwrap(): cannot unwrap/decrypt - rejecting: ${e}`),r(e)}}))}sign(e,t){return crypto.subtle.sign("HMAC",e,t)}verify(e,t,n){return crypto.subtle.verify("HMAC",e,t,n)}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}compareKeys(e,t){return null!=e&&null!=t&&"object"==typeof e&&"object"==typeof t&&e.x===t.x&&e.y===t.y}}function he(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function ye(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name,a=e.constructor.ReadyFlag;p(a in this,"'readyFlagSymbol' missing yet getter accessed with @Ready pattern (fatal)"),p(this[a],`'${n}.${t}' getter accessed but object not 'ready' (fatal)`);const s=r.call(this);return p(null!=s,`'${n}.${t}' getter accessed but return value will be NULL (fatal)`),s}}}function ue(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;return"owner"in this&&p(!0===this.owner,`${t} getter or method accessed for object ${n} but callee is not channel owner`),r.call(this)}}}const de=["SBMessage","SBObjectHandle","SBChannelHandle","ChannelApiBody"],fe=Symbol("SB_CHANNEL_MESSAGE_SYMBOL"),pe=Symbol("SB_CHANNEL_API_BODY_SYMBOL"),ge=Symbol("SBChannelHandle"),we=Symbol.for("SBMessage"),be=Symbol.for("SBObjectHandle");function ve(e,t){switch(t){case"SBMessage":return we in e;case"SBObjectHandle":case"SBChannelHandle":return be in e;default:return!1}}const me=new le;class Se{sb384Ready;static ReadyFlag=Symbol("SB384ReadyFlag");#n;#r;#a;#s;#o;#i;#c;constructor(e,t){this[Se.ReadyFlag]=!1,this.sb384Ready=new Promise((async(n,r)=>{try{if(e)if(e instanceof CryptoKey){const n=await me.exportKey("jwk",e);p(n&&n.x&&n.y,"INTERNAL"),n.d?(this.#n=!0,this.#s=n.d):(this.#n=!1,p(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#r=n.x,this.#a=n.y}else if(e&&e instanceof Object&&"kty"in e){const n=e;p(n&&n.x&&n.y,"Cannot parse format of JWK key"),e.d?(this.#n=!0,this.#s=n.d):(this.#n=!1,p(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#r=n.x,this.#a=n.y}else{if("string"!=typeof e)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=function(e){try{if(e.length<=4)return;const t=e.slice(0,4),n=e.slice(4);switch(t){case ce.SBPublicKey:{const e=H(n);if(96!==e.byteLength)return;return{prefix:ce.SBPublicKey,x:x(e.slice(0,48)),y:x(e.slice(48,96))}}case ce.SBPrivateKey:{const e=H(n);if(144!==e.byteLength)return;return{prefix:ce.SBPrivateKey,x:x(e.slice(0,48)),y:x(e.slice(48,96)),d:x(e.slice(96,144))}}default:return}}catch(e){return void console.error("parseSB384string() - malformed input, exception: ",e)}}(e);if(!n)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey | SBUserPublicKey | SBUserPrivateKey, or omitted)");const{x:r,y:a,d:s}=n;s?(this.#n=!0,this.#s=s):(this.#n=!1,p(!t,"ERROR creating SB384 object: key provided is not the requested private")),p(r&&a,"INTERNAL"),this.#r=r,this.#a=a}}else{c&&console.log("SB384() - generating new key pair");const e=await me.generateKeys(),t=await me.exportKey("jwk",e.privateKey);p(t&&t.x&&t.y&&t.d,"INTERNAL"),this.#n=!0,this.#r=t.x,this.#a=t.y,this.#s=t.d}l&&console.log("SB384() constructor; x/y/d:\n",this.#r,"\n",this.#a,"\n",this.#s),this.#n&&(this.#o=await me.importKey("jwk",this.jwkPrivate,"ECDH",!0,["deriveKey"])),this.#i=await me.importKey("jwk",this.jwkPublic,"ECDH",!0,[]);const r=J(P(this.#r),P(this.#a));this.#c=N(await crypto.subtle.digest("SHA-256",r)),l&&console.log("SB384() constructor; hash:\n",this.#c),this[Se.ReadyFlag]=!0,n(this)}catch(e){r("ERROR creating SB384 object failed: "+f(e))}}))}get SB384ReadyFlag(){return this[Se.ReadyFlag]}get ready(){return this.sb384Ready}get private(){return this.#n}get hash(){return this.#c}get userId(){return this.hash}get ownerChannelId(){return this.hash}get privateKey(){if(!this.private)throw new Error("this is a public key, there is no 'privateKey' value");return this.#o}get publicKey(){return this.#i}get jwkPrivate(){return p(this.#n,"jwkPrivate() - not a private key"),p(this.#r&&this.#a&&this.#s,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:["deriveKey"],kty:"EC",x:this.#r,y:this.#a,d:this.#s}}get jwkPublic(){return p(this.#r&&this.#a,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:this.#r,y:this.#a}}get userPublicKey(){p(this.#r&&this.#a,"userPublicKey() - sufficient key info is not available (fatal)");const e=new Uint8Array(96);return e.set(P(this.#r),0),e.set(P(this.#a),48),ce.SBPublicKey+N(e)}get userPrivateKey(){p(this.#n,"userPrivateKey() - not a private key, there is no userPrivateKey"),p(this.#r&&this.#a&&this.#s,"userPrivateKey() - sufficient key info is not available (fatal)");const e=new Uint8Array(144);return e.set(P(this.#r),0),e.set(P(this.#a),48),e.set(P(this.#s),96),ce.SBPrivateKey+N(e)}}r([he,ye],Se.prototype,"private",null),r([he,ye],Se.prototype,"hash",null),r([he,ye],Se.prototype,"userId",null),r([he,ye],Se.prototype,"ownerChannelId",null),r([he,ye],Se.prototype,"privateKey",null),r([he,ye],Se.prototype,"publicKey",null),r([he],Se.prototype,"jwkPrivate",null),r([he],Se.prototype,"jwkPublic",null),r([he],Se.prototype,"userPublicKey",null),r([he],Se.prototype,"userPrivateKey",null);class ke extends Se{#l;sbChannelKeysReady;static ReadyFlag=Symbol("SBChannelKeysReadyFlag");#h;#y;#u;channelServer;#d;#f;#p;constructor(e){e?(super(e.userPrivateKey,!0),e.channelServer&&(this.channelServer=e.channelServer,"/"===this.channelServer[this.channelServer.length-1]&&(this.channelServer=this.channelServer.slice(0,-1))),this.#l=e.channelId):super(),this[ke.ReadyFlag]=!1,this.sbChannelKeysReady=new Promise((async(t,n)=>{c&&console.log("SBChannelKeys() constructor."),await this.sb384Ready;try{if(e)if(e.channelData)this.#h=e.channelData;else{p(this.channelServer,"SBChannelKeys() constructor: need either channelKeys or channelServer"),c&&console.log("++++ SBChannelKeys initialized from channel server");const e=await d(this.channelServer+"/api/v2/channel/"+this.#l+"/getChannelKeys");p(e&&!e.ok,"SBChannelKeys(): failed to get channel keys (network response not 'ok')");const t=se(await e.arrayBuffer());p(t&&!t.error,"SBChannelKeys(): failed to get channel keys (error in response)");const n=t;p(n.channelId===this.#l&&n.ownerPublicKey,"SBChannelKeys(): failed to get channel keys (invalid or incomplete response)"),this.#h=n}else{this.#l=this.ownerChannelId;const e=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]);this.#f=e.privateKey,this.#d=e.publicKey;const t=await new Se(this.#f,!0).ready;this.#p=t.userPrivateKey,this.#h={channelId:this.#l,ownerPublicKey:this.userPublicKey}}p(this.SB384ReadyFlag,"SBChannelKeys(): parent SB384 object is not ready (?)"),this.#y=await me.deriveKey(this.privateKey,this.#d,"AES-GCM",!0,["encrypt","decrypt"]),this.#u=await me.deriveKey(this.privateKey,this.#d,"HMAC",!0,["sign","verify"]),this[ke.ReadyFlag]=!0,t(this)}catch(e){n("ERROR creating SBChannelKeys object failed: "+f(e))}}))}get ready(){return this.sbChannelKeysReady}get SBChannelKeysReadyFlag(){return this[ke.ReadyFlag]}get channelData(){return this.#h}get owner(){return this.private&&this.ownerChannelId===this.channelId}get channelId(){return this.#l}get encryptionKey(){return this.#y}get signKey(){return this.#u}get channelPrivateKey(){return this.#f}get channelPublicKey(){return this.#d}get channelUserPrivateKey(){return this.#p}}r([he,ye],ke.prototype,"channelData",null),r([he,ye],ke.prototype,"owner",null),r([he,ye],ke.prototype,"channelId",null),r([he,ye],ke.prototype,"encryptionKey",null),r([he,ye],ke.prototype,"signKey",null),r([he,ye],ke.prototype,"channelPrivateKey",null),r([he,ye],ke.prototype,"channelPublicKey",null),r([he,ye],ke.prototype,"channelUserPrivateKey",null);const Ae=98304;class Ke{channel;[we]=!0;ready;message;#y;constructor(e,t,n){this.channel=e,this.ready=new Promise((async r=>{await e.channelReady,this.#y=this.channel.encryptionKey,this.message=await me.wrap(t,this.channel.userId,this.#y,this.channel.privateKey),this.message.ttl=n||15,r(this)}))}get encryptionKey(){return this.#y}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}r([ye],Ke.prototype,"encryptionKey",null);class Be extends ke{channelReady;static ReadyFlag=Symbol("ChannelReadyFlag");motd="";locked=!1;adminData;verifiedGuest=!1;#g="";constructor(e){if(!e.channelServer)throw new Error("Channel(): no channel server provided");super(e),this.channelReady=this.sbChannelKeysReady.then((()=>(this[Be.ReadyFlag]=!0,this))).catch((e=>{throw e}))}get ready(){return this.channelReady}get ChannelReadyFlag(){return this[Be.ReadyFlag]}get api(){return this}get handle(){return{[ge]:!0,channelId:this.channelId,userPrivateKey:this.userPrivateKey,channelPrivateKey:this.channelUserPrivateKey,channelServer:this.channelServer,channelData:this.channelData}}#w(e,t){return c&&console.log("ChannelApi.#callApi: calling fetch with path:",e,"body:",t),p(this.channelId&&e,"Internal Error (L2864)"),new Promise((async(n,r)=>{await this.channelReady;const a=25*Math.round(Date.now()/25),s=new ArrayBuffer(8);new DataView(s).setFloat64(0,a);const i=J(s,(new TextEncoder).encode(e).buffer),l=t?te(t):void 0,h=await me.sign(this.privateKey,l?J(i,l):i),y={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:te(o({channelId:this.channelId,path:e,userId:this.userId,userPublicKey:this.userPublicKey,apiPayload:l,timestamp:a,sign:h}))};c&&console.log("==== ChannelApi.#callApi: calling fetch with init:\n",y),d(this.channelServer+"/api/v2/channel/"+this.channelId+e,y).then((async e=>{var t;if("application/json; charset=utf-8"===e.headers.get("content-type"))t=Z(await e.json(),"L2928");else{if("application/octet-stream"!==e.headers.get("content-type"))throw new Error("ChannelApi.#callApi: invalid content-type in response");t=se(await e.arrayBuffer())}if(!e.ok||t.error){let n="Network or Server error on Channel API call";e.status&&(n+=" ["+e.status+"]"),t.error&&(n+=": "+t.error),c&&console.error("ChannelApi.#callApi error:\n",n),r(new Error(n))}else c&&console.log("ChannelApi.#callApi: success\n",t),n(t)})).catch((e=>{r("ChannelApi (SBFetch) Error [2]: "+f(e))}))}))}async deCryptChannelMessage(e,t){c&&console.log("Asked to decrypt:",e,t)}getLastMessageTimes(){throw new Error("Channel.getLastMessageTimes(): not supported in 2.0 yet")}getOldMessages(e=100,t=!1){return new Promise((async(n,r)=>{p(this.channelId,"Channel.getOldMessages: no channel ID (?)");let a=t?"&cursor="+this.#g:"";const s=await this.#w("/oldMessages?currentMessagesLength="+e+a);p(s,"Channel.getOldMessages: no messages (empty/null response)"),c&&console.log("getOldMessages\n",s),Promise.all(Object.keys(s).filter((e=>s[e].hasOwnProperty("encrypted_contents"))).map((e=>this.deCryptChannelMessage(e,s[e].encrypted_contents)))).then((e=>e.filter((e=>Boolean(e))))).then((e=>{let t=e[e.length-1];t&&(this.#g=t._id||""),l&&console.log(e),n(e)})).catch((e=>{const t=`Channel.getOldMessages(): failed to decrypt messages: ${e}`;console.error(t),r(t)}))}))}send(e){return Promise.reject("Channel.send(): abstract method, must be implemented in subclass")}updateCapacity(e){return this.#w("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.#w("/getRoomCapacity")}getStorageLimit(){return this.#w("/getStorageLimit")}getMother(){return this.#w("/getMother")}getJoinRequests(){return this.#w("/getJoinRequests")}isLocked(){return new Promise((e=>this.#w("/roomLocked").then((t=>{this.locked=!0===t.locked,e(this.locked)}))))}storageRequest(e){return this.#w("/storageRequest?size="+e)}acceptVisitor(e){return this.#w("/acceptVisitor",{userId:e})}async getStorageToken(e){const t=await this.#w(`/storageRequest?size=${e}`);return p(!t.hasOwnProperty("error"),`storage token request error (${t.error})`),c&&console.log("getStorageToken():",t),t}budd(e){let{keys:t,storage:n,targetChannel:r}=e??{};return new Promise((async(a,s)=>{e&&e.hasOwnProperty("storage")&&void 0===e.storage&&s("If you omit 'storage' it defaults to Infinity, but you cannot set 'storage' to undefined");try{if(n||(n=1/0),r){if(this.channelId==r)throw new Error("[budd()]: You can't specify the same channel as targetChannel");if(t)throw new Error("[budd()]: You can't specify both a target channel and keys");a(this.#w(`/budd?targetChannel=${r}&transferBudget=${n}`))}else{const e=new Se(t);await e.ready;const r={[ge]:!0,userPrivateKey:e.userPrivateKey,channelServer:this.channelServer,channelId:e.hash};let o=await this.#w(`/budd?targetChannel=${r.channelId}&transferBudget=${n}`,r);o.success?a(r):s(JSON.stringify(o))}}catch(e){s(e)}}))}}r([he,ye],Be.prototype,"api",null),r([he,ye],Be.prototype,"handle",null),r([ye,ue],Be.prototype,"updateCapacity",null),r([ye,ue],Be.prototype,"getCapacity",null),r([ye],Be.prototype,"getStorageLimit",null),r([ye,ue],Be.prototype,"getMother",null),r([ye,ue],Be.prototype,"getJoinRequests",null),r([function(e,t,n){if(n&&n.value){const r=n.value;n.value=function(...a){try{return r.call(this,...a)}catch(r){return console.log(`ExceptionReject: ${f(r)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${f(r)}`)))}}}}],Be.prototype,"isLocked",null),r([ye],Be.prototype,"storageRequest",null),r([ye,ue],Be.prototype,"acceptVisitor",null),r([ye],Be.prototype,"getStorageToken",null),r([ye,ue],Be.prototype,"budd",null);class Ce extends Be{channelSocketReady;static ReadyFlag=Symbol("ChannelSocketReadyFlag");#b;#v;#m=this.#S;#k=new Map;#A=!1;constructor(e,t){if(p(t,"ChannelSocket(): no onMessage handler provided"),!e.hasOwnProperty("channelId")||!e.hasOwnProperty("userPrivateKey"))throw new Error("ChannelSocket(): first argument must be valid SBChannelHandle");if(!e.channelServer)throw new Error("ChannelSocket(): no channel server provided (required)");super(e),this[n.ReadyFlag]=!1,this.#v=e.channelServer.replace(/^http/,"ws"),this.#m=t;const r=this.#v+"/api/v2/channel/"+e.channelId+"/websocket";this.#b={url:r,ready:!1,closed:!1,timeout:2e3},this.channelSocketReady=this.#K()}#S(e){p(!1,"NO MESSAGE HANDLER")}async#B(e){c&&console.log("Received socket message:",e)}#K(){return new Promise((async(e,t)=>{c&&console.log("++++ STARTED ChannelSocket.readyPromise()");const r=this.#b.url;this.#b.websocket&&3!==this.#b.websocket.readyState&&2!==this.#b.websocket.readyState||(this.#b.websocket=new WebSocket(r)),this.#b.websocket.addEventListener("message",this.#B),this.#b.websocket.addEventListener("open",(async()=>{this.#b.closed=!1,await this.ready,c&&console.log("++++++++ readyPromise() sending init"),this.#b.websocket.send(JSON.stringify({ready:!0}))})),this.#b.websocket.addEventListener("close",(e=>{this.#b.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.channelServer})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.channelServer}`),t("wbSocket() closed before it was opened (?)")})),this.#b.websocket.addEventListener("error",(e=>{this.#b.closed=!0,console.log("ChannelSocket() error: ",e),t("ChannelSocket creation error (see log)")})),setTimeout((()=>{if(this[n.ReadyFlag])c&&console.log("ChannelSocket() - this socket resolved",this);else{const e="ChannelSocket() - this socket is not resolving (waited 10s) ...";console.warn(e),t(e)}}),1e4),this[n.ReadyFlag]=!0,e(this)}))}get ready(){return this.channelSocketReady}get ChannelSocketReadyFlag(){return this[n.ReadyFlag]}get status(){if(!this.#b.websocket)return"CLOSED";switch(this.#b.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#m=e}get onMessage(){return this.#m}set enableTrace(e){this.#A=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}send(e){const t=e instanceof Ke?e:new Ke(this,e);return p(this.#b.websocket,"ChannelSocket.send() called before ready"),this.#b.closed&&(this.#A&&console.info("send() triggered reset of #readyPromise() (normal)"),this.channelSocketReady=this.#K(),this[n.ReadyFlag]=!1),new Promise((async(e,n)=>{switch(await t.ready,await this.ready,this.ChannelSocketReadyFlag||n("ChannelSocket.send() is confused - ready or not?"),this.#b.websocket.readyState){case 1:this.#A&&console.log("++++++++ ChannelSocket.send() will send message:",Object.assign({},t));const r=te(t);p(r,"ChannelSocket.send(): failed to assemble message");const a=x(await crypto.subtle.digest("SHA-256",r));this.#A&&(console.log("++++++++ ChannelSocket.send():Which has hash:"),console.log(a)),this.#k.set(a,e),this.#b.websocket.send(r),setTimeout((()=>{if(this.#k.has(a)){this.#k.delete(a);const e=`Websocket request timed out (no ack) after ${this.#b.timeout}ms (${a})`;console.error(e),n(e)}else this.#A&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#b.timeout);break;case 3:case 0:case 2:n("socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING")}}))}}n=Ce,r([ye],Ce.prototype,"onMessage",null),r([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&de.includes(n)&&p(ve(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],Ce.prototype,"send",null);class Ee{version="2";#C="b";#E;#P;#R;shardServer;iv;salt;fileName;dateAndTime;fileType;lastModified;actualSize;savedSize;constructor(e){const{version:t,type:n,id:r,key:a,verification:s,iv:o,salt:i,fileName:c,dateAndTime:l,fileType:h,lastModified:y,actualSize:u,savedSize:d}=e;if(n&&(this.#C=n),t)this.version=t;else if(a&&r)if(W(a)&&W(r))this.version="2";else{if(!v(a)||!v(r))throw new Error("Unable to determine version from key and id");this.version="1"}else this.version="2";r&&(this.id=r),a&&(this.key=a),s&&(this.verification=s),this.iv=o,this.salt=i,this.fileName=c,this.dateAndTime=l,this.fileType=h,this.lastModified=y,this.actualSize=u,this.savedSize=d}set id_binary(e){if(!e)throw new Error("Invalid id_binary");if(32!==e.byteLength)throw new Error("Invalid id_binary length");this.#E=e,Object.defineProperty(this,"id64",{get:()=>x(this.#E),enumerable:!1,configurable:!1}),Object.defineProperty(this,"id32",{get:()=>N(this.#E),enumerable:!1,configurable:!1})}set key_binary(e){if(!e)throw new Error("Invalid key_binary");if(32!==e.byteLength)throw new Error("Invalid key_binary length");this.#P=e,Object.defineProperty(this,"key64",{get:()=>x(this.#P),enumerable:!1,configurable:!1}),Object.defineProperty(this,"key32",{get:()=>N(this.#P),enumerable:!1,configurable:!1})}set id(e){if("string"==typeof e){if("1"===this.version){if(!v(e))throw new Error("Requested version 1, but id is not b64");this.id_binary=P(e)}else if("2"===this.version){if(!W(e))throw new Error("Requested version 2, but id is not b62");this.id_binary=V(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid ID type");if(32!==e.byteLength)throw new Error("Invalid ID length");this.id_binary=e}}set key(e){if("string"==typeof e){if("1"===this.version){if(!v(e))throw new Error("Requested version 1, but key is not b64");this.#P=P(e)}else if("2"===this.version){if(!W(e))throw new Error("Requested version 2, but key is not b62");this.#P=V(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid key type");if(32!==e.byteLength)throw new Error("Invalid key length");this.#P=e}}get id(){if(p(this.#E,"object handle id is undefined"),"1"===this.version)return x(this.#E);if("2"===this.version)return N(this.#E);throw new Error("Invalid or missing version (internal error, should not happen)")}get key(){if(p(this.#P,"object handle key is undefined"),"1"===this.version)return x(this.#P);if("2"===this.version)return N(this.#P);throw new Error("Invalid or missing version (internal error, should not happen)")}get id64(){throw new Error("Invalid id_binary")}get id32(){throw new Error("Invalid id_binary")}get key64(){throw new Error("Invalid key_binary")}get key32(){throw new Error("Invalid key_binary")}set verification(e){this.#R=e}get verification(){return p(this.#R,"object handle verification is undefined"),this.#R}get type(){return this.#C}}class Pe{storageServer;constructor(e){p("string"==typeof e,"StorageApi() constructor requires a string (for storageServer)"),this.storageServer=e}#I(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=J(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),l&&console.log("#padBuf bytes:",r.slice(-4)),r}#O(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(l&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=r),l&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}#j(e,t){return new Promise(((n,r)=>{try{me.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}#x(e,t){return new Promise(((n,r)=>{d(this.storageServer+"/api/v1/storeRequest?name="+N(e)+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=se(e);n({salt:t.salt,iv:t.iv})})).catch((e=>{console.warn(`**** ERROR: ${e}`),r(e)}))}))}async#D(e,t,n,r,a,s,o){return new Promise((async(i,c)=>{try{const l=await this.#j(n,o),h=await me.encrypt(e,l,{iv:s}),y=await a.getStorageToken(h.byteLength),u=await this.storeObject(r,t,s,o,y,h);u.error&&c(`storeObject() failed: ${u.error}`),u.image_id!=t&&c(`received imageId ${u.image_id} but expected ${t}`),i(u.verification_token)}catch(e){const t=`storeObject() failed: ${e}`;console.error(t),c(t)}}))}storeObject(e,t,n,r,a,s){return new Promise(((o,i)=>{if("string"!=typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeData()";console.error(e),i("errMsg")}d(this.storageServer+"/storeData?type="+e+"&key="+t,{method:"POST",body:te({iv:n,salt:r,image:s,storageToken:(new TextEncoder).encode(a),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||i("response from storage server was not OK"),e.json()))).then((e=>{o(e)})).catch((e=>{i(e)}))}))}storeData(e,t,n){return new Promise(((r,a)=>{if("string"==typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeObject()";console.error(e),a("errMsg")}e instanceof Uint8Array&&(l&&console.log("converting Uint8Array to ArrayBuffer"),e=new Uint8Array(e).buffer),e instanceof ArrayBuffer||"ArrayBuffer"==e.constructor.name||(l&&console.log("buf must be an ArrayBuffer:"),console.log(e),a("buf must be an ArrayBuffer"));const s=e.byteLength,o=n instanceof Be?n:new Be(n),i=this.#I(e);me.generateIdKey(i).then((e=>{this.#x(e.id_binary,t).then((n=>{const a=N(e.id_binary),c=N(e.key_material),l={[be]:!0,version:"2",type:t,id:a,key:c,iv:n.iv,salt:n.salt,actualSize:s,verification:this.#D(i,a,e.key_material,t,o,n.iv,n.salt)};r(l)})).catch((e=>a(e)))}))}))}#_(e,t){return new Promise(((n,r)=>{try{let t=Z(me.ab2str(new Uint8Array(e)),"L3062");t.error&&r(`#processData() error: ${t.error}`)}catch(e){}finally{const r=se(e);c&&(console.log("Payload (#processData) is:"),console.log(r));const s=new ArrayBuffer(r.iv),o=new ArrayBuffer(r.salt),i=t.iv?"string"==typeof t.iv?P(t.iv):t.iv:void 0,h=t.salt?"string"==typeof t.salt?P(t.salt):t.salt:void 0;var a;if(i&&!j(s,i)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${x(i)}`),console.log(`server iv: ${x(r.iv)}`)),h&&!j(o,h)&&(console.error("WARNING: salt from server differs from local copy (will use server)"),t.salt?"string"==typeof t.salt?(console.log("h.salt is in string form (unprocessed):"),console.log(t.salt)):(console.log("h.salt is in arrayBuffer or Uint8Array"),console.log("h.salt as b64:"),console.log(x(t.salt)),console.log("h.salt unprocessed:"),console.log(t.salt)):console.log("h.salt is undefined"),console.log("handleSalt as b64:"),console.log(x(h)),console.log("handleSalt unprocessed:"),console.log(h)),l&&(console.log("will use nonce and salt of:"),console.log(`iv: ${x(s)}`),console.log(`salt : ${x(o)}`)),"1"===t.version)a=P(t.key);else{if("2"!==t.version)throw new Error("Invalid or missing version (internal error, should not happen)");a=V(t.key)}this.#j(a,o).then((e=>{const t=r.image;l&&(console.log("data.image:      "),console.log(r.image),console.log("encrypted_image: "),console.log(t)),me.unwrap(e,{contents:t,iv:s}).then((e=>{const t=this.#O(e);c&&(console.log("#processData(), unwrapped img: "),console.log(t)),n(t)}))}))}}))}async#T(e,t,n,r){const a={method:"GET"};return new Promise((async(s,o)=>{d(e+t,a).then((e=>e.ok?e.arrayBuffer():null)).then((e=>null===e?null:this.#_(e,n))).then((e=>{null===e&&s(null),s("string"===r?me.ab2str(new Uint8Array(e)):e)})).catch((e=>null))}))}fetchData(e,t="arrayBuffer"){return new Promise((async(n,r)=>{const a=new Ee(e);a||r("SBObjectHandle is null or undefined");const s=await a.verification,o=this.storageServer+"/api/v1";c&&console.log("fetchData(), fetching from server: "+o);const i="/fetchData?id="+a.id+"&type="+a.type+"&verification_token="+s,l=await this.#T(o,i,a,t);null!==l?(c&&console.log(`[fetchData] success: fetched from '${o}'`,l),n(l)):r("fetchData() failed")}))}}class Re{channelServer;storageServer;#M;#U=a;sbFetch=d;constructor(e,t,n){console.warn(`==== CREATING Snackabra object generation: ${this.#U} ====`),p("string"==typeof e,"[Snackabra] Invalid parameter type for constructor"),t&&!0===t&&(c=!0),c&&n&&!0===n&&(l=!0),c&&console.warn("++++ Snackabra constructor: setting DBG to TRUE ++++"),l&&console.warn("++++ Snackabra constructor: ALSO setting DBG2 to TRUE (verbose) ++++"),this.channelServer=e,this.storageServer="TODO",this.#M=new Pe(this.storageServer)}attach(e){return new Promise(((t,n)=>{e.channelId?(e.channelServer?e.channelServer!==this.channelServer&&n("SBChannelHandle channelId does not match channelServer"):e.channelServer=this.channelServer,t(new Be(e))):n("SBChannelHandle missing channelId")}))}create(e){return p(null!==e,"[create channel] Invalid parameter (null)"),new Promise((async(t,n)=>{try{let r;if("string"==typeof e)r=e;else if(e instanceof Be){const t=e;await t.ready,r=await t.getStorageToken(s),p(r,"[create channel] Failed to get storage token for the provided channel")}else n("Invalid parameter to create() - need a token or a budget channel");const a=await(new ke).ready,o=a.channelData;o.storageToken=r,c&&console.log("Will try to create channel with channelData:",o);const i=te(o),l=await d(this.channelServer+"/api/v2/channel/"+o.channelId+"/create",{method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:i}),h=se(await l.arrayBuffer());if(!h||!h.success){const e=`Creating channel did not succeed (${JSON.stringify(h)})`;return console.error(e),void n(e)}t({[ge]:!0,channelId:o.channelId,userPrivateKey:a.userPrivateKey,channelPrivateKey:(await new Se(a.channelPrivateKey).ready).userPrivateKey,channelServer:this.channelServer,channelData:o})}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),n(t)}}))}connect(e,t){if(p(e&&e.channelId&&e.userPrivateKey,"[connect] Invalid parameter (missing info)"),e.channelServer&&e.channelServer!==this.channelServer)throw new Error("SBChannelHandle channelId does not match channelServer (use a different Snackabra object)");const n={...e,[ge]:!0,channelServer:this.channelServer};return c&&console.log("++++ Snackabra.connect() ++++",n),t?new Ce(n,(e=>{console.log("MESSAGE (not caught):",e)})):new Be(n)}get storage(){if("string"==typeof this.#M)throw new Error("StorageApi not initialized");return this.#M}get crypto(){return me}get version(){return this.#U}}var Ie={Snackabra:Re,SBMessage:Ke,Channel:Be,SBCrypto:le,SB384:Se,arrayBufferToBase64:x,sbCrypto:me,version:a};return globalThis.SB||(globalThis.SB=Ie),console.warn(`==== SNACKABRA jslib loaded ${globalThis.SB.version} ====`),t})()));