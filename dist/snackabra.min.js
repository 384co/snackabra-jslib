!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>ze,ChannelSocket:()=>He,ClientDeepHistory:()=>M,DeepHistory:()=>P,HistoryTree:()=>I,HistoryTreeNode:()=>E,KeyPrefix:()=>ke,Memoize:()=>Me,MessageBus:()=>K,MessageQueue:()=>R,NEW_CHANNEL_MINIMUM_BUDGET:()=>s,Protocol_AES_GCM_256:()=>$e,Protocol_ECDH:()=>Ue,Ready:()=>Ke,SB384:()=>je,SBApiFetch:()=>U,SBChannelKeys:()=>Ve,SBCrypto:()=>Be,SBError:()=>x,SBEventTarget:()=>qe,SBStorageTokenPrefix:()=>i,ServerDeepHistory:()=>B,Snackabra:()=>We,StorageApi:()=>Ge,_check_SBChannelData:()=>d,_check_SBChannelHandle:()=>l,_check_SBObjectHandle:()=>b,_check_SBStorageToken:()=>o,arrayBufferToBase62:()=>oe,arrayBufferToBase64url:()=>Z,assemblePayload:()=>ve,b32decode:()=>ge,b32encode:()=>fe,b32process:()=>ye,b62regex:()=>Y,base62:()=>Q,base62ToArrayBuffer:()=>ce,base62ToBase64:()=>le,base62regex:()=>ee,base64ToArrayBuffer:()=>J,base64ToBase62:()=>he,base64url:()=>q,compareBuffers:()=>F,extractPayload:()=>be,fooBar:()=>ie,generateRandomString:()=>O,getRandomValues:()=>L,hydrateKey:()=>Pe,isBase62Encoded:()=>te,jsonOrString:()=>_,jsonParseWrapper:()=>T,msgTtlToSeconds:()=>v,msgTtlToString:()=>m,sbCrypto:()=>Fe,setDebugLevel:()=>w,stringify_SBObjectHandle:()=>C,stripChannelMessage:()=>p,validate_ChannelApiBody:()=>y,validate_ChannelMessage:()=>g,validate_Message:()=>f,validate_SBChannelData:()=>u,validate_SBChannelHandle:()=>h,validate_SBObjectHandle:()=>k,validate_SBStorageToken:()=>c});var n,r,a=function(e,t,n,r){var a,s=arguments.length,i=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,t,n,r);else for(var o=e.length-1;o>=0;o--)(a=e[o])&&(i=(s<3?a(i):s>3?a(t,n,i):a(t,n))||i);return s>3&&i&&Object.defineProperty(t,n,i),i};const s=8388608,i="LM2r";function o(e){return Object.getPrototypeOf(e)===Object.prototype&&e.hash&&"string"==typeof e.hash&&e.hash.length>0&&(!e.size||Number.isInteger(e.size)&&e.size>0)&&(!e.motherChannel||"string"==typeof e.motherChannel)&&(!e.created||Number.isInteger(e.created))&&(!e.used||"boolean"==typeof e.used)}function c(e){if(e){if(e[Ne])return e;if("string"==typeof e&&e.slice(0,4)===i)return{[Ne]:!0,hash:e};if(o(e))return{...e,[Ne]:!0};throw new x("invalid SBStorageToken")}throw new x("invalid SBStorageToken (null or undefined)")}function l(e){return!!e&&Object.getPrototypeOf(e)===Object.prototype&&e.userPrivateKey&&"string"==typeof e.userPrivateKey&&e.userPrivateKey.length>0&&(!e.channelId||"string"==typeof e.channelId&&43===e.channelId.length)&&(!e.channelServer||"string"==typeof e.channelServer)&&(!e.channelData||d(e.channelData))}function h(e){if(e){if(e[De])return e;if(l(e))return{...e,[De]:!0};throw new x("invalid SBChannelHandle")}throw new x("invalid SBChannelHandle (null or undefined)")}function d(e){return Object.getPrototypeOf(e)===Object.prototype&&e.channelId&&43===e.channelId.length&&e.ownerPublicKey&&"string"==typeof e.ownerPublicKey&&e.ownerPublicKey.length>0&&(!e.storageToken||c(e.storageToken))}function u(e){if(e){if(d(e))return e;throw new x("invalid SBChannelData")}throw new x("invalid SBChannelData (null or undefined)")}function f(e){if(e){if(void 0!==e.body&&null!==e.body&&e.channelId&&"string"==typeof e.channelId&&43===e.channelId.length&&e.sender&&"string"==typeof e.sender&&43===e.sender.length&&e.senderPublicKey&&"string"==typeof e.senderPublicKey&&e.senderPublicKey.length>0&&e.senderTimestamp&&Number.isInteger(e.senderTimestamp)&&e.serverTimestamp&&Number.isInteger(e.serverTimestamp)&&e._id&&"string"==typeof e._id&&75===e._id.length)return e;throw new x("invalid Message")}throw new x("invalid Message (null or undefined)")}function y(e){if(e){if(e[Te])return e;if(e.channelId&&43===e.channelId.length&&e.path&&"string"==typeof e.path&&e.path.length>0&&e.userId&&"string"==typeof e.userId&&43===e.userId.length&&e.userPublicKey&&e.userPublicKey.length>0&&(!e.isOwner||"boolean"==typeof e.isOwner)&&(!e.apiPayloadBuf||e.apiPayloadBuf instanceof ArrayBuffer)&&e.timestamp&&Number.isInteger(e.timestamp)&&e.sign&&e.sign instanceof ArrayBuffer)return{...e,[Te]:!0};throw new x("invalid ChannelApiBody")}throw new x("invalid ChannelApiBody (null or undefined)")}function g(e){if(e){if(e[xe])return e;if(!(e.f&&"string"==typeof e.f&&43===e.f.length&&e.c&&e.c instanceof ArrayBuffer&&e.ts&&Number.isInteger(e.ts)&&e.iv&&e.iv instanceof Uint8Array&&12===e.iv.length&&e.s&&e.s instanceof ArrayBuffer)||void 0!==e.cs&&"string"!=typeof e.cs||e.sts&&!Number.isInteger(e.sts)||e.salt&&!(e.salt instanceof ArrayBuffer&&16===e.salt.byteLength)||e._id&&("string"!=typeof e._id||86!==e._id.length)||e.ready&&"boolean"!=typeof e.ready||e.timestampPrefix&&("string"!=typeof e.timestampPrefix||26!==e.timestampPrefix.length)||e.channelId&&("string"!=typeof e.channelId||43!==e.channelId.length)||e.i2&&("string"!=typeof e.i2||!/^[a-zA-Z0-9_]{4}$/.test(e.i2))||!(void 0===e.ttl||Number.isInteger(e.ttl)&&e.ttl>=0&&e.ttl<=15))throw new x("invalid ChannelMessage");return{...e,[xe]:!0}}throw new x("invalid ChannelMessage (null or undefined)")}function p(e,t=!1){const n={};if(void 0===e.f)throw new x("ERROR: missing 'f' ('from') in message");if(n.f=e.f,void 0===e.c)throw new x("ERROR: missing 'ec' ('encrypted contents') in message");if(n.c=e.c,void 0!==e.iv)n.iv=e.iv;else if(1==!e.stringMessage)throw new x("ERROR: missing 'iv' ('nonce') in message");if(void 0===e.salt)throw new x("ERROR: missing 'salt' in message");if(n.salt=e.salt,void 0!==e.s)n.s=e.s;else if(1==!e.stringMessage)throw new x("ERROR: missing 's' ('signature') in message");if(void 0===e.ts)throw new x("ERROR: missing 'ts' ('timestamp') in message");if(n.ts=e.ts,void 0!==e.sts)n.sts=e.sts;else if(t)throw new x("ERROR: missing 'sts' ('servertimestamp') in message");return void 0!==e.ttl&&15!==e.ttl&&(n.ttl=e.ttl),void 0!==e.t&&(n.t=e.t),void 0!==e.i2&&"____"!==e.i2&&(n.i2=e.i2),void 0!==e.cs&&(n.cs=e.cs),n}function w(e,t){}const v=[0,-1,-1,60,300,1800,14400,129600,864e3,-1,-1,-1,-1,-1,1/0],m=["Ephemeral","<reserved>","<reserved>","One minute","Five minutes","Thirty minutes","Four hours","36 hours","10 days","<reserved>","<reserved>","<reserved>","<reserved>","<reserved>","Permastore (no TTL)"],S="3";if("undefined"==typeof WeakRef){class e{_target;constructor(e){this._target=e}deref(){return this._target}}Object.defineProperty(e.prototype,Symbol.toStringTag,{value:"WeakRef",configurable:!0}),globalThis.WeakRef=e}function b(e){return Object.getPrototypeOf(e)===Object.prototype&&(!e.version||e.version===S)&&e.id&&"string"==typeof e.id&&43===e.id.length&&(!e.key||"string"==typeof e.key&&43===e.key.length)&&(!e.verification||"string"==typeof e.verification||"object"==typeof e.verification)&&(!e.iv||"string"==typeof e.iv||e.iv instanceof Uint8Array)&&(!e.salt||"string"==typeof e.salt||e.salt instanceof ArrayBuffer)}function k(e){if(e){if(e[_e])return e;if(b(e))return{...e,[_e]:!0};throw new x("invalid SBObjectHandle")}throw new x("invalid SBObjectHandle (null or undefined)")}async function C(e){return e.iv&&(e.iv="string"==typeof e.iv?e.iv:oe(e.iv)),e.salt&&(e.salt="string"==typeof e.salt?e.salt:oe(e.salt)),e.verification=await e.verification,k(e)}"=".repeat(76);class E{isLeaf;childrenNodes=[];childrenValues=[];from=void 0;to=void 0;count=0;isFull=!1;height=1;frozenChunkId=void 0;constructor(e=!1){this.isLeaf=e}async insertTreeNodeValue(e,t){if(this.isFull)throw new Error("Should not be inserting here");const{count:n,from:r,to:a}=t;if(this.count+=n,A(this.from)!==A(this.to))throw new Error("Internal Error (L70)");if(A(this.from)||A(this.to))this.from=r,this.to=a;else{if(!(a>this.to))throw new Error("Internal Error (L76)");this.to=a}if(this.isLeaf){if(this.childrenValues.push(t),this.childrenValues.length===e.branchFactor){this.isFull=!0;const t=this.export();this.frozenChunkId=await e.freeze(t),this.childrenValues.length=0}}else if(0===this.childrenNodes.length||this.childrenNodes[this.childrenNodes.length-1].isFull){if(this.childrenNodes.length===e.branchFactor)throw new Error("Internal Error (L100)");const n=new E(!0);await n.insertTreeNodeValue(e,t),this.childrenNodes.push(n)}else if(await this.childrenNodes[this.childrenNodes.length-1].insertTreeNodeValue(e,t),this.childrenNodes[this.childrenNodes.length-1].isFull&&this.childrenNodes.length===e.branchFactor){let t=!0,n=0;for(n=0;n<this.childrenNodes.length-1;n++)if(this.childrenNodes[n].height!==this.childrenNodes[n+1].height){t=!1;break}if(t)this.isFull=!0,this.frozenChunkId=await e.freeze(this.export()),this.childrenNodes.length=0;else{const e=new E;e.childrenNodes=this.childrenNodes.splice(n+1),e.count=e.childrenNodes.map((e=>e.count)).reduce(((e,t)=>e+t),0);const t=e.childrenNodes.map((e=>e.height)).reduce(((e,t)=>Math.max(e,t)),0)+1;e.height=t,e.from=e.childrenNodes[0].from,e.to=e.childrenNodes[e.childrenNodes.length-1].to,this.childrenNodes.push(e)}}}async traverse(e,t,n=!1){if(n||await t(this),A(this.frozenChunkId))if(n)for(let r=this.childrenNodes.length-1;r>=0;r--)await this.childrenNodes[r].traverse(e,t,n);else for(const r of this.childrenNodes)await r.traverse(e,t,n);else await E.import(await e.deFrost(this.frozenChunkId)).traverse(e,t,n);n&&await t(this)}async validate(e,t=1){let n="";if(A(this.from)!==A(this.to)&&(n+="[1]"),this.childrenValues.length>0&&this.childrenNodes.length>0&&(n+="[2]"),0===this.childrenValues.length&&0===this.childrenNodes.length||(A(this.from)&&(n+="[3]"),0===this.count&&(n+="[4]")),this.childrenValues.length>0){const e=this.childrenValues.map((e=>e.count)).reduce(((e,t)=>e+t),0);this.count!==e&&(n+="[5]"),1!==this.height&&(n+="[6]")}if(this.childrenNodes.length>0){this.childrenNodes.map((e=>e.height)).some((e=>A(e)||0===e))&&(n+="[7]");const e=this.childrenNodes.map((e=>e.height)).reduce(((e,t)=>Math.max(e,t)),0);this.height!==e+1&&(n+="[8]")}if(A(this.frozenChunkId)||(this.childrenValues.length>0&&(n+="[9]"),this.childrenNodes.length>0&&(n+="[10]")),this.count===e.branchFactor**this.height&&(this.childrenValues.length>0&&(n+="[11]"),this.childrenNodes.length>0&&(n+="[12]"),A(this.frozenChunkId)&&(n+="[13]"),this.isFull||(n+="[14]")),function(n,r){if(A(r)||r<=1)return!1;const a=r/t,s=Math.log(a)/Math.log(e.branchFactor),i=Math.abs(s-n)>1+1e-10;return i&&console.log(Le,"Height error found.\nheight =",n,", count =",r,", actualCount =",a,", exponent =",s,", Math.floor(exponent) =",Math.floor(s),", branch =",e.branchFactor,", branch ** height =",e.branchFactor**n,Le),i}(this.height,this.count)&&(n+="[15]"),this.childrenNodes.length>=2)for(let e=0;e<this.childrenNodes.length-1;e++)(A(this.childrenNodes[e].to)||A(this.childrenNodes[e+1].to))&&(n+="[16]"),(A(this.childrenNodes[e].from)||A(this.childrenNodes[e+1].from))&&(n+="[17]"),this.childrenNodes[e].to>=this.childrenNodes[e+1].from&&(n+="[18]");if(""!==n)throw console.error(Le,"Validation failed: "+n,Le),new Error("Validation failed: "+n);if(this.childrenNodes.length>0)for(const n of this.childrenNodes)await n.validate(e,t)}async _callbackValues(e,t,n=!1){if(e.childrenValues.length>0){const r=n?e.childrenValues.slice().reverse():e.childrenValues;for(const e of r)A(t)||await t(e)}}async traverseValues(e,t,n=!1){return this.traverse(e,(async e=>await this._callbackValues(e,t,n)),n)}export(){let e={from:this.from,to:this.to,count:this.count,height:this.height};return this.isFull&&(e.isFull=!0),A(this.frozenChunkId)?this.childrenValues.length>0?e={...e,isLeaf:!0,children:this.childrenValues}:this.childrenNodes.length>0&&(e={...e,children:this.childrenNodes.map((e=>e.export()))}):e={...e,frozenChunkId:this.frozenChunkId},e}static import(e){const t=new E(e.isLeaf);return t.from=e.from,t.to=e.to,t.count=e.count,t.height=e.height,A(e.frozenChunkId)?e.isLeaf?(t.isFull=e.isFull,t.childrenValues=e.children):(t.isFull=e.isFull,e.children&&e.children.length>0&&(t.childrenNodes=e.children.map((e=>E.import(e))))):(t.frozenChunkId=e.frozenChunkId,t.isFull=!0),t}}function A(e){return null==e}class I{branchFactor;root=new E(!0);insertOrValidateLock=!1;constructor(e,t){this.branchFactor=e,t&&(this.root=E.import(t))}async insertTreeNodeValue(e){if(this.insertOrValidateLock)throw new Error("Insertion or validation already in progress (these operations are not parallelized, are you missing an 'await'?)");this.insertOrValidateLock=!0;const{count:t,from:n,to:r}=e;if(!A(this.root.to)&&n<=this.root.to)throw new Error(`Insertion 'from' index ('${n}') must be greater than the highest 'to' value in the tree (currently '${this.root.to}')`);if(this.root.isFull){const e=new E;e.from=this.root.from,e.to=this.root.to,e.count=this.root.count,e.height=this.root.height+1,e.childrenNodes.push(this.root),this.root=e}await this.root.insertTreeNodeValue(this,e),this.insertOrValidateLock=!1}async traverse(e,t=!1){return this.root.traverse(this,e,t)}async traverseValues(e,t=!1){return this.root.traverseValues(this,e,t)}async validate(e){if(this.insertOrValidateLock)throw new Error("Validation or insertion already in progress (these operations are not parallelized, are you missing an 'await'?)");if(this.insertOrValidateLock=!0,A(this.root))throw new Error("Root missing (Internal Error)");await this.root.validate(this,e),this.insertOrValidateLock=!1}export(){return this.root?this.root.export():{}}}class P extends I{branchFactor;static MAX_MESSAGE_HISTORY_SHARD_SIZE=4128768;constructor(e,t){super(e,t),this.branchFactor=e}async freeze(e){return await this.storeData(e)}async deFrost(e){return await this.fetchData(e)}}class B extends P{static MESSAGE_HISTORY_BRANCH_FACTOR=32;static MAX_MESSAGE_SET_SIZE=512;constructor(e){super(B.MESSAGE_HISTORY_BRANCH_FACTOR,e)}async insert(e){await this.insertTreeNodeValue(e)}async fetchData(e){throw new Error("[ServerDeepHistory] should not be fetching data (server-side is write-only)")}}class M extends P{channel;SB;constructor(e,t){super(B.MESSAGE_HISTORY_BRANCH_FACTOR,e),this.channel=t,this.SB=new We(this.channel.channelServer)}async storeData(e){throw new Error("[ClientDeepHistory] should not be storing data (client-side is read-only)")}async fetchData(e){if(!this.SB)throw new Error("SB required to fetch data");return(await this.SB.storage.fetchData(e)).payload}async traverseMessages(e,t=!1){await this.traverseValues((async n=>{const r=n;if(r.shard){const n=await this.fetchData(r.shard);if(!(n instanceof Map))throw new Error("Expected a map");const a=Array.from(n.keys());a.sort(),t&&a.reverse();for(const t of a){const r=n.get(t);if(r){const t=await this.channel.extractMessage(r);t&&(e?await e(t):console.log(t))}}}}),t)}async traverseMessagesEncrypted(e){await this.traverseValues((async t=>{const n=t;if(n.shard){const t=await this.fetchData(n.shard);if(!(t instanceof Map))throw new Error("Expected a map");for(const[n,r]of t)await e(n,r)}}))}async validate(){await super.validate(B.MAX_MESSAGE_SET_SIZE)}}class K{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}class R{queue=[];resolve=null;reject=null;closed=!1;error=null;enqueue(e){if(this.closed)throw new x("[MessageQueue] Error, trying to enqueue to closed queue");this.resolve?(this.resolve(e),this.resolve=null,this.reject=null):this.queue.push(e)}async dequeue(){if(this.queue.length>0){const e=this.queue.shift();return this.closed?Promise.reject(e):Promise.resolve(e)}return this.closed?null:new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}isEmpty(){return 0===this.queue.length}close(e){this.closed=!0,this.error=e||"close",this.reject&&this.reject(this.error)}async drain(e){for(this.closed||this.close(e||"drain");this.queue.length>0;)await new Promise((e=>setTimeout(e,0)))}}class x extends Error{constructor(e){super(e),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(e).stack}}function T(e,t,n){for(;e&&"string"==typeof e;)try{e=JSON.parse(e,n)}catch(n){throw new x(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}const D=/^\s*[\[\{].*[\]\}]\s*$/;function _(e){if(null===e)return null;if("string"!=typeof e)return null;if(!D.test(e))return e;try{return JSON.parse(e)}catch(e){return null}}const N=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function F(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=N(e),r=N(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function L(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{H(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}function O(e=16){const t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",n=t+"0123456789";return Array.from({length:e},((e,r)=>0===r?t.charAt(Math.floor(52*Math.random())):n.charAt(Math.floor(Math.random()*n.length)))).join("")}async function j(e,t){const n=new AbortController,r=Symbol("fetch");We.activeFetches.set(r,n);try{const r=await fetch(e,{...t,signal:n.signal});if(We.isShutdown)throw await(r.body?.cancel("shutDown")),new x("Fetch aborted (shutDown)");return r}catch(r){if(r instanceof x)throw r;const a=`${r}`;if(-1===a.indexOf("connection closed before message completed")&&-1===a.indexOf("Connection reset by peer")&&-1===a.indexOf("The connection was reset")&&-1===a.indexOf("The server closed the connection")&&-1===a.indexOf("Please try sending the request again."))throw new x(`[SBFetch] Error performing fetch() (this might be normal): ${r}`);console.warn(`... got error ('${a}'), retrying fetch() once again`);try{return await new Promise((r=>{setTimeout((()=>{r(fetch(e,{...t,signal:n.signal}))}),0)}))}catch(e){throw console.error("... got an error on retrying fetch()"),new x(`[SBFetch] Error performing fetch() (after RETRY): ${r}`)}}finally{We.activeFetches.delete(r)}}var $=j;async function U(e,t){let n;try{if(n=await $(e,t),!n)throw new x("[SBApiFetch] Server did not respond (might be expected)");if(!n.ok){const e=await n.text();let t="[SBApiFetch] Server responded with error\n";throw n.status&&(t+=`  Status code: ('${n.status}')\n`),n.statusText&&(t+=`  Status text: ('${n.statusText}')\n`),e&&(t+=`  Error msg:   ('${e}')\n`),new x(t)}const a=n.headers.get("content-type");var r;if(!a)throw new x("[SBApiFetch] No content header in server response");if(-1!==a.indexOf("application/json"))r=T(await n.json(),"L489");else{if(-1===a.indexOf("application/octet-stream"))throw-1!==a.indexOf("text/plain")?(r=await n.text(),new x(`[SBApiFetch] Server responded with text/plain (?):\n('${r}')`)):new x(`[SBApiFetch] Server responded with unknown content-type header ('${a}')`);r=be(await n.arrayBuffer()).payload}if(!r||r.error||!1===r.success){let e="[SBApiFetch] No server response, or cannot parse, or error in response";throw n.status&&(e+=" ["+n.status+"]"),r?.error&&(e+=": "+r.error),new x(e)}return r}catch(e){throw n&&n.body&&!n.body.locked&&await n.body.cancel(),e instanceof x?e:new x(`[SBApiFetch] caught error: ${e}`)}}function V(e){const t=" *ErrorStart* ",n=" *ErrorEnd* ";return e instanceof x?e:e instanceof Error?new x(t+e.message+n):new x(t+String(e)+n)}function z(e,t){throw new x("[_sb_exception] << SB lib error ("+e+": "+t+") >>")}function H(e,t){if(!e)throw new x(` <<<<[_sb_assert] assertion failed: '${t}'>>>> `)}function G(e){let t=0;for(const n of e)t+=n.byteLength;const n=new Uint8Array(t);let r=0;for(const t of e)n.set(new Uint8Array(t),r),r+=t.byteLength;return n.buffer}const q="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",W=/^([A-Za-z0-9\-_]*)(={0,2})$/;function Z(e){const t=e instanceof ArrayBuffer?new Uint8Array(e):e;let n="";for(let e=0;e<t.length;e+=3){const r=t[e],a=t[e+1],s=t[e+2];n+=q[r>>2]+q[(3&r)<<4|a>>4]+(void 0!==a?q[(15&a)<<2|s>>6]:"")+(void 0!==s?q[63&s]:"")}return n}function J(e){if(e=e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),!W.test(e))throw new x(`invalid character in b64 string (after cleanup: '${e}')`);const t=e.length,n=new Uint8Array(3*t/4);for(let r=0,a=0;r<t;r+=4){const[t,s,i,o]=[e[r],e[r+1],e[r+2],e[r+3]].map((e=>q.indexOf(e)));n[a++]=t<<2|s>>4,-1!==i&&(n[a++]=(15&s)<<4|i>>2),-1!==o&&(n[a++]=(3&i)<<6|o)}return n}const Q="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",X=Q[0],Y=/^[A-Za-z0-9]*$/,ee=Y;function te(e){return Y.test(e)}const ne=32,re=new Map,ae=new Map;for(let e=1;e<=ne;e++){const t=Math.ceil(8*e/Math.log2(62));re.set(e,t),ae.set(t,e)}const se=re.get(ne);function ie(){console.log("fooBar")}function oe(e){function t(e,t){let n="",r=0n;for(const t of e)r=r<<8n|BigInt(t);for(;r>0n;r/=62n)n=Q[Number(r%62n)]+n;return n.padStart(re.get(t),X)}if(null==e)throw new x("arrayBufferToBase62: buffer is null or undefined");const n=e instanceof ArrayBuffer?new Uint8Array(e):e;let r="";for(let e,a=n.byteLength,s=0;a>0;s+=e,a-=e)e=a>=ne?ne:a,r+=t(n.slice(s,s+e),e);return r}function ce(e){if(!Y.test(e))throw new x("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");function t(e,t){try{let n=0n,r=new Uint8Array(t);for(let t=0;t<e.length;t++)n=62n*n+BigInt(Q.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new x("base62ToArrayBuffer: Invalid Base62 string.");for(let e=t-1;e>=0;e--,n>>=8n)r[e]=Number(0xffn&n);return r}catch(e){throw new x("base62ToArrayBuffer: Invalid Base62 string.")}}try{let n=0,r=new Uint8Array(6*e.length/8);for(let a,s,i=0;i<e.length;i+=a,n+=s.byteLength)a=Math.min(e.length-i,se),s=t(e.slice(i,i+a),ae.get(a)),r.set(s,n);return r.buffer.slice(0,n)}catch(e){throw e}}function le(e){return Z(ce(e))}function he(e){return oe(J(e))}const de="0123456789ADMRTxQjrEywcLBdHpNufk",ue=new RegExp(`[${de}.concat(' ')]`);function fe(e){const t=de;if(e<0||e>524287)throw new Error("Input number is out of range. Expected a 19-bit integer.");let n=[e>>14&31,e>>9&31,e>>4&31,15&e];return n[3]|=16&(n[0]^n[1]^n[2]),n.map((e=>t[e])).join("")}function ye(e){const t={o:"0",O:"0",i:"1",I:"1",l:"1",z:"2",Z:"2",s:"5",S:"5",b:"6",G:"6",a:"9",g:"9",q:"9",m:"M",t:"T",X:"x",J:"j",e:"E",Y:"y",W:"w",C:"c",P:"p",n:"N",h:"N",U:"u",v:"u",V:"u",F:"f",K:"k"};let n="";for(let r of e)n+=t[r]||r;return n}function ge(e){if(!ue.test(e))throw new Error(`Input string contains invalid characters (${e}) - use 'process()'.`);let t=Array.from(e).map((e=>de.indexOf(e)));return 16&t.reduce(((e,t)=>e^t))?null:16*(32*(32*t[0]+t[1])+t[2])+(15&t[3])}function pe(e){if(null===e)return"0";if(void 0===e)return"u";if(Array.isArray(e))return"a";if(e instanceof ArrayBuffer)return"x";if(e instanceof Uint8Array)return"8";if("boolean"==typeof e)return"b";if(e instanceof DataView)return"v";if(e instanceof Date)return"d";if(e instanceof Map)return"m";if("number"==typeof e)return"number"==typeof(t=e)&&t>=-2147483648&&t<=2147483647&&t%1==0?"i":"n";var t;if(null!==e&&"object"==typeof e&&e.constructor===Object)return"o";if(e instanceof Set)return"t";if("string"==typeof e)return"s";if(e instanceof WeakRef)return"w";if("object"==typeof e&&"function"==typeof e.then)console.error("[getType] Trying to serialize a Promise - did you forget an 'await'?");else{if("object"==typeof e&&"function"==typeof e.toJSON)return"j";console.error("[getType] Unsupported for object:",e)}throw new x("Unsupported type")}function we(e){try{const t={};let n=0,r=0,a=[];for(const s in e)if(e.hasOwnProperty(s)){const i=e[s],o=pe(i);switch(o){case"o":const e=we(i);if(!e)throw new x(`Failed to assemble payload for ${s}`);a.push(e);break;case"j":const t=we(i.toJSON(""));if(!t)throw new x(`Failed to process toJSON for ${s}`);a.push(t);break;case"n":const n=new Uint8Array(8);new DataView(n.buffer).setFloat64(0,i),a.push(n.buffer);break;case"i":const r=new Uint8Array(4);new DataView(r.buffer).setInt32(0,i),a.push(r.buffer);break;case"d":const c=new Uint8Array(8);new DataView(c.buffer).setFloat64(0,i.getTime()),a.push(c.buffer);break;case"b":const l=new Uint8Array(1);l[0]=i?1:0,a.push(l.buffer);break;case"s":const h=(new TextEncoder).encode(i);a.push(h);break;case"x":a.push(i);break;case"8":a.push(i.buffer);break;case"m":const d=new Array;i.forEach(((e,t)=>{d.push([t,e])}));const u=we(d);if(!u)throw new x(`Failed to assemble payload for ${s}`);a.push(u);break;case"a":const f=new Array;i.forEach((e=>{f.push(e)}));const y=we(f);if(!y)throw new x(`Failed to assemble payload for ${s}`);a.push(y);break;case"t":const g=new Array;i.forEach((e=>{g.push(e)}));const p=we(g);if(!p)throw new x(`Failed to assemble payload for ${s}`);a.push(p);break;case"w":case"0":case"u":a.push(new ArrayBuffer(0));break;default:throw console.error(`[assemblePayload] Unsupported type: ${o}`),new x(`Unsupported type: ${o}`)}const c=a[a.length-1].byteLength;n++,t[n.toString()]={n:s,s:r,z:c,t:o},r+=c}const s=(new TextEncoder).encode(JSON.stringify(t));return G([new Uint32Array([s.byteLength]).buffer,s,...a])}catch(e){return console.error(e),null}}function ve(e){const t=we({ver003:!0,payload:e});return t?G([new Uint8Array([170,187,187,170]),t]):null}function me(e,t){switch(t){case"o":return Se(e);case"j":try{return JSON.parse((new TextDecoder).decode(e))}catch(t){return Se(e)}case"n":return new DataView(e).getFloat64(0);case"i":return new DataView(e).getInt32(0);case"d":return new Date(new DataView(e).getFloat64(0));case"b":return 1===new Uint8Array(e)[0];case"s":return(new TextDecoder).decode(e);case"a":const n=Se(e);if(!n)throw new x(`Failed to assemble payload for ${t}`);return Object.values(n);case"m":const r=Se(e);if(!r)throw new x(`Failed to assemble payload for ${t}`);const a=new Map;for(const e in r)a.set(r[e][0],r[e][1]);return a;case"t":const s=Se(e);if(!s)throw new x(`Failed to assemble payload for ${t}`);const i=new Set;for(const e in s)i.add(s[e]);return i;case"x":return e;case"8":return new Uint8Array(e);case"0":return null;case"u":return;default:throw new x(`Unsupported type: ${t}`)}}function Se(e){const t="Cannot parse metadata, this is not a well-formed payload";try{const n=new Uint32Array(e.slice(0,4))[0],r=(new TextDecoder).decode(e.slice(4,4+n));let a;try{a=T(r,"L1290")}catch(e){throw new x(t)}const s=4+n,i={};for(let t=1;t<=Object.keys(a).length;t++){const n=t.toString();if(a[n]){const t=a[n],r=t.s,o=t.z,c=t.t,l=e.slice(s+r,s+r+o);i[t.n]=me(l,c)}else console.log(`found nothing for index ${t}`)}return i}catch(e){if(e instanceof Error&&e.message===t)throw e;throw new x("[extractPayload] exception <<"+e+">> [/extractPayload]")}}function be(e){if(2864429994!==new Uint32Array(e,0,1)[0])throw new x("Invalid payload signature (this is not a payload)");return Se(e.slice(4))}var ke,Ce;function Ee(e){"string"==typeof e&&(e=J(e));const t=new Uint8Array(e);return 1==(1&t[t.length-1])?1:0}function Ae(e){try{if(e.length<=4)return;const t=e.slice(0,4),n=e.slice(4);switch(t.slice(0,3)){case ke.SBPublicKey:switch(t[3]){case Ce.Uncompressed:{const e=ce(n);if(96!==e.byteLength)return;const t=e.slice(48,96);return{x:Z(e.slice(0,48)),y:Z(t),ySign:Ee(t)}}case Ce.CompressedEven:case Ce.CompressedOdd:{const e=t[3]===Ce.CompressedEven?0:1,r=ce(n);if(48!==r.byteLength)return;const{x:a,y:s}=Oe(Z(r),e);return{x:a,y:s,ySign:e}}default:console.error("KeySubPrefix not recognized")}break;case ke.SBPrivateKey:switch(t[3]){case Ce.Uncompressed:{const e=ce(n);if(144!==e.byteLength)return;const t=e.slice(48,96);return{x:Z(e.slice(0,48)),y:Z(t),ySign:Ee(t),d:Z(e.slice(96,144))}}case Ce.CompressedEven:case Ce.CompressedOdd:{const e=t[3]===Ce.CompressedEven?0:1,r=ce(n);if(96!==r.byteLength)return;const a=r.slice(0,48),{x:s,y:i}=Oe(Z(a),e);return{x:s,y:i,ySign:e,d:Z(r.slice(48,96))}}case Ce.Dehydrated:return void console.error("parseSB384string() - you need to rehydrate first ('hydrateKey()')");default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}return}catch(e){return void console.error("parseSB384string() - malformed input, exception: ",e)}}function Ie(e,t,n){if(!e||64!==e.length||!t||64!==t.length||void 0===n)return;const r=new Uint8Array(96);return r.set(J(e),0),r.set(J(t),48),ke.SBPrivateKey+(0===n?Ce.CompressedEven:Ce.CompressedOdd)+oe(r)}function Pe(e,t){if(e.length<=4)return;const n=e.slice(0,4);switch(n.slice(0,3)){case ke.SBPublicKey:return e;case ke.SBPrivateKey:switch(n[3]){case Ce.Uncompressed:case Ce.CompressedEven:case Ce.CompressedOdd:return e;case Ce.Dehydrated:{if(!t)return void console.error("hydrateKey() - you need to provide pubKey to hydrate");const n=Z(ce(e.slice(4)).slice(0,48)),r=Ae(t);return r&&r.x&&void 0!==r.ySign?Ie(r.x,n,r.ySign):void console.error("hydrateKey() - failed to parse public key")}default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}}!function(e){e.SBPublicKey="PNk",e.SBPrivateKey="Xj3",e.SBDehydratedKey="XjZ"}(ke||(ke={})),function(e){e.CompressedEven="2",e.CompressedOdd="3",e.Uncompressed="4",e.Dehydrated="x"}(Ce||(Ce={}));class Be{generateIdKey(e){if(!(e instanceof ArrayBuffer))throw new TypeError("Input must be an ArrayBuffer");return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({idBinary:n,keyMaterial:r})}))}catch(e){n(e)}}))}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new x("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,a){try{let s;const i={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new x("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),s=await crypto.subtle.importKey("jwk",e,i[n],r,a)}else s=await crypto.subtle.importKey(e,t,i[n],r,a);return s}catch(e){throw new x(`... importKey() error: ${e}:`)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{}))}async encrypt(e,t,n){if(null===e)throw new x("no contents");if(!n.iv)throw new x("no nonce");return n.name?H("AES-GCM"===n.name,"Must be AES-GCM (L1951)"):n.name="AES-GCM",crypto.subtle.encrypt(n,t,e)}async wrap(e,t,n,r,a){const s=ve(e),i=crypto.getRandomValues(new Uint8Array(12)),o=await We.dateNow(),c=new DataView(new ArrayBuffer(8));return c.setFloat64(0,o),{f:t,c:await Fe.encrypt(s,n,{iv:i,additionalData:c}),iv:i,salt:r,s:await Fe.sign(a,s),ts:o}}sign(e,t){return crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-384"}},e,t)}verify(e,t,n){return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},e,t,n)}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}}function Me(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function Ke(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name,a=e.constructor.ReadyFlag;H(a in this,"'readyFlagSymbol' missing yet getter accessed with @Ready pattern (fatal)"),H(this[a],`'${n}.${t}' getter accessed but object not 'ready' (fatal)`);const s=r.call(this);return H(null!=s,`'${n}.${t}' getter accessed but return value will be NULL (fatal)`),s}}}function Re(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;return"owner"in this&&H(!0===this.owner,`${t} getter or method accessed for object ${n} but callee is not channel owner`),r.call(this)}}}const xe=Symbol("SB_CHANNEL_MESSAGE_SYMBOL"),Te=Symbol("SB_CHANNEL_API_BODY_SYMBOL"),De=Symbol("SBChannelHandle"),_e=Symbol.for("SBObjectHandle"),Ne=Symbol.for("SBStorageToken"),Fe=new Be,Le="\n"+"=".repeat(76)+"\n";function Oe(e,t){const n=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),r=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),a=(n+1n)/4n,s=new Uint8Array(J(e)),i="0x"+Array.from(s,(e=>e.toString(16).padStart(2,"0"))).join("");var o=BigInt(i),c=function(e,t,n){if(1n===n)return 0n;let r=1n;for(e%=n;t>0n;)t%2n===1n&&(r=r*e%n),t>>=1n,e=e*e%n;return r}(o*o*o-3n*o+r,a,n);c%2n!==BigInt(t)&&(c=n-c);const l=c.toString(16).padStart(96,"0");return{x:e,y:Z(new Uint8Array(l.match(/.{1,2}/g).map((e=>parseInt(e,16)))))}}"=".repeat(76);class je{sb384Ready;static ReadyFlag=Symbol("SB384ReadyFlag");#t;#n;#r;#a;#s;#i;#o;#c;#l;#h;errorState=!1;constructor(e,t){this[je.ReadyFlag]=!1,this.sb384Ready=new Promise((async(n,r)=>{try{if(e)if(e instanceof CryptoKey){const n=await Fe.exportKey("jwk",e);H(n&&n.x&&n.y,"INTERNAL"),n.d?(this.#t=!0,this.#s=n.d):(this.#t=!1,H(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#r=n.y}else if(e&&e instanceof Object&&"kty"in e){const n=e;H(n&&n.x&&n.y,"Cannot parse format of JWK key"),e.d?(this.#t=!0,this.#s=n.d):(this.#t=!1,H(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#r=n.y}else{if("string"!=typeof e)throw new x("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=Ae(e);if(!n)throw new x("ERROR creating SB384 object: invalid key (must be a JsonWebKey | SBUserPublicKey | SBUserPrivateKey, or omitted)");const{x:r,y:a,d:s}=n;s?(this.#t=!0,this.#s=s):(this.#t=!1,H(!t,"ERROR creating SB384 object: key provided is not the requested private")),H(r&&a,"INTERNAL"),this.#n=r,this.#r=a}}else{const e=await Fe.generateKeys(),t=await Fe.exportKey("jwk",e.privateKey);H(t&&t.x&&t.y&&t.d,"INTERNAL"),this.#t=!0,this.#n=t.x,this.#r=t.y,this.#s=t.d}if(this.#t&&(this.#i=await Fe.importKey("jwk",this.jwkPrivate,"ECDH",!0,["deriveKey"])),this.#o=await Fe.importKey("jwk",this.jwkPublic,"ECDH",!0,[]),this.#t){const e={...this.jwkPrivate,key_ops:["sign"]};this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["sign"])}else{const e={...this.jwkPublic,key_ops:["verify"]};this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["verify"])}const r=G([J(this.#n),J(this.#r)]),a=await crypto.subtle.digest("SHA-256",r);this.#l=oe(a);const s=BigInt("0x"+Array.from(new Uint8Array(a)).map((e=>e.toString(16).padStart(2,"0"))).join(""))>>28n;this.#h=Array.from({length:12},((e,t)=>fe(Number(s>>BigInt(19*(11-t))&0x7ffffn)))).join(""),this.#a=Ee(this.#r),this[je.ReadyFlag]=!0,n(this)}catch(e){r("ERROR creating SB384 object failed: "+V(e))}}))}get SB384ReadyFlag(){return this[je.ReadyFlag]}get ready(){return this.sb384Ready}get private(){return this.#t}get hash(){return this.#l}get hashB32(){return this.#h}get userId(){return this.hash}get ownerChannelId(){return this.hash}get privateKey(){if(!this.private)throw new x("this is a public key, there is no 'privateKey' value");return this.#i}get signKey(){return this.#c}get publicKey(){return this.#o}get jwkPrivate(){return H(this.#t,"jwkPrivate() - not a private key"),H(this.#n&&this.#r&&this.#s,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:["deriveKey"],kty:"EC",x:this.#n,y:this.#r,d:this.#s}}get jwkPublic(){return H(this.#n&&this.#r,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:this.#n,y:this.#r}}get ySign(){return H(null!==this.#a,"ySign() - ySign is not available (fatal)"),this.#a}get userPublicKey(){return H(this.#n&&void 0!==this.#a,"userPublicKey() - sufficient key info is not available (fatal)"),ke.SBPublicKey+(0===this.#a?Ce.CompressedEven:Ce.CompressedOdd)+he(this.#n)}get userPrivateKey(){H(this.#t,"userPrivateKey() - not a private key, there is no userPrivateKey");const e=Ie(this.#n,this.#s,this.#a);return H(void 0!==e,"userPrivateKey() - failed to construct key, probably missing info (fatal)"),e}get userPrivateKeyDehydrated(){return H(this.#t&&this.#s,"userPrivateKey() - not a private key, and/or 'd' is missing, there is no userPrivateKey"),ke.SBPrivateKey+Ce.Dehydrated+he(this.#s)}static async newPrivateKey(){return(await(new je).ready).userPrivateKey}}a([Me,Ke],je.prototype,"private",null),a([Me,Ke],je.prototype,"hash",null),a([Me,Ke],je.prototype,"hashB32",null),a([Me,Ke],je.prototype,"userId",null),a([Me,Ke],je.prototype,"ownerChannelId",null),a([Me,Ke],je.prototype,"privateKey",null),a([Me,Ke],je.prototype,"signKey",null),a([Me,Ke],je.prototype,"publicKey",null),a([Me],je.prototype,"jwkPrivate",null),a([Me],je.prototype,"jwkPublic",null),a([Me],je.prototype,"ySign",null),a([Me],je.prototype,"userPublicKey",null),a([Me],je.prototype,"userPrivateKey",null),a([Me],je.prototype,"userPrivateKeyDehydrated",null);class $e{#d;#u;constructor(e,t){this.#u=t,this.#d=this.initializeMasterKey(e)}async ready(){await this.#d}setChannel(e){}async initializeMasterKey(e){const t=this.#u.salt1,n=this.#u.iterations1,r=this.#u.hash1;H(t&&n&&r,"Protocol_AES_GCM_256.initializeMasterKey() - insufficient key info (fatal)");const a=await crypto.subtle.importKey("raw",(new TextEncoder).encode(e),{name:"PBKDF2"},!1,["deriveBits","deriveKey"]),s=await crypto.subtle.deriveBits({name:"PBKDF2",salt:t,iterations:n,hash:r},a,256);return crypto.subtle.importKey("raw",s,{name:"PBKDF2"},!1,["deriveBits","deriveKey"])}static async genKey(){return{salt1:crypto.getRandomValues(new Uint8Array(16)).buffer,iterations1:1e5,iterations2:1e4,hash1:"SHA-256",summary:"PBKDF2 - SHA-256 - AES-GCM"}}async#f(e){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:this.#u.iterations2,hash:this.#u.hash1},await this.#d,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async encryptionKey(e){return H(e.salt,"Protocol called without salt (Internal Error)"),this.#f(e.salt)}async decryptionKey(e,t){if(t.salt)return this.#f(t.salt);console.warn("Salt should always be present in ChannelMessage")}}class Ue{#y;#g=new Map;constructor(){}setChannel(e){this.#y=e}async encryptionKey(e){H(this.#y,"[Protocol_ECDH] Error, need to know channel (L2511)"),await this.#y.ready;const t=this.#y.channelId;H(t,"Internal Error (L2565)");const n=e.t?e.t:this.#y.channelData.ownerPublicKey;return this.#p(t,n,this.#y.privateKey)}async decryptionKey(e,t){await e.ready;const n=e.channelId;H(n,"Internal Error (L2594)");const r=e.visitors.get(t.f);if(r)return this.#p(n,r,e.privateKey);console.error("Protocol_ECDH.key() - sentFrom is unknown")}async#p(e,t,n){const r=e+"_"+t;if(!this.#g.has(r)){const e=await crypto.subtle.deriveKey({name:"ECDH",public:(await new je(t).ready).publicKey},n,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);this.#g.set(r,e)}const a=this.#g.get(r);return H(a,"Internal Error (L2584/2611)"),a}}class Ve extends je{#w;sbChannelKeysReady;static ReadyFlag=Symbol("SBChannelKeysReadyFlag");#v;channelServer;constructor(e){let t;if(null===e)throw new x("SBChannelKeys constructor: you cannot pass 'null'");if(e)if("string"==typeof e)super(e,!0);else{if(!l(e))throw new x("SBChannelKeys() constructor: invalid parameter (must be SBChannelHandle or SBUserPrivateKey)");{const n=h(e);t=n.channelServer,super(n.userPrivateKey,!0),this.#w=n.channelId,this.#v=n.channelData}}else super();t||(t=We.defaultChannelServer),"/"===t[t.length-1]&&(this.channelServer=t.slice(0,-1)),this.channelServer=t,this[Ve.ReadyFlag]=!1,this.sbChannelKeysReady=new Promise((async(e,t)=>{try{if(await this.sb384Ready,H(this.private,"Internal Error [L2833]"),!this.#w||this.owner)this.#w||(this.#w=this.ownerChannelId),this.#v={channelId:this.ownerChannelId,ownerPublicKey:this.userPublicKey};else if(!this.#v){if(!this.channelServer)throw new x("SBChannelKeys() constructor: either key is owner key, or handle contains channelData, or channelServer is provided ...");var n;try{n=await this.callApi("/getChannelKeys")}catch(e){for(;;){await new Promise((e=>setTimeout(e,1e3)));try{n=await this.callApi("/getChannelKeys");break}catch(e){console.error("SBChannelKeys() constructor: failed to get channel data, retrying ...")}}}H((n=u(n)).channelId===this.#w,"Internal Error (L2493)"),this.#v=n}this[Ve.ReadyFlag]=!0,e(this)}catch(e){t("[SBChannelKeys] constructor failed. "+V(e))}}))}get ready(){return this.sbChannelKeysReady}get SBChannelKeysReadyFlag(){return this[Ve.ReadyFlag]}get owner(){return this.private&&this.ownerChannelId&&this.channelId&&this.ownerChannelId===this.channelId}get channelId(){if(this.#w)return this.#w;throw new x("[SBChannelKeys] ChannelID not known / object not ready. Internal Error (L894)")}get channelData(){return this.#v}get handle(){return{[De]:!0,channelId:this.channelId,userPrivateKey:this.userPrivateKey,channelServer:this.channelServer,channelData:this.channelData}}async buildApiBody(e,t){await this.sb384Ready;const n=await We.dateNow(),r=new ArrayBuffer(8);new DataView(r).setFloat64(0,n);const a=G([r,(new TextEncoder).encode(e).buffer]),s=t?ve(t):void 0,i=await Fe.sign(this.signKey,s?G([a,s]):a),o={channelId:this.#w,path:e,userId:this.userId,userPublicKey:this.userPublicKey,timestamp:n,sign:i};return s&&(o.apiPayloadBuf=s),y(o)}callApi(e,t){return H(this.channelServer,"[ChannelApi.callApi] channelServer is unknown (you can just set it, eg 'channel.channelServer = ...')"),H(this.#w&&e,"Internal Error (L2528)"),new Promise((async(n,r)=>{const a={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:ve(await this.buildApiBody(e,t))};U(this.channelServer+"/api/v2/channel/"+this.#w+e,a).then((e=>{n(e)})).catch((e=>{r(e instanceof x?e:"[Channel.callApi] Error: "+V(e))}))}))}}a([Me],Ve.prototype,"owner",null),a([Me],Ve.prototype,"channelId",null),a([Me,Ke],Ve.prototype,"channelData",null),a([Me,Ke],Ve.prototype,"handle",null);class ze extends Ve{channelReady;static ReadyFlag=Symbol("ChannelReadyFlag");locked=!1;static defaultProtocol=new Ue;protocol=ze.defaultProtocol;visitors=new Map;sendQueue=new R;isClosed=!1;previous=void 0;constructor(e,t){null===e?super():super(e),this.protocol=t||ze.defaultProtocol,this.messageQueueManager().then((()=>{})).catch((e=>{throw e})),this.channelReady=this.sbChannelKeysReady.then((()=>(this.visitors.set(this.channelId,this.channelData.ownerPublicKey),this[ze.ReadyFlag]=!0,this.protocol.setChannel(this),this))).catch((e=>{throw e}))}get ready(){return H(!this.isClosed,"[Channel] Channel is closed, blocking on'ready' will reject"),this.channelReady}get ChannelReadyFlag(){return this[ze.ReadyFlag]}get api(){return this}async extractMessage(e){if(e){if(e instanceof ArrayBuffer)throw new x("[Channel.extractMessage] Message is an ArrayBuffer (did you forget extractPayload()?)");try{if(!(e=g(e)))return;const t=e.f;if(!t)return void console.error("++++ [extractMessage]: no sender userId hash in message (probably an error)");if(!this.visitors.has(t)){const e=await this.callApi("/getPubKeys");if(!(e&&e instanceof Map))return;for(const[t,n]of e)this.visitors.set(t,n)}H(this.visitors.has(t),`Cannot find sender userId hash ${t} in public key map`),H(this.protocol,"Protocol not set (internal error)");const n=await(this.protocol?.decryptionKey(this,e));if(!n)return;if(!e.ts)throw new x("unwrap() - no timestamp in encrypted message");const{c:r,iv:a}=e;H(r,"[unwrap] No contents in encrypted message (probably an error)");const s=new DataView(new ArrayBuffer(8));let i;s.setFloat64(0,e.ts);try{i=await crypto.subtle.decrypt({name:"AES-GCM",iv:a,additionalData:s},n,r)}catch(e){return}return e._id||(e._id=ze.composeMessageKey(this.channelId,e.sts,e.i2)),f({body:be(i).payload,channelId:this.channelId,sender:t,senderPublicKey:this.visitors.get(t),senderTimestamp:e.ts,serverTimestamp:e.sts,_id:e._id})}catch(e){return}}}async extractMessageMap(e){const t=new Map;for(const[n,r]of e){const e=await this.extractMessage(r);e&&t.set(n,e)}return t}packageMessage(e,t={}){let n={f:this.userId,unencryptedContents:e};if(t){if(t.sendTo&&(n.t=t.sendTo),t.subChannel)throw new x("wrapMessage(): subChannel not yet supported");void 0!==t.ttl&&(n.ttl=t.ttl),t.sendString&&(H("string"==typeof e,"[packageMessage] sendString is true, but contents is not a string"),H(void 0===t.ttl||0===t.ttl,`[packageMessage] sendString implies TTL=0 (we got ${t.ttl})`),n.ttl=0,n.stringMessage=!0)}return!0!==n.stringMessage&&(n.protocol=t.protocol?t.protocol:this.protocol,void 0===n.ttl&&(n.ttl=15),n.salt||(n.salt=crypto.getRandomValues(new Uint8Array(16)).buffer),n.iv||(n.iv=crypto.getRandomValues(new Uint8Array(12)))),n}async finalizeMessage(e){e.ts||(e.ts=await We.dateNow()),H(!(!0===e.stringMessage),"[Channel.finalizeMessage()] stringMessage is true, finalizing should not be called (internal error)");const t=ve(e.unencryptedContents);H(t,"wrapMessage(): failed to assemble payload"),H(t.byteLength<65536,`[Channel.finalizeMessage]: body must be smaller than 64 KiB (we got ${t.byteLength/1024} KiB)})`),e.ts=await We.dateNow();const n=new DataView(new ArrayBuffer(8));return n.setFloat64(0,e.ts),H(e.protocol,"[Channel.finalizeMessage()] Protocol not set (internal error)"),e.c=await Fe.encrypt(t,await e.protocol.encryptionKey(e),{iv:e.iv,additionalData:n}),e.s=await Fe.sign(this.signKey,e.c),p(e)}#m(e){return new Promise((async(t,n)=>{await this.ready;const r=!0===e.stringMessage?e.unencryptedContents:await this.finalizeMessage(e);await this.callApi("/send",r).then((e=>{t(e)})).catch((e=>{n(e)}))}))}async send(e,t={}){return new Promise((async(n,r)=>{const a=this.packageMessage(e,t);this.sendQueue.enqueue({msg:a,resolve:n,reject:r,_send:this.#m.bind(this),retryCount:void 0!==t.retries?t.retries:0})}))}create(e,t=this.channelServer){return H(null!==e,"[Channel.create] Missing storage token"),t&&(this.channelServer=t),H(this.channelServer,"[Channel.create] Missing channel server (neither provided nor in channelKeys)"),new Promise((async(n,r)=>{await this.channelReady,this.channelData.storageToken=c(e),this.callApi("/budd",this.channelData).then((()=>{this.channelServer=t,H(this.channelData&&this.channelData.channelId&&this.userPrivateKey,"Internal Error [L2546]"),n(this)})).catch((e=>{r("Channel.create() failed: "+V(e))}))}))}getLastMessageTimes(){throw new x("Channel.getLastMessageTimes(): deprecated")}getLatestTimestamp(){return this.callApi("/getLatestTimestamp")}async messageQueueManager(){await this.ready;let e=!0;for(;e;)await this.sendQueue.dequeue().then((async t=>{if(t){let e=null;for(;t.retryCount-- >=0;)try{const e=await t._send(t.msg);t.resolve(e);break}catch(t){e="[ERROR] "+t}t.reject(e)}else e=!1})).catch((e=>{if("shutDown"!==e)throw new x("[messageQueueManager] Channel message queue is shutting down with error: "+e.message)}))}close(){return this.isClosed=!0,this.sendQueue.drain("shutDown")}getMessageKeys(e="0"){return new Promise((async(t,n)=>{try{await this.channelReady,H(this.channelId,"Channel.getMessageKeys: no channel ID (?)");const{keys:n,historyShard:r}=await this.callApi("/getMessageKeys",{prefix:e});n&&0!==n.size||console.warn("[Channel.getMessageKeys] Warning: no messages (empty/null response); not an error but perhaps unexpected?"),t({keys:n,historyShard:r})}catch(e){n(`[Channel.getMessageKeys] Error in getting message keys (offline?) ('${e}')`)}}))}getRawMessageMap(e){if(0===e.size)throw new x("[getRawMessageMap] no message keys provided");if(e.size>We.MAX_MESSAGE_REQUEST_SIZE)throw new x(`[getRawMessageMap] too many messages requested at once (max ${We.MAX_MESSAGE_REQUEST_SIZE}, ${e.size} requested)`);return new Promise((async(t,n)=>{await this.channelReady,H(this.channelId,"[getRawMessageMap] no channel ID (?)");const r=await this.callApi("/getMessages",e);H(r,"[getRawMessageMap] no messages (empty/null response)"),t(r)}))}getMessageMap(e){if(e.size>We.MAX_MESSAGE_REQUEST_SIZE)throw new x(`[getMessageMap] too many message keys provided (max ${We.MAX_MESSAGE_REQUEST_SIZE}, ${e.size} provided)`);if(0===e.size)throw new x("[getMessageMap] no message keys provided");return new Promise((async(t,n)=>{await this.channelReady;const r=await this.callApi("/getMessages",e),a=new Map;for(const[e,t]of r)try{a.set(e,g(be(t).payload))}catch(e){}t(await this.extractMessageMap(a))}))}async getHistory(){await this.channelReady,H(this.channelId,"Channel.getHistory: no channel ID (?)");const e=await this.callApi("/getHistory");return console.log(Le,"getHistory result:\n",JSON.stringify(e,null,2),Le),new M(e,this)}setPage(e){var{page:t,prefix:n,type:r}=e;if(H(t,"Channel.setPage: no page (contents) provided"),(n=n||12)<6)throw new x("Channel.setPage: prefix must be at least 6 characters");return r=r||"sb384payloadV3",this.callApi("/setPage",{page:t,type:r,prefix:n})}async getPage(){const e=this.hashB32,t=await $(this.channelServer+"/api/v2/page/"+e).catch((e=>{throw new x(`[Channel.getPage] fetch failed: ${e}`)}));if("sb384payloadV3"!==t.headers.get("content-type"))throw new x("[Channel.getPage] Can only handle 'sb384payloadV3' content type, use 'fetch()'");return be(await t.arrayBuffer()).payload}acceptVisitor(e){return this.callApi("/acceptVisitor",{userId:e})}getCapacity(){return this.callApi("/getCapacity")}getAdminData(){return this.callApi("/getAdminData")}getMother(){return this.getAdminData().then((e=>e.motherChannel))}isLocked(){return this.getAdminData().then((e=>e.locked))}lock(){return this.callApi("/lockChannel")}updateCapacity(e){return this.callApi("/setCapacity",{capacity:e})}getChannelKeys(){return this.callApi("/getChannelKeys")}getPubKeys(){return this.callApi("/getPubKeys")}getStorageLimit(){return this.callApi("/getStorageLimit")}async getStorageToken(e){return c(await this.callApi("/getStorageToken",{size:e}))}budd(e){return new Promise((async(t,n)=>{var{targetChannel:r,size:a}=e||{};if(r){if(this.channelId===r.channelId)return void n(new Error("[budd()]: source and target channels are the same, probably an error"))}else r=(await(new ze).ready).handle;if(a||(a=s),a!==1/0&&Math.abs(a)>await this.getStorageLimit())return void n(new Error(`[budd()]: storage amount (${a}) is more than current storage limit`));const i=r.channelData;if(i)try{i.storageToken=await this.getStorageToken(a);const e=await new ze(r).ready;e.channelServer||(e.channelServer=this.channelServer);const s=u(await e.callApi("/budd",i));if(r.channelId!==s.channelId)return console.warn("[budd()]: target channel ID changed, should not happen, error somewhere\n",Le),console.warn("targetChannel:",r,"\n",Le),console.warn("newChannelData:",s,"\n",Le),void n(new Error("[budd()]: target channel ID changed, should not happen, error somewhere"));s.storageToken||console.warn("[budd()]: target channel has no storage token, possibly an error, should be returned from server"),t(h({[De]:!0,channelId:s.channelId,userPrivateKey:r.userPrivateKey,channelServer:this.channelServer,channelData:s}))}catch(e){return void n("[budd] Could not get storage token from server, are you sure about the size?")}else n(new Error("[budd()]: target channel has no channel data, probably an error"))}))}static LOWEST_TIMESTAMP="0".repeat(26);static HIGHEST_TIMESTAMP="3".repeat(26);static timestampToBase4String(e){return e.toString(4).padStart(22,"0")+"0000"}static base4stringToDate(e){const t=parseInt(e.slice(0,-4),4);return new Date(t).toISOString()}static getLexicalExtremes(e){if(!(e instanceof Set||e instanceof Array||e instanceof Map))throw new x("[getLexicalExtremes] Paramater must be a Set, Array, or Map");const t=e instanceof Array?e:Array.from(e.keys());if(0===t.length)return[];let[n,r]=[t[0],t[0]];for(const e of t)e<n&&(n=e),e>r&&(r=e);return[n,r]}static messageKeySetToPrefix=e=>{if(0===e.size)return"0";const[t,n]=ze.getLexicalExtremes(e);H(t&&n,"[timestampLongestPrefix]: no lowest or highest (internal error?)");const{timestamp:r}=ze.deComposeMessageKey(t),{timestamp:a}=ze.deComposeMessageKey(n);let s=0;for(;s<r.length&&s<a.length&&r[s]===a[s];)s++;return r.substring(0,s)};static timestampLongestPrefix=(e,t)=>{if(e&&t&&"string"==typeof e&&"string"==typeof t&&26===e.length&&26===t.length){let n=0;for(;n<e.length&&n<t.length&&e[n]===t[n];)n++;return e.substring(0,n)}throw new x(`[timestampLongestPrefix]: invalid input:\n '${e}' or '${t}'`)};static timestampRegex=/^[0-3]{26}$/;static base4StringToTimestamp(e){return e&&"string"==typeof e&&26===e.length&&ze.timestampRegex.test(e)?parseInt(e.slice(0,-4),4):0}static base4StringToDate(e){const t=ze.base4StringToTimestamp(e);return t?new Date(t).toISOString():""}static deComposeMessageKey(e){const t=e.match(/^([a-zA-Z0-9]{43})_([_a-zA-Z0-9]{4})_([0-3]{26})$/);return t&&t.length>=4?{channelId:t[1],i2:t[2],timestamp:t[3]}:{channelId:"",i2:"",timestamp:""}}static composeMessageKey(e,t,n="____"){return`${e}_${n??"____"}_${ze.timestampToBase4String(t)}`}}a([Me,Ke],ze.prototype,"api",null),a([Ke],ze.prototype,"getLatestTimestamp",null),a([Ke,Re],ze.prototype,"setPage",null),a([Ke],ze.prototype,"getPage",null),a([Ke,Re],ze.prototype,"acceptVisitor",null),a([Ke,Re],ze.prototype,"getCapacity",null),a([Ke,Re],ze.prototype,"getAdminData",null),a([Ke,Re],ze.prototype,"getMother",null),a([Ke,Re],ze.prototype,"isLocked",null),a([Ke,Re],ze.prototype,"lock",null),a([Ke,Re],ze.prototype,"updateCapacity",null),a([Ke,Me],ze.prototype,"getChannelKeys",null),a([Ke],ze.prototype,"getPubKeys",null),a([Ke],ze.prototype,"getStorageLimit",null),a([Ke],ze.prototype,"getStorageToken",null),a([Ke,Re],ze.prototype,"budd",null);class He extends ze{channelSocketReady;static ReadyFlag=Symbol("ChannelSocketReadyFlag");#S;#b;onMessage=e=>{H(!1,"[ChannelSocket] NO MESSAGE HANDLER")};#k=new Map;#C=new Map;#E=!1;lastTimestampPrefix="0".repeat(26);#A=0;#I;#P;constructor(e,t,r){if(H(t,"[ChannelSocket] constructor: no onMessage handler provided"),"string"==typeof e)super(e,r);else{const t=h(e);super(t,r),t.channelServer&&(this.channelServer=t.channelServer)}this.channelServer||(this.channelServer=We.defaultChannelServer),this[n.ReadyFlag]=!1,this.#b=this.channelServer.replace(/^http/,"ws"),this.onMessage=t,this.channelSocketReady=this.#B()}#M(){if(this.#A=setInterval((()=>{if(this.isClosed)return console.error("[ChannelSocket] we are closed, removing ping interval"),void clearInterval(this.#A);We.haveNotHeardFromServer()}),500),this.#S&&this.#S.websocket&&1===this.#S.websocket.readyState)try{this.#S.websocket.send("ping")}catch(e){console.error("[ChannelSocket] Failed to send first (hibernation) 'ping' message, Internal Error [L3986]")}else console.error("[ChannelSocket] websocket not ready (?), not sending first 'ping', hibernation disabled")}async#K(){await new Promise((e=>setTimeout(e,50))),this.channelSocketReady=this.#B().catch((e=>(console.error(Le,"[ChannelSocket] Could not re-establish connection, should queue up\n",e,Le),this)))}async#R(e){console.warn(`[ChannelSocket] Lost connection to server, will try to reset.\nReason (if any): '${e}'`),this[n.ReadyFlag]=!1,We.removeChannelSocket(this),We.on("online",this.#K)}#B(){return this.#I=new Promise(((e,t)=>{this.#P=t})),Promise.race([this.#I,new Promise((async(e,t)=>{await this.sbChannelKeysReady;const r=this.#b+"/api/v2/channel/"+this.channelId+"/websocket";if(this.#S={url:r,ready:!1,closed:!1,timeout:2e4},!this.#S.websocket||3===this.#S.websocket.readyState||2===this.#S.websocket.readyState){this.#S.websocket&&(console.warn("[ChannelSocket] websocket is in a bad state, closing it ... will await"),await async function(e){console.log("[closeSocket] closing socket",e),e.readyState!==WebSocket.CLOSED?await new Promise((t=>{e.addEventListener("close",(()=>{console.log("[Snackabra.closeSocket] ... socket confirmed closed",e),t()}),{once:!0}),e.close(1e3)})):console.warn("[Snackabra] websocket already closed")}(this.#S.websocket),We.addChannelSocket(this));const e=ve(await this.buildApiBody(r));H(e,"Internal Error [L3598]");try{this.#S.websocket=new WebSocket(r+"?apiBody="+oe(e)),We.addChannelSocket(this)}catch(e){const t="[ChannelSocket] Could not open websocket: "+e;return void this.#P(t)}}const a=this.#S.websocket,s=async t=>{if(!t.data){const e="[ChannelSocket] received empty message (should be a 'ready' message)";console.error(e),this.#P(e)}let r=null;if("string"==typeof t.data?r=T(t.data,"L3909"):t.data instanceof ArrayBuffer?r=be(t.data).payload:t.data instanceof Blob?r=be(await t.data.arrayBuffer()).payload:z("L3987","[ChannelSocket] received something other than string or ArrayBuffer"),r)if(r.ready)r.latestTimestamp?this.lastTimestampPrefix=r.latestTimestamp:console.warn("[ChannelSocket] received 'ready' message without 'latestTimestamp'"),a.removeEventListener("message",s),a.addEventListener("message",this.#x),this.#M(),this[n.ReadyFlag]=!0,e(this);else{const e="[ChannelSocket] received something other than 'ready' as first message:\n"+JSON.stringify(t.data);!0===this[n.ReadyFlag]?console.warn(e):this.#P(e)}else{const e="[ChannelSocket] received empty message, or could not parse it (should be a 'ready' message)";!0===this[n.ReadyFlag]?console.warn(e):this.#P(e)}};this.#S.websocket.addEventListener("message",s);let i=setTimeout((()=>{if(this[n.ReadyFlag]);else{const e="[ChannelSocket] Socket not resolving after waiting, fatal.";console.warn(e),this.#P(e)}}),2e3);this.#S.websocket.addEventListener("open",(async()=>{this.#S.closed=!1,i&&(clearTimeout(i),i=void 0),await this.ready,this.#S.websocket.send("ready")})),this.#S.websocket.addEventListener("close",(e=>{if(this.#S.closed=!0,e.wasClean)if(e.reason.includes("does not have an owner")){const e=`[ChannelSocket] No such channel on this server (${this.channelServer})`;if(!0===this[n.ReadyFlag])throw new x(e+" plus we are ready? (L4130)");this.#P(e)}else console.log(`[ChannelSocket] Closed (cleanly).\nReason (if any): '${e.reason}'.`);else console.warn(`[ChannelSocket] Closed (but not cleanly) [L4137]\nReason (if any): '${e.reason}'. Server: '${this.channelServer}'`);if(!0===this[n.ReadyFlag])this.#R("Channel was ready, but reporting being closed [L4140]");else{const e="[ChannelSocket] Closed before ready (?) [L4142]";console.error(e),this.#P(e)}})),this.#S.websocket.addEventListener("error",(e=>{if(this.#S.closed=!0,!0===this[n.ReadyFlag]){const t="[ChannelSocket] Socket closed [L4152]\nEvent message (if any): '"+e.message+"'";console.error(t),this.#P(t)}else{const t=`[ChannelSocket] Failed to connect, or errored out immediately [L4153].\nError (if any): '${e}'`;console.error(t),this.#P(t)}}))}))])}#x=async e=>{H(!this.errorState,"[ChannelSocket] in error state (Internal Error L4018)");const t=e.data;var r=null;if(H(t,"[ChannelSocket] received empty message"),We.heardFromServer(),"string"==typeof t&&ze.timestampRegex.test(t))return We.heardFromServer(),t>this.lastTimestampPrefix&&this.#S.websocket.send(this.lastTimestampPrefix),void setTimeout((()=>{if(this.#S&&!this.#S.closed&&1===this.#S.websocket?.readyState)try{this.#S.websocket.send("ping")}catch(e){}}),1e3);if("string"==typeof t){const e=_(t);if(e)return void this.#S.websocket.send(ve({error:`Cannot parse 'string' message (''${e})`}));z("L3287","[ChannelSocket] Cannot parse message: "+t)}else if(t instanceof ArrayBuffer)r=be(t).payload;else{if(!(t instanceof Blob))return void this.#S.websocket.send(ve({error:"Received unknown 'type' of message (??)"}));r=be(await t.arrayBuffer()).payload}if(H(r,"[ChannelSocket] cannot extract message"),r.ready)return;if(r.error)return void console.error("++++++++ #processMessage: received error message\n",r);(r=g(r)).channelId||(r.channelId=this.channelId),H(r.channelId===this.channelId,"[ChannelSocket] received message for wrong channel?"),this.#E&&console.log("[ChannelSocket] Received socket message:",r),H(r.sts,"[ChannelSocket] Message missing server timestamp Internal Error (L4145)"),this.lastTimestampPrefix=n.timestampToBase4String(r.sts),H(r.c&&r.c instanceof ArrayBuffer,"[ChannelSocket] Internal Error (L3675)");const a=Z(await crypto.subtle.digest("SHA-256",r.c));this.previous&&(r.p=this.previous),this.previous=a;const s=this.#k.get(a);s&&(this.#E&&console.log(`++++++++ #processMessage: found matching ack for id ${a}`),this.#k.delete(a),s("success"));const i=this.#C.get(a);i&&(this.#E&&console.log(`++++++++ #processMessage: clearing matching ack timeout for id ${a}`),clearTimeout(i),this.#C.delete(a));const o=await this.extractMessage(r);o&&this.onMessage(o)};get ready(){return H(!this.errorState,"[ChannelSocket] in error state (Internal Error L4104)"),H(!this.isClosed,"[ChannelSocket] We are closed, blocking on'ready' will reject"),this.channelSocketReady}get errorPromise(){if(!this.#I)throw new x("[ChannelSocket] errorPromise called before ready");return this.#I}get ChannelSocketReadyFlag(){return this[n.ReadyFlag]}get status(){if(!this.#S||!this.#S.websocket)return"CLOSED";switch(this.#S.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set enableTrace(e){this.#E=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}#m(e){return H(!this.errorState,"[ChannelSocket] in error state (Internal Error L4130)"),new Promise((async(t,n)=>{if(this.#S.closed)n("<websocket closed>");else if(!0===e.stringMessage)try{const n=e.unencryptedContents;this.#S.websocket.send(n),t("success")}catch(e){return void n(`<websocket error upon send() of a string message: ${e}>`)}else{const r=ve(e=await this.finalizeMessage(e));if(!r)return void n("ChannelSocket.send(): no message payload (Internal Error)");const a=Z(await crypto.subtle.digest("SHA-256",e.c));this.#E&&console.log("++++++++ ChannelSocket.send(): Which has hash:",a),this.#k.set(a,t),this.#C.set(a,setTimeout((async()=>{if(this.#k.has(a))return this.#k.delete(a),We.isShutdown?void n("shutDown"):void n(`<websocket request timed out (no ack) after ${this.#S.timeout}ms (${a})>`);this.#E&&console.log("++++++++ ChannelSocket.send() completed sending"),t("<received ACK, success, message sent and mirrored back>")}),this.#S.timeout));try{this.#S.websocket.send(r)}catch(e){return console.error("Failed to send on socket:\n",e,"\n",(new Error).stack),void n(`<websocket error upon send() of a message: ${e}>`)}}}))}async send(e,t){return await this.ready,H(this.#S&&this.#S.websocket,"[ChannelSocket.send()] called before ready"),this.#S.closed&&(console.info("send() triggered reset of #readyPromise() (normal)"),this.channelSocketReady=this.#B(),this[n.ReadyFlag]=!1),new Promise((async(n,r)=>{this.ChannelSocketReadyFlag||r("ChannelSocket.send() is NOT ready, perhaps it's resetting?");const a=this.#S.websocket.readyState;switch(a){case 1:this.sendQueue.enqueue({msg:this.packageMessage(e,t),resolve:n,reject:r,_send:this.#m.bind(this),retryCount:3});break;case 0:case 2:case 3:r("[ChannelSocket.send()] Tried sending but socket not OPEN - it is "+(0===a?"CONNECTING":2===a?"CLOSING":"CLOSED"));break;default:z("ChannelSocket",`socket in unknown state (${a})`)}}))}async close(){this.isClosed=!0,clearInterval(this.#A),this.#S&&this.#S.websocket&&(1===this.#S.websocket.readyState&&(this.#S.websocket.close(),await new Promise((e=>setTimeout(e,200)))),this.#S.closed=!0);const e=super.close();return We.removeChannelSocket(this),this[n.ReadyFlag]=!1,e}reset(){this.#S&&this.#S.websocket&&(1===this.#S.websocket.readyState&&this.#S.websocket.close(),this.#S.closed=!0,this[n.ReadyFlag]=!1,We.removeChannelSocket(this),this.channelSocketReady=this.#B())}}n=He;class Ge{#T;#D="";static#_=0;constructor(e){e&&(this.#T=e,this.#N().then((e=>{if(!e){const e=setInterval((async()=>{if(We.isShutdown)clearInterval(e);else{await this.#N()&&clearInterval(e)}}),1e3)}})))}async#N(){if(this.#D)return this.#D;if(this.#T){const e=await We.getServerInfo(this.#T);if(!e)return"";if(e&&!e.storageServer)throw new x("[StorageApi] Server available did not provide storage server name, cannot initialize. Should not happen [L4651]");this.#D=e.storageServer}return this.#D}async getStorageServer(){const e=await this.#N();if(e)return e;throw new x("[StorageApi] Identity of storage server is not (yet) known.")}static padBuf(e){const t=e.byteLength;let n;const r=1048576;n=t+4<4096?4096:t+4<r?2**Math.ceil(Math.log2(t+4)):Math.ceil((t+4)/r)*r;let a=G([e,new Uint8Array(n-t).buffer]);return new DataView(a).setUint32(n-4,t),a}#F(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(n=r),e.slice(0,n)}static getObjectKey(e,t){return new Promise(((n,r)=>{try{Fe.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}static async getObjectId(e,t,n){return oe(await crypto.subtle.digest("SHA-256",G([e,t,n])))}static async paceUploads(){for(;r.#_>8;)await new Promise((e=>setTimeout(e,50)))}async storeData(e,t){r.#_++;try{const n=ve(e);if(!n)throw new x("[storeData] failed to assemble payload");const a=oe(await crypto.subtle.digest("SHA-256",n)).slice(0,12),s=r.padBuf(n),i=await Fe.generateIdKey(s),h=await this.getStorageServer(),d=h+"/api/v2/storeRequest?id="+oe(i.idBinary),u=await U(d);if(!u.salt||!u.iv)throw new x("[storeData] Failed to get key info (salt, nonce) from storage server");const f=await r.getObjectKey(i.keyMaterial,u.salt),y=await Fe.encrypt(s,f,{iv:u.iv});let g;if(t instanceof ze)g=await t.getStorageToken(y.byteLength);else if(l(t))g=await(await new ze(t).ready).getStorageToken(y.byteLength);else{if(!o(t))throw new x("[storeData] invalid budget source (needs to be a channel, channel handle, or storage token)");g=c(t)}const p=await r.getObjectId(u.iv,u.salt,y),w=h+"/api/v2/storeData?id="+p,v={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:ve({id:p,iv:u.iv,salt:u.salt,storageToken:g,data:y})},m=await U(w,v);return{[_e]:!0,version:S,id:p,key:oe(i.keyMaterial),iv:u.iv,salt:u.salt,hash:a,verification:m.verification,storageServer:h}}catch(e){if(console.error("[storeData] failed:",e),e instanceof x)throw e.message.includes("Not enough storage budget")?new x("Not enough storage budget"):e;throw new x(`[storeData] failed to store data: ${e}`)}finally{r.#_--}}async#L(e,t,n){try{let a=function(e){if(e){if("3"===e.version&&"string"==typeof e.id&&43===e.id.length&&Y.test(e.id)&&e.iv instanceof Uint8Array&&12===e.iv.byteLength&&e.salt instanceof ArrayBuffer&&16===e.salt.byteLength&&e.data instanceof ArrayBuffer&&e.actualSize===e.data.byteLength)return e;throw new x("invalid Shard")}throw new x("invalid SBObjectHandle (null or undefined)")}(await U(e+t,{method:"GET"}));H(n.key,"object handle 'key' is missing, cannot decrypt"),n.iv=a.iv,n.salt=a.salt,n.data=new WeakRef(a.data);const s=ce(n.key),i=await r.getObjectKey(s,n.salt),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:n.iv},i,a.data),c=this.#F(o),l=oe(await crypto.subtle.digest("SHA-256",c)).slice(0,12);return n.hash&&n.hash!==l&&console.error("[fetchData] Hash mismatch in object, internal error (L4730) but ignored"),n.payload=be(c).payload,n.data=new WeakRef(a.data),{hash:l,handle:n}}catch(e){return}}async fetchData(e){if(!e)throw new x("[fetchData] No handle provided (cannot accept null or undefined)");const t=k(e);We.shardBreakpoints.has(t.id);const n=await t.verification,r=t.storageServer?t.storageServer:null,a=await this.getStorageServer();for(const e of[r,"http://localhost:3841",a]){if(!e)continue;const r="/api/v2/fetchData?id="+t.id+"&verification="+n,a=await this.#L(e,r,t);if(a){const{hash:t,handle:n}=a;return n.storageServer=e,We.knownShards.set(t,n),n}}throw new x("[fetchData] failed to fetch from any server")}static getData(e){if(void 0===e)return;const t=k(e);if(t.data){if(t.data instanceof WeakRef){return t.data.deref()||void 0}if(t.data instanceof ArrayBuffer)return t.data;throw new x("Invalid data type in handle")}}async fetchPayload(e){if(!e)throw new x("[fetchPayload] No handle provided (cannot accept null or undefined)");if(e.payload||e.data||(e=await this.fetchData(e)),e.payload)return e.payload;if(e.data)return r.getData(e);throw new x("[fetchPayload] Failed to fetch data or payload")}}r=Ge;class qe{static listeners={};static addEventListener(e,t,n){qe.listeners[e]=qe.listeners[e]||[],qe.listeners[e].push(t)}static removeEventListener(e,t,n){if(!qe.listeners[e])return;const r=qe.listeners[e],a=r.indexOf(t);a>-1&&r.splice(a,1)}static dispatchEvent(e){const t=qe.listeners[e.type];return!t||(t.forEach((t=>t(e))),!e.defaultPrevented)}static on(e,t){qe.addEventListener(e,t)}static off(e,t){qe.removeEventListener(e,t)}static emit(e,...t){const n=new CustomEvent(e,{detail:1===t.length?t[0]:t});qe.dispatchEvent(n)}}class We extends qe{static version="3.20240605.6";static MAX_MESSAGE_REQUEST_SIZE=128;static MAX_MESSAGE_SET_SIZE=B.MAX_MESSAGE_SET_SIZE;static knownShards=new Map;#O;#j;static lastTimeStamp=0;static activeFetches=new Map;static#$=new Set;static isShutdown=!1;static lastTimestampPrefix="0".repeat(26);static#U=Date.now();static onlineStatus="unknown";static defaultChannelServer="https://c3.384.dev";eventTarget=new qe;static shardBreakpoints=new Set;constructor(e,t){super(),H("string"==typeof e,"[Snackabra] Takes channel server URL as parameter"),e&&(We.defaultChannelServer=e),console.warn(`==== CREATING Snackabra object generation: ${We.version} (${We.defaultChannelServer}) ====`),"boolean"==typeof t&&(t={DEBUG:t}),t&&t.sbFetch&&(console.log("++++ Snackabra constructor: setting custom fetch function ++++"),$=t.sbFetch),this.#O=e,this.#j=new Ge(e)}static async dateNow(){let e=Date.now();return e<=We.lastTimeStamp&&(e=We.lastTimeStamp+1),We.lastTimeStamp=e,e}static heardFromServer(){switch(We.#U=Date.now(),We.onlineStatus){case"offline":this.emit("online"),this.emit("reconnected"),We.onlineStatus="online";break;case"online":break;case"unknown":this.emit("online"),We.onlineStatus="online"}this.checkUnknownNetworkStatus()}static checkUnknownNetworkStatus(){0===We.#$.size&&("unknown"!==We.onlineStatus&&this.emit("unknownNetworkStatus"),We.onlineStatus="unknown")}static haveNotHeardFromServer(){Date.now()-We.#U>1500&&"online"===We.onlineStatus&&(We.#$.size>0?(We.onlineStatus="offline",this.emit("offline")):(We.onlineStatus="unknown",We.onlineStatus="offline",this.emit("unknownNetworkStatus"))),this.checkUnknownNetworkStatus()}static addChannelSocket(e){We.#$.add(e)}static removeChannelSocket(e){We.#$.has(e)&&We.#$.delete(e),this.checkUnknownNetworkStatus()}async getPage(e){const t=await j(this.#O+"/api/v2/page/"+e);if(t.ok){const n=t.headers.get("content-type");if(!n)throw new x(`[getPage] Failed to fetch page '${e}'`);let r;if(n.includes("application/json"))r=await t.json();else if(n.includes("text/")||n.includes("xml")||n.includes("html"))r=await t.text();else{if(n.includes("multipart/form-data"))throw new x("[getPage] Multipart form data not supported");r=n.match(/(image|audio|video)\//)?await t.blob():await t.arrayBuffer()}return{type:n,payload:r}}throw new x(`[getPage] Failed to fetch page '${e}'`)}create(e){return H(null!==e,"[create channel] Invalid parameter (null)"),new Promise((async(t,n)=>{try{var r;if(e instanceof ze){const t=e;await t.ready,t.channelServer||(t.channelServer=this.#O),r=await t.getStorageToken(s)}else try{r=c(e)}catch(e){return void n("Invalid parameter to create() - need a token or a budget channel")}H(r,"[create channel] Failed to get storage token for the provided channel");const a=await(new ze).ready;a.channelServer=this.#O,a.create(r).then((e=>{t(e.handle)})).catch((e=>{n(e)}))}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),n(t)}}))}connect(e,t){let n;if("string"==typeof e)n={userPrivateKey:e};else if(n=e,!l(n))throw new x("[Snackabra.connect] Invalid parameter (not a channel handle)");if(H(void 0!==n&&n&&n.userPrivateKey,"[Snackabra.connect] Invalid parameter (at least need owner private key)"),n.channelServer&&n.channelServer!==this.#O)throw new x(`[Snackabra.connect] channel server in handle ('${n.channelServer}') does not match what SB was set up with ('${this.#O}')`);return n.channelServer||(n.channelServer=this.#O),t?new He(n,t):new ze(n)}static async closeAll(){console.log(Le,"==== Snackabra.closeAll() called ====",Le),We.isShutdown?console.warn("closeAll() called, but it was already shutting down"):(We.isShutdown=!0,We.activeFetches.forEach((e=>e.abort("Snackabra.closeAll() called"))),We.activeFetches.clear(),console.log("[Snackabra] [closeAll] closing all active channel sockets:",We.#$),await Promise.all(Array.from(We.#$).map(close)),console.log("[Snackabra] [closeAll] ... waiting for everything to close ..."),await new Promise((e=>setTimeout(e,200))))}static async getServerInfo(e=We.defaultChannelServer){try{const t=await U(e+"/api/v2/info");return t&&t.maxMessageRequestSize&&(We.MAX_MESSAGE_REQUEST_SIZE=t.maxMessageRequestSize),t}catch(e){return}}static traceShard(e){We.shardBreakpoints.add(e)}get storage(){return this.#j}async getStorageServer(){return this.storage.getStorageServer()}get crypto(){return Fe}get version(){return We.version}}return a([Me],We.prototype,"storage",null),a([Me],We.prototype,"getStorageServer",null),console.warn(`==== SNACKABRA jslib (re)loaded, version '${We.version}' ====`),t})()));