!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>he,ChannelEndpoint:()=>ue,ChannelSocket:()=>de,MessageBus:()=>a,SB:()=>be,SB384:()=>ce,SBCrypto:()=>Q,SBMessage:()=>le,SBObjectHandle:()=>pe,Snackabra:()=>we,arrayBuffer32ToBase62:()=>T,arrayBufferToBase64:()=>P,assemblePayload:()=>z,base62ToArrayBuffer32:()=>M,base62ToBase64:()=>D,base64ToArrayBuffer:()=>E,base64ToBase62:()=>I,cleanBase32mi:()=>F,compareBuffers:()=>R,decodeB64Url:()=>Z,encodeB64Url:()=>q,encryptedContentsMakeBinary:()=>d,extractPayload:()=>W,extractPayloadV1:()=>V,getRandomValues:()=>u,isBase62Encoded:()=>N,jsonParseWrapper:()=>G,partition:()=>J,sbCrypto:()=>ae,simpleRand256:()=>L,simpleRandomString:()=>H,version:()=>r});var n=function(e,t,n,r){var s,o=arguments.length,a=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(a=(o<3?s(a):o>3?s(t,n,a):s(t,n))||a);return o>3&&a&&Object.defineProperty(t,n,a),a};const r="1.2.0 (pre) build 02";var s=!1,o=!1;class a{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function i(e,t){return t?fetch(e,t):fetch(e,{method:"GET"})}function c(e){return e instanceof Error?e:new Error(String(e))}function l(e,t){throw new Error("<< SB lib error ("+e+": "+t+") >>")}function h(e,t){if(!e)throw new Error(`<< SB assertion error: ${t} >>`)}async function y(e){const t=new ce(e);await t.ready;const n=t.exportable_pubKey,r=t.exportable_privateKey,s=t.hash,o=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=await crypto.subtle.exportKey("jwk",o),i=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]),c=await crypto.subtle.exportKey("jwk",i.privateKey);return{channelData:{roomId:s,ownerKey:JSON.stringify(n),encryptionKey:JSON.stringify(a),signKey:JSON.stringify(c)},exportable_privateKey:r}}function d(e){try{let t,n;if(o&&(console.log("=+=+=+=+ processing content"),console.log(e.content.constructor.name)),"string"==typeof e.content)try{t=E(decodeURIComponent(e.content))}catch(e){throw new Error("EncryptedContents is string format but not base64 (?)")}else{const n=e.content.constructor.name;h("ArrayBuffer"===n||"Uint8Array"===n,"undetermined content type in EncryptedContents object"),t=e.content}if(o&&console.log("=+=+=+=+ processing nonce"),"string"==typeof e.iv)o&&(console.log("got iv as string:"),console.log(structuredClone(e.iv))),n=E(decodeURIComponent(e.iv)),o&&(console.log("this was turned into array:"),console.log(structuredClone(n)));else if("Uint8Array"===e.iv.constructor.name||"ArrayBuffer"===e.iv.constructor.name)o&&console.log("it's an array already"),n=new Uint8Array(e.iv);else{o&&console.log("probably a dictionary");try{n=new Uint8Array(Object.values(e.iv))}catch(t){s&&(console.error("ERROR: cannot figure out format of iv (nonce), here's the input object:"),console.error(e.iv)),h(!1,"undetermined iv (nonce) type, see console")}}return o&&(console.log("decided on nonce as:"),console.log(n)),h(12==n.length,`unwrap(): nonce should be 12 bytes but is not (${n.length})`),{content:t,iv:n}}catch(e){throw console.error("encryptedContentsMakeBinary() failed:"),console.error(e),console.trace(),console.log(e.stack),e}}function u(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{h(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}const g=/([A-Za-z0-9+/_\-=]{64})([01]{42})/,p=/^([A-Za-z0-9+/_\-=]*)$/;function f(e){const t=p.exec(e);return!!t&&t[0]===e}function w(e){const t=p.exec(e);return h(t&&t[0]===e,"ensureSafe() tripped: something is not URI safe"),e}const b=[],m=[],v=[],k="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",S=k+"+/",K=k+"-_",A="=",C=16383;for(let e=0,t=S.length;e<t;++e)b[e]=S[e],m[e]=K[e],v[S.charCodeAt(e)]=e;function E(e){if(!f(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,r]=function(e){const t=e.length;let n=e.indexOf(A);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),s=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,r));let o=0;const a=r>0?n-4:n;let i;for(i=0;i<a;i+=4)t=v[e.charCodeAt(i)]<<18|v[e.charCodeAt(i+1)]<<12|v[e.charCodeAt(i+2)]<<6|v[e.charCodeAt(i+3)],s[o++]=t>>16&255,s[o++]=t>>8&255,s[o++]=255&t;return 2===r&&(t=v[e.charCodeAt(i)]<<2|v[e.charCodeAt(i+1)]>>4,s[o++]=255&t),1===r&&(t=v[e.charCodeAt(i)]<<10|v[e.charCodeAt(i+1)]<<4|v[e.charCodeAt(i+2)]>>2,s[o++]=t>>8&255,s[o++]=255&t),s}function x(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function O(e,t,n,r){let s;const o=new Array((r-n)/3);for(let a=n,i=0;a<r;a+=3,i++)s=(t.getUint8(a)<<16&16711680)+(t.getUint8(a+1)<<8&65280)+(255&t.getUint8(a+2)),o[i]=x(e,s);return o.join("")}v["-".charCodeAt(0)]=62,v["_".charCodeAt(0)]=63;const B=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function R(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=B(e),r=B(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function P(e,t="url"){if(null==e)return l("L509","arrayBufferToBase64() -> null paramater"),"";{const n=B(e),r=n.byteLength,s=r%3,o=r-s,a=new Array(Math.floor(o/C)+Math.sign(s)),i="url"==t?m:b,c="";let l=0;for(let e=0;e<o;e+=C)a[l++]=O(i,n,e,e+C>o?o:e+C);if(1===s){const e=n.getUint8(r-1);a[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===s){const e=(n.getUint8(r-2)<<8)+n.getUint8(r-1);a[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return a.join("")}}const _="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",j=/^(a32\.)?[0-9A-Za-z]{43}$/;function M(e){if(!j.test(e))throw new Error(`base62ToArrayBuffer32: string must match: ${j}`);e=e.slice(4);let t=BigInt(0);for(let n=0;n<e.length;n++)t=62n*t+BigInt(_.indexOf(e[n]));if(t>2n**256n-1n)throw new Error("base62ToArrayBuffer32: value exceeds 256 bits.");const n=new ArrayBuffer(32),r=new DataView(n);for(let e=0;e<8;e++,t>>=32n)r.setUint32(4*(8-e-1),Number(BigInt.asUintN(32,t)));return n}function T(e){if(32!==e.byteLength)throw new Error("arrayBuffer32ToBase62: buffer must be exactly 32 bytes (256 bits).");let t="";for(let n=BigInt("0x"+Array.from(new Uint8Array(e)).map((e=>e.toString(16).padStart(2,"0"))).join(""));n>0n;n/=62n)t=_[Number(n%62n)]+t;return"a32."+t.padStart(43,"0")}function D(e){return P(M(e))}function I(e){return T(E(e))}function N(e){return j.test(e)}function U(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function L(){return crypto.getRandomValues(new Uint8Array(1))[0]}const $="0123456789abcdefyhEjkLmNHpFrRTUW";function H(e,t){if("base32mi"==t){const t=crypto.getRandomValues(new Uint8Array(e));let n="";for(let r=0;r<e;r++)n+=$[31&t[r]];return n}return l("simpleRandomString","code "+t+" not supported"),""}function F(e){return e.replace(/[OoQD]/g,"0").replace(/[lIiJ]/g,"1").replace(/[Zz]/g,"2").replace(/[A]/g,"4").replace(/[Ss]/g,"5").replace(/[G]/g,"6").replace(/[t]/g,"7").replace(/[B]/g,"8").replace(/[gq]/g,"9").replace(/[C]/g,"c").replace(/[Y]/g,"y").replace(/[KxX]/g,"k").replace(/[M]/g,"m").replace(/[n]/g,"N").replace(/[P]/g,"p").replace(/[uvV]/g,"U").replace(/[w]/g,"w")}function J(e,t){throw`partition() not tested on TS yet - (${e}, ${t})`}function G(e,t){if(null==e)return null;try{return JSON.parse(e)}catch(n){try{let t="",n="",r=e;for(;r!=(n=t,t=r,r=r?.match(/^(['"])(.*)\1$/m)?.[2]);)return JSON.parse(`'${n}'`)}catch{try{return JSON.parse(e.slice(1,-1))}catch{throw new Error(`JSON.parse() error at ${t} (tried eval and slice)\nString was: ${e}`)}}}}function V(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=G((new TextDecoder).decode(e.slice(4,4+t)),"L476");let r=4+t;const s={};for(const t in n)s.key&&(s[t]=e.slice(r,r+n[t]),r+=n[t]);return s}catch(e){return console.error(e),{}}}function z(e){try{const t={version:"002"};let n=0,r=0;for(const s in e)n++,t[n.toString()]={name:s,start:r,size:e[s].byteLength},r+=e[s].byteLength;const s=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([s.byteLength]);let a=U(new Uint8Array(o.buffer),new Uint8Array(s));for(const t in e)a=U(new Uint8Array(a),e[t]);return a}catch(e){return console.error(e),null}}function W(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=G((new TextDecoder).decode(e.slice(4,4+t)),"L533"),r=4+t;switch(n.version||(n.version="001"),n.version){case"001":return V(e);case"002":{const t=[];for(let s=1;s<Object.keys(n).length;s++){const o=s.toString();if(n[o]){const s=n[o].start,a=n[o].size;t[n[o].name]=e.slice(r+s,r+s+a)}else console.log(`found nothing for index ${s}`)}return t}default:throw new Error("Unsupported payload version ("+n.version+") - fatal")}}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function q(e){return e.replaceAll("+","-").replaceAll("/","_")}function Z(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;if(t){if(1===t)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");e+=new Array(5-t).join("=")}return e}var X;function Y(e){return e&&Object.values(X).includes(e.prefix)}!function(e){e.SBAES256Key="T881",e.SBPrivateKey="Aj3p",e.SBPublicKey="pNkk"}(X||(X={}));class Q{#t=new Map;SBKeyToJWK(e){if(!Y(e))return e;switch(e.prefix){case"pNkk":return{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:e.x,y:e.y};case"Aj3p":return{crv:"P-384",d:e.d,ext:!0,key_ops:["deriveKey"],kty:"EC",x:e.x,y:e.y};case"T881":return{k:e.k,alg:"A256GCM",key_ops:["encrypt","decrypt"],kty:"oct"};default:throw new Error(`SBKeyToJWK() - unknown key prefix: ${e.prefix}`)}}JWKToSBKey(e){if(e){if("oct"===e.kty&&"A256GCM"===e.alg&&e.k&&43===e.k.length)return{prefix:X.SBAES256Key,k:I(e.k)};if("EC"===e.kty&&"P-384"===e.crv&&e.x&&e.y){if(64!==e.x.length||64!==e.y.length)return;return e.d&&64===e.d.length?{prefix:X.SBPrivateKey,x:e.x,y:e.y,d:e.d}:{prefix:X.SBPublicKey,x:e.x,y:e.y}}}}SBKeyToString(e){const t=e.prefix;switch(t){case X.SBAES256Key:return t+T(E(e.k)).slice(4);case X.SBPublicKey:{const n=e,r=new Uint8Array(96);return r.set(E(n.x),0),r.set(E(n.y),48),t+T(r.slice(0,32).buffer).slice(4)+T(r.slice(32,64).buffer).slice(4)+T(r.slice(64,96).buffer).slice(4)}case X.SBPrivateKey:{const n=e,r=new Uint8Array(160);return r.set(E(n.x).slice(4),0),r.set(E(n.y).slice(4),48),r.set(E(n.d).slice(4),96),t+T(r.slice(0,32).buffer).slice(4)+T(r.slice(32,64).buffer).slice(4)+T(r.slice(64,96).buffer).slice(4)+T(r.slice(96,128).buffer).slice(4)+T(r.slice(128,160).buffer).slice(4)}default:throw new Error("Unknown SBKey type.")}}StringToSBKey(e){try{if(e.length<4)return;const t=e.slice(0,4),n=e.slice(4);switch(t){case X.SBAES256Key:{if(43!==n.length)return;const e=M("a32."+n);return{prefix:X.SBAES256Key,k:P(e)}}case X.SBPublicKey:{if(86!==n.length)return;const e=new Uint8Array(M("a32."+n.slice(0,43))),t=new Uint8Array(M("a32."+n.slice(43,86))),r=new Uint8Array(M("a32."+n.slice(86))),s=new Uint8Array(96);return s.set(e,0),s.set(t,32),s.set(r,64),{prefix:X.SBPublicKey,x:P(s.slice(0,48).buffer),y:P(s.slice(48,96).buffer)}}case X.SBPrivateKey:{if(215!==n.length)return;const e=new Uint8Array(M("a32."+n.slice(0,43))),t=new Uint8Array(M("a32."+n.slice(43,86))),r=new Uint8Array(M("a32."+n.slice(86,129))),s=new Uint8Array(M("a32."+n.slice(129,172))),o=new Uint8Array(M("a32."+n.slice(172,215))),a=new Uint8Array(160);return a.set(e,0),a.set(t,32),a.set(r,64),a.set(s,96),a.set(o,128),{prefix:X.SBPrivateKey,x:P(a.slice(0,48).buffer),y:P(a.slice(48,96).buffer),d:P(a.slice(96,144).buffer)}}default:return}}catch(e){return void console.error("StringToSBKey() - malformed input, exception: ",e)}}async addKnownKey(e){if(e)if(Y(e)&&(e=await this.SBKeyToJWK(e)),"string"==typeof e){const t=await ae.sb384Hash(e);if(!t)return;if(this.#t.has(t))s&&console.log(`addKnownKey() - key already known: ${t}, skipping upgrade check`);else{const n={hash:t,pubKeyJson:e,key:await ae.importKey("jwk",e,"ECDH",!0,["deriveKey"])};this.#t.set(t,n)}}else if(e instanceof ce){await e.ready;const t=e.hash,n={hash:t,pubKeyJson:e.exportable_pubKey,key:e.privateKey};this.#t.set(t,n)}else{if(!(e instanceof CryptoKey))throw new Error("addKnownKey() - invalid key type (must be string or SB384-derived)");{const t=await this.sb384Hash(e);if(!t)return;if(!this.#t.has(t)){const n={hash:t,pubKeyJson:await ae.exportKey("jwk",e),key:e};this.#t.set(t,n)}}}}lookupKeyGlobal(e){return this.#t.get(e)}generateIdKey(e){return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({id:P(n),key:P(r)})}))}catch(e){n(e)}}))}extractPubKey(e){try{const t={...e};return delete t.d,delete t.dp,delete t.dq,delete t.q,delete t.qi,t.key_ops=[],t}catch(e){return console.error(e),null}}async#n(e){try{const t=160,n=/^[0-9A-Za-z]+$/;let r=0,s=P(e);for(;!n.test(s);){if(r++>t)throw new Error(`generateChannelHash() - exceeded ${t} iterations:`);s=P(e=await crypto.subtle.digest("SHA-384",e))}return P(e)}catch(t){throw console.error("sb384Hash() failed",t),console.error("tried working from channelBytes:"),console.error(e),new Error(`sb384Hash() exception (${t})`)}}async#r(e,t){let n=0,r=P(e);for(;r!==t;){if(n++>160)return!1;r=P(e=await crypto.subtle.digest("SHA-384",e))}return!0}async sb384Hash(e){if(e instanceof CryptoKey&&(e=await this.exportKey("jwk",e).catch((()=>{}))),e){if(e&&e.x&&e.y){const t=U(E(Z(e.x)),E(Z(e.y)));return await this.#n(t)}throw new Error("sb384Hash() - invalid JsonWebKey (missing x and/or y)")}}async compareHashWithKey(e,t){if(!e||!t)return!1;let n=t.x,r=t.y;if(!n||!r)try{const e=JSON.parse(t);e.x&&(n=e.x),e.y&&(r=e.y)}catch{return!1}const s=U(E(Z(n)),E(Z(r)));return await this.#r(s,e)}async verifyChannelId(e,t){return await this.compareHashWithKey(t,e)}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new Error("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,s){try{let o;const a={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new Error("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),o=await crypto.subtle.importKey("jwk",e,a[n],r,s)}else o=await crypto.subtle.importKey(e,t,a[n],r,s);return this.addKnownKey(o),o}catch(o){throw console.error(`... importKey() error: ${o}:`),console.log(e),console.log(t),console.log(n),console.log(r),console.log(s),new Error("importKey() exception ("+o+")")}}async exportKey(e,t){return await crypto.subtle.exportKey(e,t).catch((()=>{s&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}deriveKey(e,t,n,r,s){return new Promise((async(o,a)=>{const i={AES:{name:"AES-GCM",length:256},HMAC:{name:"HMAC",hash:"SHA-256",length:256}};try{o(await crypto.subtle.deriveKey({name:"ECDH",public:t},e,i[n],r,s))}catch(o){console.error(o,e,t,n,r,s),a(o)}}))}encrypt(e,t,n,r="encryptedContents"){return new Promise((async(s,o)=>{try{null===e&&o(new Error("no contents"));const a=n&&null!==n?n:crypto.getRandomValues(new Uint8Array(12));"string"==typeof e&&(e=(new TextEncoder).encode(e));const i=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},t,e);s("encryptedContents"===r?{content:w(P(i)),iv:w(P(a))}:i)}catch(e){o(e)}}))}wrap(e,t,n){return new Promise((r=>{let s;s="string"===n?ae.str2ab(t):t,ae.encrypt(s,e).then((e=>{r(e)}))}))}unwrap(e,t,n){return new Promise((async(r,s)=>{try{const{content:s,iv:o}=d(t),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},e,s);"string"===n?r((new TextDecoder).decode(a)):"arrayBuffer"===n&&r(a)}catch(e){console.error(`unwrap(): unknown issue - rejecting: ${e}`),console.trace(),s(e)}}))}sign(e,t){return new Promise((async(n,r)=>{try{const s=(new TextEncoder).encode(t);let o;try{o=await crypto.subtle.sign("HMAC",e,s),n(w(P(o)))}catch(e){r(e)}}catch(e){r(e)}}))}verify(e,t,n){return new Promise(((r,s)=>{try{crypto.subtle.verify("HMAC",e,E(t),ae.str2ab(n)).then((e=>{r(e)}))}catch(e){s(c(e))}}))}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}compareKeys(e,t){return null!=e&&null!=t&&"object"==typeof e&&"object"==typeof t&&e.x===t.x&&e.y===t.y}lookupKey(e,t){for(let n=0;n<t.length;n++)if(ae.compareKeys(e,t[n]))return n;return-1}async channelKeyStringsToCryptoKeys(e){return new Promise((async(t,n)=>{let r=G(e.ownerKey,"L1513");Promise.all([ae.importKey("jwk",r,"ECDH",!1,[]),ae.importKey("jwk",G(e.encryptionKey,"L2250"),"AES",!1,["encrypt","decrypt"]),ae.importKey("jwk",G(e.signKey,"L2251"),"ECDH",!0,["deriveKey"]),ae.importKey("jwk",ae.extractPubKey(G(e.signKey,"L2252")),"ECDH",!0,[])]).then((async e=>{s&&console.log("++++++++ readyPromise() processed first batch of keys");const n=e[0],o=e[1],a=e[2],i=e[3];t({ownerKey:n,ownerPubKeyX:r.x,encryptionKey:o,signKey:a,publicSignKey:i})})).catch((e=>{console.error(`readyPromise(): failed to import keys: ${e}`),n(e)}))}))}}function ee(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function te(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;`${n}ReadyFlag`in this&&h(this.readyFlag,`${t} getter accessed but object ${n} not ready (fatal)`);const s=r.call(this);return h(null!=s,`${t} getter accessed in object type ${n} but returns NULL (fatal)`),s}}}const ne=["SBMessage","SBObjectHandle"],re=Symbol.for("SBMessage"),se=Symbol.for("SBObjectHandle");function oe(e,t){switch(t){case"SBMessage":return re in e;case"SBObjectHandle":return se in e}}const ae=new Q,ie=[{channel_server:"https://channel.384co.workers.dev",channel_ws:"wss://channel.384co.workers.dev",storage_server:"https://storage.384co.workers.dev",shard_server:"https://shard.3.8.4.land"},{channel_server:"https://r.384co.workers.dev",channel_ws:"wss://r.384co.workers.dev",storage_server:"https://s.384co.workers.dev"}];class ce{ready;sb384Ready;#s=!1;#o;#a;#i;#c;constructor(e){this.ready=new Promise((async(t,n)=>{try{if(e){if(!e.d){const e="ERROR creating SB384 object: invalid key (must be a PRIVATE key)";console.error(e),n(e)}this.#a=e;const t=ae.extractPubKey(e);h(t,"unable to extract public key"),this.#o=t,this.#i=await ae.importKey("jwk",e,"ECDH",!0,["deriveKey"])}else{const e=await ae.generateKeys();this.#i=e.privateKey,this.#o=await ae.exportKey("jwk",e.publicKey),this.#a=await ae.exportKey("jwk",e.privateKey)}this.#c=await ae.sb384Hash(this.#o),ae.addKnownKey(this),this.#s=!0,t(this)}catch(e){n("ERROR creating SB384 object failed: "+c(e))}})),this.sb384Ready=this.ready}get readyFlag(){return this.#s}get exportable_pubKey(){return this.#o}get exportable_privateKey(){return this.#a}get privateKey(){return this.#i}get ownerChannelId(){return this.hash}get hash(){return this.#c}get _id(){return JSON.stringify(this.exportable_pubKey)}}n([ee],ce.prototype,"readyFlag",null),n([ee,te],ce.prototype,"exportable_pubKey",null),n([ee,te],ce.prototype,"exportable_privateKey",null),n([ee,te],ce.prototype,"privateKey",null),n([ee,te],ce.prototype,"ownerChannelId",null),n([ee,te],ce.prototype,"hash",null),n([ee,te],ce.prototype,"_id",null);class le{ready;channel;contents;#l;#h;[re]=!0;MAX_SB_BODY_SIZE=98304;constructor(e,t="",n){this.contents="string"==typeof t?{encrypted:!1,isVerfied:!1,contents:t,sign:"",image:"",imageMetaData:{}}:{encrypted:!1,isVerfied:!1,contents:"",sign:"",image:t.image,imageMetaData:t.imageMetaData};let r=this.contents,s=JSON.stringify(r);n&&(this.#h=ae.extractPubKey(n)),h(s.length<this.MAX_SB_BODY_SIZE,`SBMessage(): body must be smaller than ${this.MAX_SB_BODY_SIZE/1024} KiB (we got ${s.length/1024})})`),this.channel=e,this.ready=new Promise((t=>{e.channelReady.then((async()=>{this.contents.sender_pubKey=this.channel.exportable_pubKey,e.userName&&(this.contents.sender_username=e.userName);const n=this.channel.channelSignKey,s=ae.sign(n,r.contents),o=ae.sign(n,this.contents.image),a=ae.sign(n,JSON.stringify(this.contents.imageMetaData));this.#h?this.#l=await ae.deriveKey(this.channel.privateKey,await ae.importKey("jwk",this.#h,"ECDH",!0,[]),"AES",!1,["encrypt","decrypt"]):this.#l=this.channel.keys.encryptionKey,Promise.all([s,o,a]).then((e=>{this.contents.sign=e[0],this.contents.image_sign=e[1],this.contents.imageMetadata_sign=e[2],t(this)}))}))}))}get encryptionKey(){return this.#l}get sendToPubKey(){return this.#h}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}n([te],le.prototype,"encryptionKey",null);class he extends ce{channelReady;#y=!1;#d;motd="";locked=!1;owner=!1;admin=!1;adminData;verifiedGuest=!1;userName="";#u;#g;#p;#f="";#w="";#b="";constructor(e,t,n){console.log("CONSTRUCTOR new channel"),h(n,"Channel(): as of jslib 1.1.x the channelId must be provided"),super(t),this.#d=e,this.#p=n,this.#w=e.channel_server+"/api/",this.#b=e.channel_server+"/api/room/",this.channelReady=new Promise((async(e,t)=>{await this.sb384Ready,i(this.#d.channel_server+"/api/room/"+this.#p+"/getChannelKeys",{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>(e.ok||t("ChannelEndpoint(): failed to get channel keys (network response not ok)"),e.json()))).then((async n=>{n.error&&t("ChannelEndpoint(): failed to get channel keys (error in response)"),await this.#m(n),this.#y=!0,e(this)})).catch((e=>{t("ChannelApi Error [1]: "+c(e))}))}))}async#v(e){this.#u=e,s&&(console.log("set channelkeys to 'k':"),console.log(e)),h(this.#u,"Channel.importKeys: no channel keys (?)"),h(this.#u.publicSignKey,"Channel.importKeys: no public sign key (?)"),h(this.privateKey,"Channel.importKeys: no private key (?)"),this.#g=await ae.deriveKey(this.privateKey,this.#u.publicSignKey,"HMAC",!1,["sign","verify"])}async#m(e){s&&(console.log("loading keys:"),console.log(e)),await this.#v(await ae.channelKeyStringsToCryptoKeys(e))}get keys(){return this.#u}get sbServer(){return this.#d}get readyFlag(){return this.#y}get api(){return this}get channelId(){return this.#p}get channelSignKey(){return this.#g}getLastMessageTimes(){return new Promise(((e,t)=>{i(this.#w+"/getLastMessageTimes",{method:"POST",body:JSON.stringify([this.channelId])}).then((e=>(e.ok||t(new Error("Network response was not OK")),e.json()))).then((t=>{e(t[this.channelId])})).catch((e=>{t(e)}))}))}getOldMessages(e=100,t=!1){return new Promise((async(n,r)=>{this.#y||(s&&console.log("Channel.getOldMessages: channel not ready (we will wait)"),await this.channelReady,this.#u||r("Channel.getOldMessages: no channel keys (?) despite waiting"));let a="";t&&(a="&cursor="+this.#f),i(this.#b+this.channelId+"/oldMessages?currentMessagesLength="+e+a,{method:"GET"}).then((async e=>(e.ok||r(new Error("Network response was not OK")),e.json()))).then((e=>{s&&(console.log("getOldMessages"),console.log(e)),Promise.all(Object.keys(e).filter((t=>e[t].hasOwnProperty("encrypted_contents"))).map((t=>ge(t,e[t].encrypted_contents,this.#u)))).then((e=>e.filter((e=>Boolean(e))))).then((e=>{let t=e[e.length-1];t&&(this.#f=t._id||t.id||""),o&&console.log(e),n(e)}))})).catch((e=>{r(e)}))}))}async#k(e,t){s&&console.log("#callApi:",e),this.#y||(console.log("ChannelApi.#callApi: channel not ready (we will wait)"),await this.channelReady);const n=t?"POST":"GET";return new Promise((async(r,s)=>{await this.ready;let o="";const a=(new Date).getTime().toString();o=a+"."+await ae.sign(this.channelSignKey,a);let l={method:n,headers:{"Content-Type":"application/json",authorization:o}};t&&(l.body=JSON.stringify(t)),await this.ready,i(this.#b+this.channelId+e,l).then((async e=>{const t=await e.json();if(!e.ok||t.error){let n="Network or Server error on Channel API call";e.status&&(n+=" ["+e.status+"]"),t.error&&(n+=": "+t.error),s(new Error(n))}else r(t)})).catch((e=>{s("ChannelApi (SBFetch) Error [2]: "+c(e))}))}))}updateCapacity(e){return this.#k("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.#k("/getRoomCapacity")}getStorageLimit(){return this.#k("/getStorageLimit")}getMother(){return this.#k("/getMother")}getJoinRequests(){return this.#k("/getJoinRequests")}isLocked(){return new Promise((e=>this.#k("/roomLocked").then((t=>e(!0===t.locked)))))}setMOTD(e){return this.#k("/motd",{motd:e})}getAdminData(){return this.#k("/getAdminData")}downloadData(){return new Promise(((e,t)=>{this.#k("/downloadData").then((t=>{console.log("From downloadData:"),console.log(t),Promise.all(Object.keys(t).filter((e=>{const n=new RegExp(this.channelId);if(e.match(n)){const n=G(t[e],"L3318");if(n.hasOwnProperty("encrypted_contents"))return s&&console.log("Received message: ",n),n}})).map((e=>{const n=G(t[e],"L3327");return o&&console.log(e,n.encrypted_contents,this.keys),ge(e,n.encrypted_contents,this.keys)}))).then((e=>e.filter((e=>Boolean(e))))).then((n=>{let r={};n.forEach((e=>{if(!e.control&&e.imageMetaData.imageId){const t=n.find((t=>t.id&&t.id==e.imageMetaData.imageId)),s=n.find((t=>t.id&&t.id==e.imageMetaData.previewId));r[`${e.imageMetaData.imageId}.f`]=t?.verificationToken,r[`${e.imageMetaData.previewId}.p`]=s?.verificationToken}})),e({storage:r,channel:t})}))})).catch((e=>{t(e)}))}))}uploadChannel(e){return this.#k("/uploadRoom",e)}authorize(e,t){return this.#k("/authorizeRoom",{roomId:this.channelId,SERVER_SECRET:t,ownerKey:e})}postPubKey(e){throw new Error("postPubKey() deprecated")}storageRequest(e){return this.#k("/storageRequest?size="+e)}lock(){return console.warn("WARNING: lock() on channel api has not been tested/debugged fully .."),new Promise((async(e,t)=>{if(null==this.keys.lockedKey&&this.admin){const n=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),r=await crypto.subtle.exportKey("jwk",n);this.#k("/lockRoom").then((t=>{t.locked&&this.acceptVisitor(JSON.stringify(this.exportable_pubKey)).then((()=>{e({locked:t.locked,lockedKey:r})}))})).catch((e=>{t(e)}))}else t(new Error("no lock key or not admin"))}))}acceptVisitor(e){return console.warn("WARNING: acceptVisitor() on channel api has not been tested/debugged fully .."),new Promise((async(t,n)=>{this.privateKey||n(new Error("acceptVisitor(): no private key"));const r=await ae.deriveKey(this.privateKey,await ae.importKey("jwk",G(e,"L2276"),"ECDH",!1,[]),"AES",!1,["encrypt","decrypt"]),s=await ae.encrypt(ae.str2ab(JSON.stringify(this.keys.lockedKey)),r);t(this.#k("/acceptVisitor",{pubKey:e,lockedKey:JSON.stringify(s)}))}))}ownerKeyRotation(){throw new Error("ownerKeyRotation() replaced by new budd() approach")}budd(e){let{keys:t,storage:n,targetChannel:r}=e??{};return new Promise((async(s,o)=>{e&&e.hasOwnProperty("storage")&&void 0===e.storage&&o("If you omit 'storage' it defaults to Infinity, but you cannot set 'storage' to undefined");try{if(n||(n=1/0),r){if(this.#p==r)throw new Error("[budd()]: You can't specify the same channel as targetChannel");if(t)throw new Error("[budd()]: You can't specify both a target channel and keys");s(this.#k(`/budd?targetChannel=${r}&transferBudget=${n}`))}else{const{channelData:e,exportable_privateKey:r}=await y(t);let a=await this.#k(`/budd?targetChannel=${e.roomId}&transferBudget=${n}`,e);a.success?s({channelId:e.roomId,key:r}):o(JSON.stringify(a))}}catch(e){o(e)}}))}}function ye(e){h(!1,"NO MESSAGE HANDLER")}n([ee,te],he.prototype,"keys",null),n([ee,te],he.prototype,"sbServer",null),n([ee,te],he.prototype,"readyFlag",null),n([ee,te],he.prototype,"api",null),n([ee,te],he.prototype,"channelId",null),n([ee,te],he.prototype,"channelSignKey",null),n([te],he.prototype,"updateCapacity",null),n([te],he.prototype,"getCapacity",null),n([te],he.prototype,"getStorageLimit",null),n([te],he.prototype,"getMother",null),n([te],he.prototype,"getJoinRequests",null),n([function(e,t,n){if(n&&n.value){const r=n.value;n.value=function(...s){try{return r.call(this,...s)}catch(r){return console.log(`ExceptionReject: ${c(r)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${c(r)}`)))}}}}],he.prototype,"isLocked",null),n([te],he.prototype,"setMOTD",null),n([te],he.prototype,"getAdminData",null),n([te],he.prototype,"downloadData",null),n([te],he.prototype,"uploadChannel",null),n([te],he.prototype,"authorize",null),n([te],he.prototype,"postPubKey",null),n([te],he.prototype,"storageRequest",null),n([te],he.prototype,"lock",null),n([te],he.prototype,"acceptVisitor",null),n([te],he.prototype,"ownerKeyRotation",null),n([te],he.prototype,"budd",null);class de extends he{ready;channelSocketReady;onOpen=void 0;onClose=void 0;onError=void 0;#S=!1;#K;#d;#A=ye;#C=new Map;#E=!1;#x=()=>{l("L2461","this should never be called")};#O=e=>{l("L2462","this should never be called")};constructor(e,t,n,r){super(e,n,r),h(e.channel_ws,"ChannelSocket(): no websocket server name provided"),h(t,"ChannelSocket(): no onMessage handler provided");const s=e.channel_ws+"/api/room/"+r+"/websocket";this.#A=t,this.#d=e,this.#d.hasOwnProperty("onOpen")&&(this.onOpen=this.#d.onOpen),this.#d.hasOwnProperty("onClose")&&(this.onClose=this.#d.onClose),this.#d.hasOwnProperty("onError")&&(this.onError=this.#d.onError),this.#K={url:s,ready:!1,closed:!1,timeout:2e3},this.ready=this.channelSocketReady=this.#B()}#B(){return s&&console.log("++++ CREATING ChannelSocket.readyPromise()"),new Promise(((e,t)=>{s&&console.log("++++ STARTED ChannelSocket.readyPromise()"),this.#x=e;const n=this.#K.url;s&&(console.log("++++++++ readyPromise() has url:"),console.log(n)),this.#K.websocket||(this.#K.websocket=new WebSocket(this.#K.url)),3===this.#K.websocket.readyState?this.#K.websocket=new WebSocket(n):2===this.#K.websocket.readyState&&(console.warn("STRANGE - trying to use a ChannelSocket that is in the process of closing ..."),this.#K.websocket=new WebSocket(n)),this.#K.websocket.addEventListener("open",(()=>{this.#K.closed=!1,this.channelReady.then((()=>{h(this.exportable_pubKey,"ChannelSocket.readyPromise(): no exportable pub key?"),this.#K.init={name:JSON.stringify(this.exportable_pubKey)},s&&(console.log("++++++++ readyPromise() constructed init:"),console.log(this.#K.init)),this.onOpen&&this.onOpen(),this.#K.websocket.send(JSON.stringify(this.#K.init))}))})),this.#O=this.#R.bind(this),this.#K.websocket.addEventListener("message",this.#O),this.#K.websocket.addEventListener("close",(e=>{this.#K.closed=!0,e.wasClean?(e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.#d.channel_server})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason),this.onClose&&this.onClose(e)):(this.onClose&&this.onClose(e),console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.#d.channel_server}`)),this.onClose&&this.onClose(e),t("wbSocket() closed before it was opened (?)")})),this.#K.websocket.addEventListener("error",(e=>{this.#K.closed=!0,console.log("ChannelSocket() error: ",e),this.onError&&this.onError(e),t("ChannelSocket creation error (see log)")})),setTimeout((()=>{this.#S?s&&(console.log("ChannelSocket() - this socket resolved"),console.log(this)):(console.warn("ChannelSocket() - this socket is not resolving (waited 10s) ..."),console.log(this),t("ChannelSocket() - this socket is not resolving (waited 10s) ..."))}),1e4)}))}async#P(e){let t=e.data;this.#E&&(console.log("... raw unwrapped message:"),console.log(structuredClone(t)));const n=G(t,"L1489");this.#E&&(console.log("... json unwrapped version of raw message:"),console.log(Object.assign({},n))),"function"!=typeof this.#A&&l("ChannelSocket","received message but there is no handler");const r=n;try{const e=Object.entries(r)[0][1];if("encrypted_contents"===Object.keys(e)[0]){s&&(console.log("++++++++ #processMessage: received message:"),console.log(e.encrypted_contents.content));const t=P(await crypto.subtle.digest("SHA-256",(new TextEncoder).encode(e.encrypted_contents.content)));o&&console.log("Received message with hash:",t);const r=this.#C.get(t);r&&(this.#E&&console.log(`++++++++ #processMessage: found matching ack for id ${t}`),this.#C.delete(t),r("success"));const a=Object.entries(n)[0][0],i=e.encrypted_contents.iv;if(i&&f(i)&&16==i.length){e.encrypted_contents.iv=E(i);try{const t=await ge(a,e.encrypted_contents,this.keys);if(!t)return;this.#E&&(console.log("++++++++ #processMessage: passing to message handler:"),console.log(Object.assign({},t))),this.#A(t)}catch{console.warn("Error decrypting message, dropping (ignoring) message")}}else console.error("#processMessage: - iv is malformed, should be 16-char b64 string (ignoring)")}else console.warn("++++++++ #processMessage: can't decipher message, passing along unchanged:"),console.log(Object.assign({},r)),this.onMessage(r)}catch(e){console.log(`++++++++ #processMessage: caught exception while decyphering (${e}), passing it along unchanged`),this.onMessage(r)}}#_(e){console.warn("WARNING: firstMessageEventHandler() called recursively (?)"),console.warn(e)}#R(e){console.log("FIRST MESSAGE HANDLER CALLED");const t=this.#_.bind(this);this.#K.websocket.addEventListener("message",t),this.#K.websocket.removeEventListener("message",this.#O),s&&(console.log("++++++++ readyPromise() received ChannelKeysMessage:"),console.log(e));const n=G(e.data,"L2239");s&&console.log(n),h(n.ready,"got roomKeys but channel reports it is not ready (?)"),this.motd=n.motd,this.locked=n.roomLocked;const r=G(n.keys.ownerKey,"L2246");h(this.keys.ownerPubKeyX===r.x,"ChannelSocket.readyPromise(): owner key mismatch??"),h(this.readyFlag,"#ChannelReadyFlag is false, parent not ready (?)"),this.owner=ae.compareKeys(r,this.exportable_pubKey),this.admin=!1,this.#K.websocket.addEventListener("message",this.#P.bind(this)),this.#K.websocket.removeEventListener("message",t),s&&console.log("++++++++ readyPromise() all done - resolving!"),this.#S=!0,this.#x(this)}get status(){if(!this.#K.websocket)return"CLOSED";switch(this.#K.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#A=e}get onMessage(){return this.#A}set enableTrace(e){this.#E=e,console.log(`==== jslib ChannelSocket: Tracing ${e?"en":"dis"}abled ====`)}send(e){let t="string"==typeof e?new le(this,e):e;return h(this.#K.websocket,"ChannelSocket.send() called before ready"),this.#K.closed&&(this.#E&&console.info("send() triggered reset of #readyPromise() (normal)"),this.ready=this.channelSocketReady=this.#B(),this.#S=!0),new Promise(((e,n)=>{t.ready.then((t=>{this.ready.then((()=>{switch(this.#S||n("ChannelSocket.send() is confused - ready or not?"),this.#K.websocket.readyState){case 1:this.#E&&(console.log("Wrapping message contents:"),console.log(Object.assign({},t.contents))),ae.wrap(t.encryptionKey,JSON.stringify(t.contents),"string").then((r=>{const o=JSON.stringify({encrypted_contents:r,recipient:t.sendToPubKey?t.sendToPubKey:void 0});console.log("++++++++ ChannelSocket.send(): sending message:"),console.log(r.content),crypto.subtle.digest("SHA-256",(new TextEncoder).encode(r.content)).then((t=>{const r=P(t);s&&(console.log("Which has hash:"),console.log(r)),this.#C.set(r,e),this.#K.websocket.send(o),setTimeout((()=>{if(this.#C.has(r)){this.#C.delete(r);const e=`Websocket request timed out (no ack) after ${this.#K.timeout}ms (${r})`;console.error(e),n(e)}else this.#E&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#K.timeout)}))}));break;case 3:case 0:case 2:n("socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING")}}))}))}))}get exportable_owner_pubKey(){return this.keys.ownerKey}}n([te],de.prototype,"onMessage",null),n([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&ne.includes(n)&&h(oe(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],de.prototype,"send",null),n([ee,te],de.prototype,"exportable_owner_pubKey",null);class ue extends he{constructor(e,t,n){super(e,t,n)}send(e,t){return new Promise(((e,t)=>{t("ChannelEndpoint.send(): send outside ChannelSocket not yet implemented")}))}set onMessage(e){h(!1,"ChannelEndpoint.onMessage: send/receive outside ChannelSocket not yet implemented")}}async function ge(e,t,n){const r=g.exec(e);let s=n.encryptionKey;if(r){let e={type:"encrypted",channelID:r[1],timestampPrefix:r[2],_id:r[1]+r[2],encrypted_contents:d(t)};const o=await ae.unwrap(s,e.encrypted_contents,"string");let a={...e,...G(o,"L1977")};if(a.contents&&(a.text=a.contents),a.user={name:a.sender_username?a.sender_username:"Unknown",_id:a.sender_pubKey},a.verificationToken&&!a.sender_pubKey)return void console.error("ERROR: message with verification token is lacking sender identity (cannot be verified).");const i=await ae.importKey("jwk",a.sender_pubKey,"ECDH",!0,[]),c=await ae.deriveKey(n.signKey,i,"HMAC",!1,["sign","verify"]);return await ae.verify(c,a.sign,a.contents)?(a.whispered,a):(console.error("***** signature is NOT correct for message (rejecting)"),console.log("verifyKey:"),console.log(Object.assign({},c)),console.log("m2.sign"),console.log(Object.assign({},a.sign)),console.log("m2.contents"),console.log(structuredClone(a.contents)),console.log("Message:"),console.log(Object.assign({},a)),void console.trace())}return console.log("++++++++ #processMessage: ERROR - cannot parse channel ID / timestamp, invalid message"),console.log(Object.assign({},e)),void console.log(Object.assign({},t))}class pe{version="1";#j="b";#M;#T;#D;#I;#N;iv;salt;fileName;dateAndTime;shardServer;fileType;lastModified;actualSize;savedSize;constructor(e){const{version:t,type:n,id:r,key:s,id32:o,key32:a,verification:i,iv:c,salt:l,fileName:h,dateAndTime:y,shardServer:d,fileType:u,lastModified:g,actualSize:p,savedSize:f}=e;n&&(this.#j=n),t&&(this.version=t),r&&(this.id=r),s&&(this.key=s),o&&(this.id32=o),a&&(this.key32=a),i&&(this.#N=i),this.iv=c,this.salt=l,this.fileName=h,this.dateAndTime=y,this.shardServer=d,this.fileType=u,this.lastModified=g,this.actualSize=p,this.savedSize=f}set id(e){f(e),this.#M=e,this.#D=I(e)}get id(){return h(this.#M,"object handle identifier is undefined"),this.#M}set key(e){f(e),this.#T=e,this.#I=I(e)}get key(){return h(this.#T,"object handle identifier is undefined"),this.#T}set id32(e){if(!N(e))throw new Error("Invalid base62 encoded ID");this.#D=e,this.#M=D(e)}set key32(e){if(!N(e))throw new Error("Invalid base62 encoded Key");this.#I=e,this.#T=D(e)}get id32(){return h(this.#D,"object handle id (32) is undefined"),this.#D}get key32(){return h(this.#I,"object handle key (32) is undefined"),this.#I}set verification(e){this.#N=e}get verification(){return h(this.#N,"object handle verification is undefined"),this.#N}get type(){return this.#j}}class fe{server;shardServer;channelServer;constructor(e,t,n){this.server=e+"/api/v1",this.channelServer=t+"/api/room/",n&&(this.shardServer=n+"/api/v1")}#U(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=U(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),o&&(console.log("#padBuf bytes:"),console.log(r.slice(-4))),r}#L(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(o&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=r),o&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}#$(e,t){return new Promise(((n,r)=>{try{ae.importKey("raw",E(decodeURIComponent(e)),"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}#H(e,t){return new Promise(((n,r)=>{i(this.server+"/storeRequest?name="+e+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=W(e);n({salt:new Uint8Array(t.salt),iv:new Uint8Array(t.iv)})})).catch((e=>{console.warn(`**** ERROR: ${e}`),r(e)}))}))}#F(e,t,n,r,s,o,a){return new Promise(((c,l)=>{this.#$(n,a).then((n=>{ae.encrypt(e,n,o,"arrayBuffer").then((e=>{i(this.channelServer+s+"/storageRequest?size="+e.byteLength).then((e=>e.json())).then((n=>{n.hasOwnProperty("error")&&l(`storage token request error (${n.error})`);let s=JSON.stringify(n);this.storeData(r,t,o,a,s,e).then((e=>{e.error&&l(`storeObject() failed: ${e.error}`),e.image_id!=t&&l(`received imageId ${e.image_id} but expected ${t}`),c(e.verification_token)})).catch((e=>{console.log("ERROR in _storeObject(): ${e}"),l(e)}))}))}))}))}))}getObjectMetadata(e,t){return new Promise(((n,r)=>{const s=this.#U(e);ae.generateIdKey(s).then((e=>{this.#H(e.id,t).then((r=>{const o={[se]:!0,version:"1",type:t,id:e.id,key:e.key,iv:r.iv,salt:r.salt,paddedBuffer:s};n(o)})).catch((e=>r(e)))}))}))}storeObject(e,t,n,r){return new Promise(((s,a)=>{e instanceof Uint8Array&&(o&&console.log("converting Uint8Array to ArrayBuffer"),e=new Uint8Array(e).buffer),e instanceof ArrayBuffer||"ArrayBuffer"==e.constructor.name||(o&&console.log("buf must be an ArrayBuffer:"),console.log(e),a("buf must be an ArrayBuffer"));const i=e.byteLength;if(r){const e={[se]:!0,version:"1",type:t,id:r.id,key:r.key,iv:r.iv,salt:r.salt,actualSize:i,verification:this.#F(r.paddedBuffer,r.id,r.key,t,n,r.iv,r.salt)};s(e)}else{const r=this.#U(e);ae.generateIdKey(r).then((e=>{this.#H(e.id,t).then((o=>{const a={[se]:!0,version:"1",type:t,id:e.id,key:e.key,id32:I(e.id),key32:I(e.key),iv:o.iv,salt:o.salt,actualSize:i,verification:this.#F(r,e.id,e.key,t,n,o.iv,o.salt)};s(a)})).catch((e=>a(e)))}))}}))}storeRequest(e){return new Promise(((t,n)=>{i(this.server+"/storeRequest?name="+e).then((e=>(e.ok||n(new Error("Network response was not OK")),e.arrayBuffer()))).then((e=>{t(e)})).catch((e=>{n(e)}))}))}storeData(e,t,n,r,s,o){return new Promise(((a,c)=>{i(this.server+"/storeData?type="+e+"&key="+w(t),{method:"POST",body:z({iv:n,salt:r,image:o,storageToken:(new TextEncoder).encode(s),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||c("response from storage server was not OK"),e.json()))).then((e=>{a(e)})).catch((e=>{c(e)}))}))}#J(e,t){return new Promise(((n,r)=>{try{let t=G(ae.ab2str(new Uint8Array(e)),"L3062");t.error&&r(`#processData() error: ${t.error}`)}catch(e){}finally{const r=W(e);s&&(console.log("Payload (#processData) is:"),console.log(r));const a=new Uint8Array(r.iv),i=new Uint8Array(r.salt),c=t.iv?"string"==typeof t.iv?E(t.iv):t.iv:void 0,l=t.salt?"string"==typeof t.salt?E(t.salt):t.salt:void 0;c&&!R(a,c)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${P(c)}`),console.log(`server iv: ${P(r.iv)}`)),l&&!R(i,l)&&(console.error("WARNING: salt from server differs from local copy (will use server)"),t.salt?"string"==typeof t.salt?(console.log("h.salt is in string form (unprocessed):"),console.log(t.salt)):(console.log("h.salt is in arrayBuffer or Uint8Array"),console.log("h.salt as b64:"),console.log(P(t.salt)),console.log("h.salt unprocessed:"),console.log(t.salt)):console.log("h.salt is undefined"),console.log("handleSalt as b64:"),console.log(P(l)),console.log("handleSalt unprocessed:"),console.log(l)),o&&(console.log("will use nonce and salt of:"),console.log(`iv: ${P(a)}`),console.log(`salt : ${P(i)}`)),this.#$(t.key,i).then((e=>{const t=r.image;o&&(console.log("data.image:      "),console.log(r.image),console.log("encrypted_image: "),console.log(t)),ae.unwrap(e,{content:t,iv:a},"arrayBuffer").then((e=>{const t=this.#L(e);s&&(console.log("#processData(), unwrapped img: "),console.log(t)),n(t)}))}))}}))}fetchData(e,t="arrayBuffer"){return new Promise((async(n,r)=>{e||r("SBObjectHandle is null or undefined");const o=await e.verification,a=e.shardServer?e.shardServer+"/api/v1":this.shardServer?this.shardServer:this.server;s&&console.log("fetchData(), fetching from server: "+a),i(a+"/fetchData?id="+w(e.id)+"&type="+e.type+"&verification_token="+o,{method:"GET"}).then((e=>(e.ok||r(new Error("Network response was not OK")),e.arrayBuffer()))).then((t=>this.#J(t,e))).then((e=>{n("string"===t?ae.ab2str(new Uint8Array(e)):e)})).catch((e=>{r(e)}))}))}async retrieveImage(e,t,n,r,s){console.trace("retrieveImage()"),console.log(e);const o=n||e.previewId,a=r||e.previewKey,i=s||"p",c=t.find((e=>e.id&&e.id==o));if(console.log(c),c){h(c.verificationToken,"retrieveImage(): verificationToken missing (?)"),h(c.id,"retrieveImage(): id missing (?)");const e={type:i,id:c.id,key:a,verification:new Promise(((e,t)=>{c.verificationToken?e(c.verificationToken):t("retrieveImage(): verificationToken missing (?)")}))},t=await this.fetchData(e);return console.log(t),{url:"data:image/jpeg;base64,"+P(t,"b64")}}return{error:"Failed to fetch data - missing control message for that image"}}}class we{#G;#V;#z;#W=r;constructor(e,t=!1){console.warn(`==== CREATING Snackabra object generation: ${this.version} ====`),e&&(this.#z=Object.assign({},e),this.#G=new fe(e.storage_server,e.channel_server,e.shard_server?e.shard_server:void 0),t&&(s=!0),s&&console.warn("++++ Snackabra constructor ++++ setting DBG to TRUE ++++"))}connect(e,t,n){return s&&(console.log("++++ Snackabra.connect() ++++"),t&&console.log(t),n&&console.log(n)),new Promise((async r=>{this.#z?r(new de(this.#z,e,t,n)):r(Promise.any(ie.map((r=>new de(r,e,t,n).ready))))}))}create(e,t,n){return new Promise((async(r,s)=>{try{const{channelData:o,exportable_privateKey:a}=await y(n);o.SERVER_SECRET=t;const c=(new TextEncoder).encode(JSON.stringify(o));let l=await i(e.channel_server+"/api/room/"+o.roomId+"/uploadRoom",{method:"POST",body:c});l=await l.json(),l.success?r({channelId:o.roomId,key:a,server:e.channel_server}):s(JSON.stringify(l))}catch(e){s(e)}}))}get channel(){return this.#V}get storage(){return this.#G}get crypto(){return ae}get version(){return this.#W}}var be={Snackabra:we,SBMessage:le,Channel:he,SBCrypto:Q,SB384:ce,arrayBufferToBase64:P,sbCrypto:ae,version:r};return globalThis.SB||(globalThis.SB=be),console.warn(`==== SNACKABRA jslib loaded ${globalThis.SB.version} ====`),t})()));