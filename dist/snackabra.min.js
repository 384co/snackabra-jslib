!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>_e,ChannelSocket:()=>Ue,KeyPrefix:()=>ye,Memoize:()=>be,MessageBus:()=>A,NEW_CHANNEL_MINIMUM_BUDGET:()=>o,Protocol_AES_GCM_256:()=>je,Protocol_ECDH:()=>Fe,Ready:()=>Se,SB:()=>He,SB384:()=>xe,SBApiFetch:()=>x,SBChannelKeys:()=>Te,SBCrypto:()=>ve,SBError:()=>P,SBMessage:()=>Oe,SBStorageTokenPrefix:()=>i,Snackabra:()=>Ne,StorageApi:()=>$e,arrayBufferToBase62:()=>Y,arrayBufferToBase64url:()=>U,assemblePayload:()=>ce,b32decode:()=>se,b32encode:()=>re,b32process:()=>ae,b62regex:()=>G,base62:()=>N,base62ToArrayBuffer:()=>X,base62ToBase64:()=>Q,base62regex:()=>z,base64ToArrayBuffer:()=>$,base64ToBase62:()=>ee,base64url:()=>F,compareBuffers:()=>D,composeMessageKey:()=>u,deComposeMessageKey:()=>g,extractPayload:()=>de,getRandomValues:()=>R,hydrateKey:()=>we,isBase62Encoded:()=>V,jsonParseWrapper:()=>I,msgTtlToSeconds:()=>k,msgTtlToString:()=>B,sbCrypto:()=>De,setDebugLevel:()=>m,stringify_SBObjectHandle:()=>K,stripChannelMessage:()=>v,validate_ChannelApiBody:()=>p,validate_ChannelMessage:()=>w,validate_Message:()=>f,validate_SBChannelData:()=>y,validate_SBChannelHandle:()=>h,validate_SBObjectHandle:()=>C,validate_SBStorageToken:()=>c,version:()=>s});var n,r,a=function(e,t,n,r){var a,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(a=e[i])&&(o=(s<3?a(o):s>3?a(t,n,o):a(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};const s="2.0.0-alpha.5 (build 082)",o=8388608,i="LM2r";function c(e){if(e){if(e[Ie])return e;if("string"==typeof e&&e.slice(0,4)===i)return{[Ie]:!0,hash:e};if(!(e.hash&&"string"==typeof e.hash&&e.hash.length>0&&(!e.size||Number.isInteger(e.size)&&e.size>0))||e.motherChannel&&"string"!=typeof e.motherChannel||e.created&&!Number.isInteger(e.created)||e.used&&"boolean"!=typeof e.used)throw b&&console.error("invalid SBStorageToken ... trying to ingest:\n",e),new P("invalid SBStorageToken");return{...e,[Ie]:!0}}throw new P("invalid SBStorageToken (null or undefined)")}function l(e){return e.channelId&&43===e.channelId.length&&e.userPrivateKey&&"string"==typeof e.userPrivateKey&&e.userPrivateKey.length>0&&(!e.channelServer||"string"==typeof e.channelServer)&&(!e.channelData||d(e.channelData))}function h(e){if(e){if(e[Ke])return e;if(l(e))return{...e,[Ke]:!0};throw S&&console.error("invalid SBChannelHandle ... trying to ingest:\n",e),new P("invalid SBChannelHandle")}throw new P("invalid SBChannelHandle (null or undefined)")}function d(e){return e.channelId&&43===e.channelId.length&&e.ownerPublicKey&&"string"==typeof e.ownerPublicKey&&e.ownerPublicKey.length>0&&(!e.storageToken||c(e.storageToken))}function y(e){if(e){if(d(e))return e;throw b&&console.error("invalid SBChannelData ... trying to ingest:\n",e),new P("invalid SBChannelData")}throw new P("invalid SBChannelData (null or undefined)")}function u(e,t,n="____"){return`${e}_${n??"____"}_${r=t,r.toString(4).padStart(22,"0")+"0000"}`;var r}function g(e){const t=e.slice(0,43),n=e.slice(44,48);var r;return{channelId:t,timestamp:(r=e.slice(49),parseInt(r,4)),subChannel:n}}function f(e){if(e){if(void 0!==e.body&&null!==e.body&&e.channelId&&"string"==typeof e.channelId&&43===e.channelId.length&&e.sender&&"string"==typeof e.sender&&43===e.sender.length&&e.senderPublicKey&&"string"==typeof e.senderPublicKey&&e.senderPublicKey.length>0&&e.senderTimestamp&&Number.isInteger(e.senderTimestamp)&&e.serverTimestamp&&Number.isInteger(e.serverTimestamp)&&e._id&&"string"==typeof e._id&&75===e._id.length)return e;throw b&&console.error("invalid Message ... trying to ingest:\n",e),new P("invalid Message")}throw new P("invalid Message (null or undefined)")}function p(e){if(e){if(e[Ce])return e;if(e.channelId&&43===e.channelId.length&&e.path&&"string"==typeof e.path&&e.path.length>0&&e.userId&&"string"==typeof e.userId&&43===e.userId.length&&e.userPublicKey&&e.userPublicKey.length>0&&(!e.isOwner||"boolean"==typeof e.isOwner)&&(!e.apiPayloadBuf||e.apiPayloadBuf instanceof ArrayBuffer)&&e.timestamp&&Number.isInteger(e.timestamp)&&e.sign&&e.sign instanceof ArrayBuffer)return{...e,[Ce]:!0};throw b&&console.error("invalid ChannelApiBody ... trying to ingest:\n",e),new P("invalid ChannelApiBody")}throw new P("invalid ChannelApiBody (null or undefined)")}function w(e){if(e){if(e[Be])return e;if(!(e.f&&"string"==typeof e.f&&43===e.f.length&&e.c&&e.c instanceof ArrayBuffer&&e.ts&&Number.isInteger(e.ts)&&e.iv&&e.iv instanceof Uint8Array&&12===e.iv.length&&e.s&&e.s instanceof ArrayBuffer)||e.sts&&!Number.isInteger(e.sts)||e.salt&&!(e.salt instanceof ArrayBuffer&&16===e.salt.byteLength)||e._id&&("string"!=typeof e._id||86!==e._id.length)||e.ready&&"boolean"!=typeof e.ready||e.timestampPrefix&&("string"!=typeof e.timestampPrefix||26!==e.timestampPrefix.length)||e.channelId&&("string"!=typeof e.channelId||43!==e.channelId.length)||e.i2&&("string"!=typeof e.i2||!/^[a-zA-Z0-9_]{4}$/.test(e.i2))||e.ttl&&!(Number.isInteger(e.ttl)&&e.ttl>=0&&e.ttl<=15))throw S&&console.error("invalid ChannelMessage ... trying to ingest:\n",e),new P("invalid ChannelMessage");return{...e,[Be]:!0}}throw new P("invalid ChannelMessage (null or undefined)")}function v(e){b&&console.log("stripping message:\n",e);const t={};if(void 0===e.f)throw new P("ERROR: missing 'f' ('from') in message");if(t.f=e.f,void 0===e.c)throw new P("ERROR: missing 'ec' ('encrypted contents') in message");if(t.c=e.c,void 0===e.iv)throw new P("ERROR: missing 'iv' ('nonce') in message");if(t.iv=e.iv,void 0===e.salt)throw new P("ERROR: missing 'salt' in message");if(t.salt=e.salt,void 0===e.s)throw new P("ERROR: missing 's' ('signature') in message");if(t.s=e.s,void 0===e.ts)throw new P("ERROR: missing 'ts' ('timestamp') in message");if(t.ts=e.ts,void 0===e.sts)throw new P("ERROR: missing 'sts' ('servertimestamp') in message");return t.sts=e.sts,void 0!==e.ttl&&15!==e.ttl&&(t.ttl=e.ttl),void 0!==e.t&&(t.t=e.t),void 0!==e.i2&&"____"!==e.i2&&(t.i2=e.i2),t}var b=!1,S=!1;function m(e,t){t&&(S=e&&t),(b=e)&&console.warn("++++ [setDebugLevel]: setting DBG to TRUE ++++"),S&&console.warn("++++ [setDebugLevel]: ALSO setting DBG2 to TRUE (verbose) ++++")}globalThis.configuration&&!0===globalThis.configuration.DEBUG&&((b=!0)&&console.warn("++++ Setting DBG to TRUE based on 'configuration.DEBUG' ++++"),!0===globalThis.configuration.DEBUG2&&(S=!0,b&&console.warn("++++ ALSO setting DBG2 (verbose) ++++")));const k=[0,-1,-1,60,300,1800,14400,129600,864e3,-1,-1,-1,-1,-1,1/0],B=["Ephemeral","<reserved>","<reserved>","One minute","Five minutes","Thirty minutes","Four hours","36 hours","10 days","<reserved>","<reserved>","<reserved>","<reserved>","<reserved>","Permastore (no TTL)"];function C(e){if(e){if(e[Pe])return e;if(e.version&&"3"!==e.version||!e.id||"string"!=typeof e.id||43!==e.id.length||e.key&&("string"!=typeof e.key||43!==e.key.length)||e.verification&&"string"!=typeof e.verification&&"object"!=typeof e.verification||e.iv&&"string"!=typeof e.iv&&!(e.iv instanceof Uint8Array)||e.salt&&"string"!=typeof e.salt&&!(e.salt instanceof ArrayBuffer))throw b&&console.error("invalid SBObjectHandle ... trying to ingest:\n",e),new P("invalid SBObjectHandle");return{...e,[Pe]:!0}}throw new P("invalid SBObjectHandle (null or undefined)")}async function K(e){return e.iv&&(e.iv="string"==typeof e.iv?e.iv:Y(e.iv)),e.salt&&(e.salt="string"==typeof e.salt?e.salt:Y(e.salt)),e.verification=await e.verification,C(e)}class A{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}class P extends Error{constructor(e){if(super(e),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(e).stack,S){let t=null;if(this.stack){const e=this.stack.split("\n");for(let n=1;n<e.length;n++)if(e[n].trim().startsWith("at")){t=`${e[n].trim()}`;break}}null!==t?console.log("\n",Re,"SBError():\n","'"+e+"'","\n",t,"\n",Re):console.log("\n",Re,"SBError():\n",e,"\n",Re)}}}function I(e,t,n){for(;e&&"string"==typeof e;)try{e=JSON.parse(e,n)}catch(n){throw new P(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}const M=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function D(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=M(e),r=M(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function R(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{O(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}function E(e,t){return fetch(e,t??{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>e)).catch((e=>{const t=`[SBFetch] Error performing fetch() (this might be normal): ${e}`;throw console.warn(t),new P(t)}))}async function x(e,t){let n;try{if(n=await E(e,t),!n)throw new P("[SBApiFetch] Server did not respond (might be expected)");const a=n.headers.get("content-type");var r;if(!a)throw new P("[SBApiFetch] Server did not respond (might be expected) (no content header)");if(-1!==a.indexOf("application/json")){const e=await n.json();S&&console.log(`[SBApiFetch] json ('${e}'):\n`,e),r=I(e,"L489")}else{if(-1===a.indexOf("application/octet-stream"))throw new P("[SBApiFetch] Server responded with unknown content-type header (?)");r=de(await n.arrayBuffer()).payload}if(n.ok&&r&&!r.error&&!1!==r.success)return S&&console.log("[SBApiFetch] Success:\n",Re,e,"\n",Re,r,"\n",Re),r;{let e="[SBApiFetch] Network or Server error or cannot parse response";throw n.status&&(e+=" ["+n.status+"]"),r?.error&&(e+=": "+r.error),S&&console.error("[SBApiFetch] error:\n",e),new P(e)}}catch(e){throw S&&console.error(`[SBApiFetch] caught error: ${e}`),n&&n.body&&!n.body.locked&&(S&&console.log("[SBApiFetch] cancelling response body"),await n.body.cancel()),e instanceof P?e:new P(`[SBApiFetch] caught error: ${e}`)}}function T(e){const t=" *ErrorStart* ",n=" *ErrorEnd* ";return e instanceof P?e:e instanceof Error?(b&&console.error("[WrapError] Error: \n",e),new P(t+e.message+n)):new P(t+String(e)+n)}function L(e,t){throw new P("[_sb_exception] << SB lib error ("+e+": "+t+") >>")}function O(e,t){if(!e){const e=` <<<<[_sb_assert] assertion failed: '${t}'>>>> `;throw b&&console.trace(e),new P(e)}}function j(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}const F="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",_=/^([A-Za-z0-9\-_]*)(={0,2})$/;function U(e){const t=e instanceof ArrayBuffer?new Uint8Array(e):e;let n="";for(let e=0;e<t.length;e+=3){const r=t[e],a=t[e+1],s=t[e+2];n+=F[r>>2]+F[(3&r)<<4|a>>4]+(void 0!==a?F[(15&a)<<2|s>>6]:"")+(void 0!==s?F[63&s]:"")}return n}function $(e){if(e=e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),!_.test(e))throw new P(`invalid character in b64 string (after cleanup: '${e}')`);const t=e.length,n=new Uint8Array(3*t/4);for(let r=0,a=0;r<t;r+=4){const[t,s,o,i]=[e[r],e[r+1],e[r+2],e[r+3]].map((e=>F.indexOf(e)));n[a++]=t<<2|s>>4,-1!==o&&(n[a++]=(15&s)<<4|o>>2),-1!==i&&(n[a++]=(3&o)<<6|i)}return n}const N="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",H=N[0],G=/^[A-Za-z0-9]*$/,z=G;function V(e){return G.test(e)}const W=32,q=new Map,J=new Map;for(let e=1;e<=W;e++){const t=Math.ceil(8*e/Math.log2(62));q.set(e,t),J.set(t,e)}const Z=q.get(W);function Y(e){function t(e,t){let n="",r=0n;for(const t of e)r=r<<8n|BigInt(t);for(;r>0n;r/=62n)n=N[Number(r%62n)]+n;return n.padStart(q.get(t),H)}if(null==e)throw new P("arrayBufferToBase62: buffer is null or undefined");const n=e instanceof ArrayBuffer?new Uint8Array(e):e;let r="";for(let e,a=n.byteLength,s=0;a>0;s+=e,a-=e)e=a>=W?W:a,r+=t(n.slice(s,s+e),e);return r}function X(e){if(!G.test(e))throw new P("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");function t(e,t){try{let n=0n,r=new Uint8Array(t);for(let t=0;t<e.length;t++)n=62n*n+BigInt(N.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new P("base62ToArrayBuffer: Invalid Base62 string.");for(let e=t-1;e>=0;e--,n>>=8n)r[e]=Number(0xffn&n);return r}catch(e){throw new P("base62ToArrayBuffer: Invalid Base62 string.")}}try{let n=0,r=new Uint8Array(6*e.length/8);for(let a,s,o=0;o<e.length;o+=a,n+=s.byteLength)a=Math.min(e.length-o,Z),s=t(e.slice(o,o+a),J.get(a)),r.set(s,n);return r.buffer.slice(0,n)}catch(e){throw e}}function Q(e){return U(X(e))}function ee(e){return Y($(e))}const te="0123456789ADMRTxQjrEywcLBdHpNufk",ne=new RegExp(`[${te}.concat(' ')]`);function re(e){const t=te;if(e<0||e>524287)throw new Error("Input number is out of range. Expected a 19-bit integer.");let n=[e>>14&31,e>>9&31,e>>4&31,15&e];return n[3]|=16&(n[0]^n[1]^n[2]),n.map((e=>t[e])).join("")}function ae(e){const t={o:"0",O:"0",i:"1",I:"1",l:"1",z:"2",Z:"2",s:"5",S:"5",b:"6",G:"6",a:"9",g:"9",q:"9",m:"M",t:"T",X:"x",J:"j",e:"E",Y:"y",W:"w",C:"c",P:"p",n:"N",h:"N",U:"u",v:"u",V:"u",F:"f",K:"k"};let n="";for(let r of e)n+=t[r]||r;return n}function se(e){if(!ne.test(e))throw new Error(`Input string contains invalid characters (${e}) - use 'process()'.`);let t=Array.from(e).map((e=>te.indexOf(e)));return 16&t.reduce(((e,t)=>e^t))?null:16*(32*(32*t[0]+t[1])+t[2])+(15&t[3])}function oe(e){if(null===e)return"0";if(void 0===e)return"u";if(Array.isArray(e))return"a";if(e instanceof ArrayBuffer)return"x";if(e instanceof Uint8Array)return"8";if("boolean"==typeof e)return"b";if(e instanceof DataView)return"v";if(e instanceof Date)return"d";if(e instanceof Map)return"m";if("number"==typeof e)return"number"==typeof(t=e)&&t>=-2147483648&&t<=2147483647&&t%1==0?"i":"n";var t;if(null!==e&&"object"==typeof e&&e.constructor===Object)return"o";if(e instanceof Set)return"t";if("string"==typeof e)return"s";if(e instanceof WeakRef)return"w";throw"object"==typeof e&&"function"==typeof e.then?console.error("[getType] Trying to serialize a Promise - did you forget an 'await'?"):console.error("[getType] Unsupported for object:",e),new P("Unsupported type")}function ie(e){try{const t={};let n=0,r=0,a=[];for(const s in e)if(e.hasOwnProperty(s)){const o=e[s],i=oe(o);switch(i){case"o":const e=ie(o);if(!e)throw new P(`Failed to assemble payload for ${s}`);a.push(e);break;case"n":const t=new Uint8Array(8);new DataView(t.buffer).setFloat64(0,o),a.push(t.buffer);break;case"i":const n=new Uint8Array(4);new DataView(n.buffer).setInt32(0,o),a.push(n.buffer);break;case"d":const r=new Uint8Array(8);new DataView(r.buffer).setFloat64(0,o.getTime()),a.push(r.buffer);break;case"b":const c=new Uint8Array(1);c[0]=o?1:0,a.push(c.buffer);break;case"s":const l=(new TextEncoder).encode(o);a.push(l);break;case"x":a.push(o);break;case"8":a.push(o.buffer);break;case"m":const h=new Array;o.forEach(((e,t)=>{h.push([t,e])}));const d=ie(h);if(!d)throw new P(`Failed to assemble payload for ${s}`);a.push(d);break;case"a":const y=new Array;o.forEach((e=>{y.push(e)}));const u=ie(y);if(!u)throw new P(`Failed to assemble payload for ${s}`);a.push(u);break;case"t":const g=new Array;o.forEach((e=>{g.push(e)}));const f=ie(g);if(!f)throw new P(`Failed to assemble payload for ${s}`);a.push(f);break;case"w":case"0":case"u":a.push(new ArrayBuffer(0));break;default:throw console.error(`[assemblePayload] Unsupported type: ${i}`),new P(`Unsupported type: ${i}`)}const c=a[a.length-1].byteLength;n++,t[n.toString()]={n:s,s:r,z:c,t:i},r+=c}const s=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([s.byteLength]);let i=j(new Uint8Array(o.buffer),new Uint8Array(s));for(let e=0;e<a.length;e++)i=j(new Uint8Array(i),a[e]);return i}catch(e){return console.error(e),null}}function ce(e){b&&e instanceof ArrayBuffer&&console.warn("[assemblePayload] Warning: data is already an ArrayBuffer, make sure you are not double-encoding");const t=ie({ver003:!0,payload:e});return t?j(new Uint8Array([170,187,187,170]),t):null}function le(e,t){switch(t){case"o":return he(e);case"n":return new DataView(e).getFloat64(0);case"i":return new DataView(e).getInt32(0);case"d":return new Date(new DataView(e).getFloat64(0));case"b":return 1===new Uint8Array(e)[0];case"s":return(new TextDecoder).decode(e);case"a":const n=he(e);if(!n)throw new P(`Failed to assemble payload for ${t}`);return Object.values(n);case"m":const r=he(e);if(!r)throw new P(`Failed to assemble payload for ${t}`);const a=new Map;for(const e in r)a.set(r[e][0],r[e][1]);return a;case"t":const s=he(e);if(!s)throw new P(`Failed to assemble payload for ${t}`);const o=new Set;for(const e in s)o.add(s[e]);return o;case"x":return e;case"8":return new Uint8Array(e);case"0":return null;case"u":return;default:throw new P(`Unsupported type: ${t}`)}}function he(e){const t="Cannot parse metadata, this is not a well-formed payload";try{const n=new Uint32Array(e.slice(0,4))[0],r=(new TextDecoder).decode(e.slice(4,4+n));let a;try{a=I(r,"L1290")}catch(e){throw new P(t)}const s=4+n,o={};for(let t=1;t<=Object.keys(a).length;t++){const n=t.toString();if(a[n]){const t=a[n],r=t.s,i=t.z,c=t.t,l=e.slice(s+r,s+r+i);o[t.n]=le(l,c)}else console.log(`found nothing for index ${t}`)}return o}catch(e){if(e instanceof Error&&e.message===t)throw e;throw new P("[extractPayload] exception <<"+e+">> [/extractPayload]")}}function de(e){const t="Invalid payload signature (this is not a payload)";if(2864429994!==new Uint32Array(e,0,1)[0])throw b&&console.error("\n",Re,t,"\n",e,Re),new P(t);return he(e.slice(4))}var ye,ue;function ge(e){"string"==typeof e&&(e=$(e));const t=new Uint8Array(e);return 1==(1&t[t.length-1])?1:0}function fe(e){try{if(e.length<=4)return;const t=e.slice(0,4),n=e.slice(4);switch(t.slice(0,3)){case ye.SBPublicKey:switch(t[3]){case ue.Uncompressed:{const e=X(n);if(96!==e.byteLength)return;const t=e.slice(48,96);return{x:U(e.slice(0,48)),y:U(t),ySign:ge(t)}}case ue.CompressedEven:case ue.CompressedOdd:{const e=t[3]===ue.CompressedEven?0:1,r=X(n);if(48!==r.byteLength)return;const{x:a,y:s}=Ee(U(r),e);return{x:a,y:s,ySign:e}}default:console.error("KeySubPrefix not recognized")}break;case ye.SBPrivateKey:switch(t[3]){case ue.Uncompressed:{const e=X(n);if(144!==e.byteLength)return;const t=e.slice(48,96);return{x:U(e.slice(0,48)),y:U(t),ySign:ge(t),d:U(e.slice(96,144))}}case ue.CompressedEven:case ue.CompressedOdd:{const e=t[3]===ue.CompressedEven?0:1,r=X(n);if(96!==r.byteLength)return;const a=r.slice(0,48),{x:s,y:o}=Ee(U(a),e);return{x:s,y:o,ySign:e,d:U(r.slice(48,96))}}case ue.Dehydrated:return void console.error("parseSB384string() - you need to rehydrate first ('hydrateKey()')");default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}return}catch(e){return void console.error("parseSB384string() - malformed input, exception: ",e)}}function pe(e,t,n){if(!e||64!==e.length||!t||64!==t.length||void 0===n)return;const r=new Uint8Array(96);return r.set($(e),0),r.set($(t),48),ye.SBPrivateKey+(0===n?ue.CompressedEven:ue.CompressedOdd)+Y(r)}function we(e,t){if(e.length<=4)return;const n=e.slice(0,4);switch(n.slice(0,3)){case ye.SBPublicKey:return e;case ye.SBPrivateKey:switch(n[3]){case ue.Uncompressed:case ue.CompressedEven:case ue.CompressedOdd:return e;case ue.Dehydrated:{if(!t)return void console.error("hydrateKey() - you need to provide pubKey to hydrate");const n=U(X(e.slice(4)).slice(0,48)),r=fe(t);return r&&r.x&&void 0!==r.ySign?pe(r.x,n,r.ySign):void console.error("hydrateKey() - failed to parse public key")}default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}}!function(e){e.SBPublicKey="PNk",e.SBPrivateKey="Xj3",e.SBDehydratedKey="XjZ"}(ye||(ye={})),function(e){e.CompressedEven="2",e.CompressedOdd="3",e.Uncompressed="4",e.Dehydrated="x"}(ue||(ue={}));class ve{generateIdKey(e){if(!(e instanceof ArrayBuffer))throw new TypeError("Input must be an ArrayBuffer");return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({idBinary:n,keyMaterial:r})}))}catch(e){n(e)}}))}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new P("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,a){try{let s;const o={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new P("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),s=await crypto.subtle.importKey("jwk",e,o[n],r,a)}else s=await crypto.subtle.importKey(e,t,o[n],r,a);return s}catch(s){const o=`... importKey() error: ${s}:`;throw b&&(console.log(Re,Re),console.error(o),console.log(e),console.log(t),console.log(n),console.log(r),console.log(a),console.log(Re,Re)),new P(o)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{b&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}async encrypt(e,t,n){if(null===e)throw new P("no contents");if(!n.iv)throw new P("no nonce");return n.name?O("AES-GCM"===n.name,"Must be AES-GCM (L1951)"):n.name="AES-GCM",crypto.subtle.encrypt(n,t,e)}async wrap(e,t,n,r,a,s){O(e&&t&&n&&a,"wrapMessage(): missing required parameter(2)");const o=ce(e);O(o,"wrapMessage(): failed to assemble payload"),O(o.byteLength<Le,`wrapMessage(): body must be smaller than ${Le/1024} KiB (we got ${o.byteLength/1024} KiB)})`),O(r,"wrapMessage(): missing salt"),S&&console.log("will wrap() body, payload:\n",Re,"\n",e,"\n",Re,o,"\n",Re);const i=crypto.getRandomValues(new Uint8Array(12)),c=25*Math.round(Date.now()/25),l=new DataView(new ArrayBuffer(8));l.setFloat64(0,c);var h={f:t,c:await De.encrypt(o,n,{iv:i,additionalData:l}),iv:i,salt:r,s:await De.sign(a,o),ts:c};if(S&&console.log("wrap() message is\n",h),s&&(s.sendTo&&(h.t=s.sendTo),s.ttl&&(h.ttl=s.ttl),s.subChannel))throw new P("wrapMessage(): subChannel not yet supported");try{h=w(h)}catch(e){const t=`wrapMessage(): failed to validate message: ${e}`;throw console.error(t),new P(t)}return h}sign(e,t){return crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-384"}},e,t)}verify(e,t,n){return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},e,t,n)}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}}function be(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function Se(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name,a=e.constructor.ReadyFlag;O(a in this,"'readyFlagSymbol' missing yet getter accessed with @Ready pattern (fatal)"),O(this[a],`'${n}.${t}' getter accessed but object not 'ready' (fatal)`);const s=r.call(this);return O(null!=s,`'${n}.${t}' getter accessed but return value will be NULL (fatal)`),s}}}function me(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;return"owner"in this&&O(!0===this.owner,`${t} getter or method accessed for object ${n} but callee is not channel owner`),r.call(this)}}}const ke=["SBMessage","SBObjectHandle","SBChannelHandle","ChannelApiBody"],Be=Symbol("SB_CHANNEL_MESSAGE_SYMBOL"),Ce=Symbol("SB_CHANNEL_API_BODY_SYMBOL"),Ke=Symbol("SBChannelHandle"),Ae=Symbol.for("SBMessage"),Pe=Symbol.for("SBObjectHandle"),Ie=Symbol.for("SBStorageToken");function Me(e,t){switch(t){case"SBMessage":return Ae in e;case"SBObjectHandle":case"SBChannelHandle":return Pe in e;default:return!1}}const De=new ve,Re="============================================================\n";function Ee(e,t){const n=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),r=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),a=(n+1n)/4n,s=new Uint8Array($(e)),o="0x"+Array.from(s,(e=>e.toString(16).padStart(2,"0"))).join("");var i=BigInt(o),c=function(e,t,n){if(1n===n)return 0n;let r=1n;for(e%=n;t>0n;)t%2n===1n&&(r=r*e%n),t>>=1n,e=e*e%n;return r}(i*i*i-3n*i+r,a,n);c%2n!==BigInt(t)&&(c=n-c);const l=c.toString(16).padStart(96,"0");return{x:e,y:U(new Uint8Array(l.match(/.{1,2}/g).map((e=>parseInt(e,16)))))}}class xe{sb384Ready;static ReadyFlag=Symbol("SB384ReadyFlag");#t;#n;#r;#a;#s;#o;#i;#c;#l;#h;constructor(e,t){this[xe.ReadyFlag]=!1,this.sb384Ready=new Promise((async(n,r)=>{try{if(e)if(e instanceof CryptoKey){const n=await De.exportKey("jwk",e);O(n&&n.x&&n.y,"INTERNAL"),n.d?(this.#t=!0,this.#s=n.d):(this.#t=!1,O(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#r=n.y}else if(e&&e instanceof Object&&"kty"in e){const n=e;O(n&&n.x&&n.y,"Cannot parse format of JWK key"),e.d?(this.#t=!0,this.#s=n.d):(this.#t=!1,O(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#r=n.y}else{if("string"!=typeof e)throw new P("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=fe(e);if(!n)throw new P("ERROR creating SB384 object: invalid key (must be a JsonWebKey | SBUserPublicKey | SBUserPrivateKey, or omitted)");const{x:r,y:a,d:s}=n;s?(this.#t=!0,this.#s=s):(this.#t=!1,O(!t,"ERROR creating SB384 object: key provided is not the requested private")),O(r&&a,"INTERNAL"),this.#n=r,this.#r=a}}else{S&&console.log("SB384() - generating new key pair");const e=await De.generateKeys(),t=await De.exportKey("jwk",e.privateKey);O(t&&t.x&&t.y&&t.d,"INTERNAL"),this.#t=!0,this.#n=t.x,this.#r=t.y,this.#s=t.d,S&&console.log("#### FROM SCRATCH",this.#t)}if(S&&console.log("SB384() constructor; x/y/d:\n",this.#n,"\n",this.#r,"\n",this.#s),this.#t&&(this.#o=await De.importKey("jwk",this.jwkPrivate,"ECDH",!0,["deriveKey"])),this.#i=await De.importKey("jwk",this.jwkPublic,"ECDH",!0,[]),this.#t){const e={...this.jwkPrivate,key_ops:["sign"]};S&&console.log("starting jwk (private):\n",e),this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["sign"])}else{const e={...this.jwkPublic,key_ops:["verify"]};S&&console.log("starting jwk (public):\n",e),this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["verify"])}const r=j($(this.#n),$(this.#r)),a=await crypto.subtle.digest("SHA-256",r);this.#l=Y(a);const s=BigInt("0x"+Array.from(new Uint8Array(a)).map((e=>e.toString(16).padStart(2,"0"))).join(""))>>28n;this.#h=Array.from({length:12},((e,t)=>re(Number(s>>BigInt(19*(11-t))&0x7ffffn)))).join(""),S&&console.log("SB384() constructor; hash:\n",this.#l),this.#a=ge(this.#r),S&&console.log("SB384() - constructor wrapping up",this),this[xe.ReadyFlag]=!0,n(this)}catch(e){r("ERROR creating SB384 object failed: "+T(e))}}))}get SB384ReadyFlag(){return this[xe.ReadyFlag]}get ready(){return this.sb384Ready}get private(){return this.#t}get hash(){return this.#l}get hashB32(){return this.#h}get userId(){return this.hash}get ownerChannelId(){return this.hash}get privateKey(){if(!this.private)throw new P("this is a public key, there is no 'privateKey' value");return this.#o}get signKey(){return this.#c}get publicKey(){return this.#i}get jwkPrivate(){return O(this.#t,"jwkPrivate() - not a private key"),O(this.#n&&this.#r&&this.#s,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:["deriveKey"],kty:"EC",x:this.#n,y:this.#r,d:this.#s}}get jwkPublic(){return O(this.#n&&this.#r,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:this.#n,y:this.#r}}get ySign(){return O(null!==this.#a,"ySign() - ySign is not available (fatal)"),this.#a}get userPublicKey(){return O(this.#n&&void 0!==this.#a,"userPublicKey() - sufficient key info is not available (fatal)"),ye.SBPublicKey+(0===this.#a?ue.CompressedEven:ue.CompressedOdd)+ee(this.#n)}get userPrivateKey(){O(this.#t,"userPrivateKey() - not a private key, there is no userPrivateKey");const e=pe(this.#n,this.#s,this.#a);return O(void 0!==e,"userPrivateKey() - failed to construct key, probably missing info (fatal)"),e}get userPrivateKeyDehydrated(){return O(this.#t&&this.#s,"userPrivateKey() - not a private key, and/or 'd' is missing, there is no userPrivateKey"),ye.SBPrivateKey+ue.Dehydrated+ee(this.#s)}}a([be,Se],xe.prototype,"private",null),a([be,Se],xe.prototype,"hash",null),a([be,Se],xe.prototype,"hashB32",null),a([be,Se],xe.prototype,"userId",null),a([be,Se],xe.prototype,"ownerChannelId",null),a([be,Se],xe.prototype,"privateKey",null),a([be,Se],xe.prototype,"signKey",null),a([be,Se],xe.prototype,"publicKey",null),a([be],xe.prototype,"jwkPrivate",null),a([be],xe.prototype,"jwkPublic",null),a([be],xe.prototype,"ySign",null),a([be],xe.prototype,"userPublicKey",null),a([be],xe.prototype,"userPrivateKey",null),a([be],xe.prototype,"userPrivateKeyDehydrated",null);class Te extends xe{#d;sbChannelKeysReady;static ReadyFlag=Symbol("SBChannelKeysReadyFlag");#y;channelServer;constructor(e){if(null===e)throw new P("SBChannelKeys constructor: you cannot pass 'null'");if(e)if("string"==typeof e)super(e,!0);else{if(!l(e))throw new P("SBChannelKeys() constructor: invalid parameter (must be SBChannelHandle or SBUserPrivateKey)");{const t=h(e);super(t.userPrivateKey,!0),t.channelServer&&(this.channelServer=t.channelServer,"/"===this.channelServer[this.channelServer.length-1]&&(this.channelServer=this.channelServer.slice(0,-1))),this.#d=t.channelId,this.#y=t.channelData}}else super();this[Te.ReadyFlag]=!1,this.sbChannelKeysReady=new Promise((async(e,t)=>{try{if(b&&console.log("SBChannelKeys() constructor."),await this.sb384Ready,O(this.private,"Internal Error (L2476)"),this.#d){if(!this.#y){if(!this.channelServer)throw new P("SBChannelKeys() constructor: either key is owner key, or handle contains channelData, or channelServer is provided ...");b&&console.log("++++ SBChannelKeys being initialized from server");var n=await this.callApi("/getChannelKeys");O((n=y(n)).channelId===this.#d,"Internal Error (L2493)"),this.#y=n}}else this.#d=this.ownerChannelId,this.#y={channelId:this.#d,ownerPublicKey:this.userPublicKey};this[Te.ReadyFlag]=!0,e(this)}catch(e){t("[SBChannelKeys] constructor failed. "+T(e))}}))}get ready(){return this.sbChannelKeysReady}get SBChannelKeysReadyFlag(){return this[Te.ReadyFlag]}get channelData(){return this.#y}get owner(){return this.private&&this.ownerChannelId&&this.channelId&&this.ownerChannelId===this.channelId}get channelId(){return this.#d}get handle(){return{[Ke]:!0,channelId:this.channelId,userPrivateKey:this.userPrivateKey,channelServer:this.channelServer,channelData:this.channelData}}async buildApiBody(e,t){await this.sb384Ready;const n=25*Math.round(Date.now()/25),r=new ArrayBuffer(8);new DataView(r).setFloat64(0,n);const a=j(r,(new TextEncoder).encode(e).buffer),s=t?ce(t):void 0,o=await De.sign(this.signKey,s?j(a,s):a),i={channelId:this.#d,path:e,userId:this.userId,userPublicKey:this.userPublicKey,timestamp:n,sign:o};return s&&(i.apiPayloadBuf=s),p(i)}callApi(e,t){return O(this.channelServer,"[ChannelApi.callApi] channelServer is unknown (you can just set it, eg 'channel.channelServer = ...')"),b&&console.log("ChannelApi.callApi: calling fetch with path:",e),S&&console.log("... and body:",t),O(this.#d&&e,"Internal Error (L2528)"),new Promise((async(n,r)=>{const a={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:ce(await this.buildApiBody(e,t))};S&&console.log("==== ChannelApi.callApi: calling fetch with init:\n",a),x(this.channelServer+"/api/v2/channel/"+this.#d+e,a).then((e=>{n(e)})).catch((e=>{r(e instanceof P?e:"[Channel.callApi] Error: "+T(e))}))}))}}a([be,Se],Te.prototype,"channelData",null),a([be,Se],Te.prototype,"owner",null),a([be,Se],Te.prototype,"channelId",null),a([be,Se],Te.prototype,"handle",null);const Le=65536;class Oe{channel;contents;options;[Ae]=!0;sbMessageReady;static ReadyFlag=Symbol("SBMessageReadyFlag");#u;salt;constructor(e,t,n={}){this.channel=e,this.contents=t,this.options=n,this.salt=crypto.getRandomValues(new Uint8Array(16)).buffer,this.sbMessageReady=new Promise((async t=>{if(await e.channelReady,this.options.protocol||(this.options.protocol=e.protocol),!this.options.protocol)throw new P("SBMessage() - no protocol provided");this.#u=await De.wrap(this.contents,this.channel.userId,await this.options.protocol.encryptionKey(this),this.salt,this.channel.signKey,n),this[Oe.ReadyFlag]=!0,t(this)}))}get ready(){return this.sbMessageReady}get SBMessageReadyFlag(){return this[Oe.ReadyFlag]}get message(){return this.#u}async send(){return S&&console.log("SBMessage.send() - sending message:",this.message),this.channel.send(this)}}a([Se],Oe.prototype,"message",null);class je{#g;#f;constructor(e,t){this.#f=t,this.#g=this.initializeMasterKey(e)}async initializeMasterKey(e){const t=this.#f.salt1,n=this.#f.iterations1,r=this.#f.hash1;O(t&&n&&r,"Protocol_AES_GCM_256.initializeMasterKey() - insufficient key info (fatal)");const a=await crypto.subtle.importKey("raw",(new TextEncoder).encode(e),{name:"PBKDF2"},!1,["deriveBits","deriveKey"]),s=await crypto.subtle.deriveBits({name:"PBKDF2",salt:t,iterations:n,hash:r},a,256);return crypto.subtle.importKey("raw",s,{name:"PBKDF2"},!1,["deriveBits","deriveKey"])}static async genKey(){return{salt1:crypto.getRandomValues(new Uint8Array(16)).buffer,iterations1:1e5,iterations2:1e4,hash1:"SHA-256",summary:"PBKDF2 - SHA-256 - AES-GCM"}}async#p(e){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:this.#f.iterations2,hash:this.#f.hash1},await this.#g,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async encryptionKey(e){return b&&console.log("CALLING Protocol_AES_GCM_384.encryptionKey(), salt:",e.salt),this.#p(e.salt)}async decryptionKey(e,t){if(t.salt)return b&&console.log("CALLING Protocol_AES_GCM_384.decryptionKey(), salt:",t.salt),this.#p(t.salt);console.warn("Salt should always be present in ChannelMessage")}}class Fe{#w=new Map;constructor(){}async encryptionKey(e){await e.channel.ready;const t=e.channel.channelId;O(t,"Internal Error (L2565)");const n=e.options.sendTo?e.options.sendTo:e.channel.channelData.ownerPublicKey;return this.#v(t,n,e.channel.privateKey)}async decryptionKey(e,t){await e.ready;const n=e.channelId;O(n,"Internal Error (L2594)");const r=e.visitors.get(t.f);if(r)return this.#v(n,r,e.privateKey);b&&console.log("Protocol_ECDH.key() - sentFrom is unknown")}async#v(e,t,n){const r=e+"_"+t;if(!this.#w.has(r)){const e=await crypto.subtle.deriveKey({name:"ECDH",public:(await new xe(t).ready).publicKey},n,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);this.#w.set(r,e),S&&console.log("++++ Protocol_ECDH.key() - newKey:",e)}const a=this.#w.get(r);return O(a,"Internal Error (L2584/2611)"),S&&console.log("++++ Protocol_ECDH.key() - res:",a),a}}class _e extends Te{protocol;channelReady;static ReadyFlag=Symbol("ChannelReadyFlag");locked=!1;#b="";visitors=new Map;constructor(e,t){if(null===e)throw new P("Channel() constructor: you cannot pass 'null'");S&&console.log("Channel() constructor called with handleOrKey:",e),super(e),this.protocol=t,this.channelReady=this.sbChannelKeysReady.then((()=>(this[_e.ReadyFlag]=!0,this))).catch((e=>{throw e}))}get ready(){return this.channelReady}get ChannelReadyFlag(){return this[_e.ReadyFlag]}get api(){return this}async extractMessage(e){b&&console.log("[extractMessage] Extracting message:",e);try{const t=(e=w(e)).f;if(!t)return;if(!this.visitors.has(t)){S&&console.log("++++ [extractMessage]: need to update visitor table ...");const e=await this.callApi("/getPubKeys");if(!(e&&e instanceof Map))return;S&&console.log(Re,"visitorMap:\n",e,"\n",Re);for(const[t,n]of e)S&&console.log("++++ [extractMessage]: adding visitor:",t,n),this.visitors.set(t,n)}O(this.visitors.has(t),`Cannot find sender userId hash ${t} in public key map`);const n=await(this.protocol?.decryptionKey(this,e));if(!n)return;try{if(!e.ts)throw new P("unwrap() - no timestamp in encrypted message");const{c:r,iv:a}=e;O(r,"[unwrap] No contents in encrypted message (probably an error)");const s=new DataView(new ArrayBuffer(8));s.setFloat64(0,e.ts);const o=await crypto.subtle.decrypt({name:"AES-GCM",iv:a,additionalData:s},n,r);return e._id||(e._id=u(this.channelId,e.sts,e.i2)),void 0!==e.ttl&&15!==e.ttl&&console.warn(`[extractMessage] TTL->EOL missing (TTL set to ${e.ttl}) [L2762]`),f({body:de(o).payload,channelId:this.channelId,sender:t,senderPublicKey:this.visitors.get(t),senderTimestamp:e.ts,serverTimestamp:e.sts,_id:e._id})}catch(e){return void(b&&console.error("[extractMessage] Could not process message [L2766]:",e))}}catch(e){return void(b&&console.error("[extractMessage] Could not process message [L2771]:",e))}}async extractMessageMap(e){const t=new Map;for(const[n,r]of e){const e=await this.extractMessage(r);e&&t.set(n,e)}return t}create(e,t=this.channelServer){return b&&console.log("==== Channel.create() called with storageToken:",e,"and channelServer:",t),O(null!==e,"[Channel.create] Missing storage token"),t&&(this.channelServer=t),O(this.channelServer,"[Channel.create] Missing channel server (neither provided nor in channelKeys)"),new Promise((async(n,r)=>{await this.channelReady,this.channelData.storageToken=c(e),b&&console.log("Will try to create channel with channelData:",this.channelData),this.callApi("/budd",this.channelData).then((()=>{this.channelServer=t,O(this.channelData&&this.channelData.channelId&&this.userPrivateKey,"Internal Error [L2546]"),n({[Ke]:!0,channelId:this.channelData.channelId,userPrivateKey:this.userPrivateKey,channelServer:this.channelServer,channelData:this.channelData})})).catch((e=>{r("Channel.create() failed: "+T(e))}))}))}getLastMessageTimes(){throw new P("Channel.getLastMessageTimes(): not supported in 2.0 yet")}getMessageKeys(e=100,t=!1){return new Promise((async(n,r)=>{O(this.channelId,"Channel.getMessageKeys: no channel ID (?)");const a=await this.callApi("/getMessageKeys",{currentMessagesLength:e,cursor:t?this.#b:void 0});O(a,"Channel.getMessageKeys: no messages (empty/null response)"),S&&console.log("getMessageKeys\n",a),n(a)}))}getRawMessageMap(e){if(b&&console.log("[getRawMessageMap] called with messageKeys:",e),0===e.size)throw new P("Channel.getMessages() - no message keys provided");return new Promise((async(t,n)=>{O(this.channelId,"[getRawMessageMap]  no channel ID (?)");const r=await this.callApi("/getMessages",e);O(r,"[getRawMessageMap]  no messages (empty/null response)"),S&&console.log(Re,Re,"[getRawMessageMap] - here are the raw ones\n",r,Re,Re),t(r)}))}getMessageMap(e){if(b&&console.log("Channel.getDecryptedMessages() called with messageKeys:",e),0===e.size)throw new P("[getMessageMap] no message keys provided");return new Promise((async(t,n)=>{const r=await this.callApi("/getMessages",e),a=new Map;for(const[e,t]of r)try{a.set(e,w(de(t).payload))}catch(e){b&&console.warn(Re,"[getMessageMap] Failed extract and/or to validate message:",Re,t,Re,e,Re)}t(await this.extractMessageMap(a))}))}async send(e){const t=e instanceof Oe?e:new Oe(this,e);return await t.ready,this.callApi("/send",t.message)}setPage(e){var{page:t,prefix:n,type:r}=e;return O(t,"Channel.setPage: no page (contents) provided"),n=n||12,(r=r||"sb384payloadV3")?this.callApi("/setPage",{page:t,type:r,prefix:n}):this.callApi("/setPage",t)}async getPage(){const e=this.hashB32;b&&console.log(`==== ChannelApi.getPage: calling fetch with: ${e}`);const t=await E(this.channelServer+"/api/v2/page/"+e);if("sb384payloadV3"!==t.headers.get("content-type"))throw new P("[Channel.getPage] Can only handle 'sb384payloadV3' content type, use 'fetch()'");return de(await t.arrayBuffer()).payload}acceptVisitor(e){return this.callApi("/acceptVisitor",{userId:e})}getCapacity(){return this.callApi("/getCapacity")}getAdminData(){return this.callApi("/getAdminData")}getMother(){return this.getAdminData().then((e=>e.motherChannel))}isLocked(){return this.getAdminData().then((e=>e.locked))}lock(){return this.callApi("/lockChannel")}updateCapacity(e){return this.callApi("/setCapacity",{capacity:e})}getChannelKeys(){return this.callApi("/getChannelKeys")}getPubKeys(){return this.callApi("/getPubKeys")}getStorageLimit(){return this.callApi("/getStorageLimit")}async getStorageToken(e){return c(await this.callApi("/getStorageToken",{size:e}))}budd(e){return new Promise((async(t,n)=>{var{targetChannel:r,size:a}=e||{};if(r){if(this.channelId===r.channelId)return void n(new Error("[budd()]: source and target channels are the same, probably an error"))}else r=(await(new _e).ready).handle,b&&console.log("\n",Re,"[budd()]: no target channel provided, using new channel:\n",Re,r,"\n",Re);if(a||(a=o),a!==1/0&&Math.abs(a)>await this.getStorageLimit())return void n(new Error(`[budd()]: storage amount (${a}) is more than current storage limit`));const s=r.channelData;if(s)try{s.storageToken=await this.getStorageToken(a),b&&console.log(`[budd()]: requested ${a}, got storage token:`,s.storageToken);const e=await new _e(r).ready;e.channelServer||(e.channelServer=this.channelServer);const o=y(await e.callApi("/budd",s));if(r.channelId!==o.channelId)return console.warn("[budd()]: target channel ID changed, should not happen, error somewhere\n",Re),console.warn("targetChannel:",r,"\n",Re),console.warn("newChannelData:",o,"\n",Re),void n(new Error("[budd()]: target channel ID changed, should not happen, error somewhere"));o.storageToken||console.warn("[budd()]: target channel has no storage token, possibly an error, should be returned from server");const i={[Ke]:!0,channelId:o.channelId,userPrivateKey:r.userPrivateKey,channelServer:this.channelServer,channelData:o};b&&console.log("[budd()]: success, newHandle:",i),t(h(i))}catch(e){return void n("[budd] Could not get storage token from server, are you sure about the size?")}else n(new Error("[budd()]: target channel has no channel data, probably an error"))}))}}a([be,Se],_e.prototype,"api",null),a([Se],_e.prototype,"send",null),a([Se,me],_e.prototype,"setPage",null),a([Se],_e.prototype,"getPage",null),a([Se,me],_e.prototype,"acceptVisitor",null),a([Se,me],_e.prototype,"getCapacity",null),a([Se,me],_e.prototype,"getAdminData",null),a([Se,me],_e.prototype,"getMother",null),a([Se,me],_e.prototype,"isLocked",null),a([Se,me],_e.prototype,"lock",null),a([Se,me],_e.prototype,"updateCapacity",null),a([Se,be],_e.prototype,"getChannelKeys",null),a([Se],_e.prototype,"getPubKeys",null),a([Se],_e.prototype,"getStorageLimit",null),a([Se],_e.prototype,"getStorageToken",null),a([Se,me],_e.prototype,"budd",null);class Ue extends _e{channelSocketReady;static ReadyFlag=Symbol("ChannelSocketReadyFlag");#S;#m;onMessage=e=>{O(!1,"[ChannelSocket] NO MESSAGE HANDLER")};#k=new Map;#B=!1;constructor(e,t){if(O(t,"ChannelSocket(): no onMessage handler provided"),!e.hasOwnProperty("channelId")||!e.hasOwnProperty("userPrivateKey"))throw new P("ChannelSocket(): first argument must be valid SBChannelHandle");if(!e.channelServer)throw new P("ChannelSocket(): no channel server provided (required)");super(e),this[n.ReadyFlag]=!1,this.#m=e.channelServer.replace(/^http/,"ws"),this.onMessage=t;const r=this.#m+"/api/v2/channel/"+e.channelId+"/websocket";this.#S={url:r,ready:!1,closed:!1,timeout:2e3},this.channelSocketReady=this.#C()}#K=async e=>{b&&console.log("Received socket message:",e);const t=e.data;var n=null;O(t,"[ChannelSocket] received empty message"),"string"==typeof t?(console.error("ChannelSocket receiving string (json?) message, this is getting deprecated"),n=I(t,"L3589")):t instanceof ArrayBuffer?n=de(t).payload:t instanceof Blob?n=de(await t.arrayBuffer()).payload:L("L3594","[ChannelSocket] received unknown message type"),O(n,"[ChannelSocket] cannot parse message"),n=w(n),console.log(Re,"Received socket message:\n",n,"\n",Re),n.channelId||(n.channelId=this.channelId),O(n.channelId===this.channelId,"[ChannelSocket] received message for wrong channel?"),this.#B&&console.log("Received socket message:",n);const r=U(await crypto.subtle.digest("SHA-256",n.c));b&&console.log("Received message with hash:",r);const a=this.#k.get(r);a&&((b||this.#B)&&console.log(`++++++++ #processMessage: found matching ack for id ${r}`),this.#k.delete(r),a("success"));const s=await this.extractMessage(n);s?(b&&console.log("Repackaged and will deliver 'Message':",s),this.onMessage(s)):b&&console.log("Message could not be parsed, will not deliver")};#C(){return new Promise((async(e,t)=>{b&&console.log("++++ STARTED ChannelSocket.readyPromise()");const r=this.#S.url;if(!this.#S.websocket||3===this.#S.websocket.readyState||2===this.#S.websocket.readyState){const e=ce(await this.buildApiBody(r));O(e,"Internal Error [L3598]"),this.#S.websocket=new WebSocket(r+"?apiBody="+Y(e))}this.#S.websocket.addEventListener("message",(r=>{r.data&&"string"==typeof r.data&&I(r.data,"L3618")?.hasOwnProperty("ready")?(this.#S.websocket.addEventListener("message",this.#K),this[n.ReadyFlag]=!0,e(this)):(b&&console.log(Re,"Received non-ready:\n",r.data,"\n",Re),t("[ChannelSocket] received something other than 'ready' as first message"))})),this.#S.websocket.addEventListener("open",(async()=>{this.#S.closed=!1,await this.ready,b&&console.log("++++++++ readyPromise() sending init"),this.#S.websocket.send(ce({ready:!0}))})),this.#S.websocket.addEventListener("close",(e=>{this.#S.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.channelServer})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.channelServer}`),t("wbSocket() closed before it was opened (?)")})),this.#S.websocket.addEventListener("error",(e=>{this.#S.closed=!0,console.log("ChannelSocket() error: ",e),t("ChannelSocket creation error (see log)")})),setTimeout((()=>{if(this[n.ReadyFlag])b&&console.log("ChannelSocket() - this socket resolved",this);else{const e="[ChannelSocket] - this socket is not resolving (waited 10s) ...";console.warn(e),t(e)}}),1e4)}))}get ready(){return this.channelSocketReady}get ChannelSocketReadyFlag(){return this[n.ReadyFlag]}get status(){if(!this.#S.websocket)return"CLOSED";switch(this.#S.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set enableTrace(e){this.#B=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}async send(e){await this.ready;const t=e instanceof Oe?e:new Oe(this,e);return O(this.#S.websocket,"ChannelSocket.send() called before ready"),this.#S.closed&&(this.#B&&console.info("send() triggered reset of #readyPromise() (normal)"),this.channelSocketReady=this.#C(),this[n.ReadyFlag]=!1),new Promise((async(e,n)=>{await t.ready,await this.ready,this.ChannelSocketReadyFlag||n("ChannelSocket.send() is confused - ready or not?");const r=this.#S.websocket.readyState;switch(r){case 1:this.#B&&console.log("++++++++ ChannelSocket.send() will send message:",Object.assign({},t.message));const a=ce(t.message);O(a,"ChannelSocket.send(): failed to assemble message");const s=U(await crypto.subtle.digest("SHA-256",t.message.c));(b||this.#B)&&console.log("++++++++ ChannelSocket.send(): Which has hash:",s),this.#k.set(s,e),this.#S.websocket.send(a),setTimeout((()=>{if(this.#k.has(s)){this.#k.delete(s);const e=`Websocket request timed out (no ack) after ${this.#S.timeout}ms (${s})`;console.error(e),n(e)}else this.#B&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#S.timeout);break;case 0:case 2:case 3:n("socket not OPEN - it is "+(0===r?"CONNECTING":2===r?"CLOSING":"CLOSED"));break;default:L("ChannelSocket",`socket in unknown state (${r})`)}}))}}n=Ue,a([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&ke.includes(n)&&O(Me(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],Ue.prototype,"send",null);class $e{#A;constructor(e){this.#A=Promise.resolve(e).then((e=>{const t=e;return O("string"==typeof t,"StorageApi() constructor requires a string (for storageServer)"),t}))}async getStorageServer(){return this.#A}static padBuf(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=j(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),S&&console.log("padBuf bytes:",r.slice(-4)),r}#P(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(S&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=r),S&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}static getObjectKey(e,t){return new Promise(((n,r)=>{try{De.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}async storeData(e,t){try{const n=ce(e);if(!n)throw new P("[storeData] failed to assemble payload");const a=t instanceof _e?t:new _e(t),s=n.byteLength,o=r.padBuf(n),i=await De.generateIdKey(o),c=await this.getStorageServer(),l=c+"/api/v2/storeRequest?id="+Y(i.idBinary),h=await x(l);if(!h.salt||!h.iv)throw new P("[storeData] Failed to get key info (salt, nonce) from storage server");const d=Y(i.idBinary),y=await r.getObjectKey(i.keyMaterial,h.salt),u=await De.encrypt(o,y,{iv:h.iv}),g=await a.getStorageToken(u.byteLength),f=c+"/api/v2/storeData?id="+d,p={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:ce({id:d,iv:h.iv,salt:h.salt,storageToken:g,data:u})},w=await x(f,p),v={[Pe]:!0,version:"3",id:d,key:Y(i.keyMaterial),iv:h.iv,salt:h.salt,actualSize:s,verification:w.verification,storageServer:c};return b&&console.log("storeData() - success, handle:",v,u),v}catch(e){if(console.error("[storeData] failed:",e),e instanceof P)throw e;throw new P(`[storeData] failed to store data: ${e}`)}}async#I(e,t,n){try{let a=await x(e+t,{method:"GET"});a=function(e){if(e){if("3"===e.version&&"string"==typeof e.id&&43===e.id.length&&G.test(e.id)&&e.iv instanceof Uint8Array&&12===e.iv.byteLength&&e.salt instanceof ArrayBuffer&&16===e.salt.byteLength&&e.data instanceof ArrayBuffer&&e.actualSize===e.data.byteLength)return e;throw new P("invalid Shard")}throw new P("invalid SBObjectHandle (null or undefined)")}(a),O(n.key,"object handle 'key' is missing, cannot decrypt"),n.iv=a.iv,n.salt=a.salt,n.data=new WeakRef(a.data),n.actualSize=a.actualSize,S&&console.log("fetchData(), handle (and data) at this point:",n,a.data);const s=X(n.key),o=await r.getObjectKey(s,n.salt),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:n.iv},o,a.data),c=this.#P(i);return S&&console.log("shard.data (decrypted and unpadded):",c),n.payload=de(c).payload,n.data=new WeakRef(a.data),n}catch(t){return b&&console.log(`fetchData(): trying to get object on '${e}' failed: '${t}'`),null}}async fetchData(e){const t=C(e);if(b&&console.log("fetchData(), handle:",t),t.data&&t.data instanceof WeakRef&&t.data.deref())return t;const n=await t.verification,r=t.storageServer?t.storageServer:null,a=await this.getStorageServer();for(const e of[r,"http://localhost:3841",a]){if(!e)continue;b&&console.log("\n",Re,"fetchData(), trying server: ",e,"\n",Re);const r="/api/v2/fetchData?id="+t.id+"&verification="+n,a=await this.#I(e,r,t);if(null!==a)return b&&console.log(`[fetchData] success: fetched from '${e}'`,a),a.storageServer=e,a}throw new P("[fetchData] failed to fetch from any server")}static getData(e){const t=C(e);if(t.data){if(t.data instanceof WeakRef){return t.data.deref()||void 0}if(t.data instanceof ArrayBuffer)return t.data;throw new P("Invalid data type in handle")}}static getPayload(e){const t=C(e);if(t.payload)return t.payload;const n=r.getData(t);if(!n)throw new P("[getPayload] no data or payload in handle, use fetchData()");return de(n).payload}}r=$e,a([be],$e.prototype,"getStorageServer",null);class Ne{#M;#D;#R=s;#E;sbFetch=E;constructor(e,t,n){console.warn(`==== CREATING Snackabra object generation: ${this.#R} ====`),O("string"==typeof e,"[Snackabra] Invalid parameter type for constructor"),t&&!0===t&&(b=!0),b&&n&&!0===n&&(S=!0),b&&console.warn("++++ Snackabra constructor: setting DBG to TRUE ++++"),S&&console.warn("++++ Snackabra constructor: ALSO setting DBG2 to TRUE (verbose) ++++"),this.#M=e,this.#D=new $e(new Promise(((e,t)=>{E(this.#M+"/api/v2/info").then((e=>(e.ok||t("response from channel server was not OK"),e.json()))).then((n=>{n.error?t(`fetching storage server name failed: ${n.error}`):(this.#E=n,b&&console.log("Channel server info:",this.#E)),O(n.storageServer,"Channel server did not provide storage server name, cannot initialize"),e(n.storageServer)})).catch((e=>{t(e)}))})))}async getPage(e){return b&&console.log(`==== Snackabra.getPage: calling fetch with: ${e}`),de(await x(this.#M+"/api/v2/page/"+e))}attach(e){return new Promise(((t,n)=>{e.channelId?(e.channelServer?e.channelServer!==this.#M&&n("[attach] SBChannelHandle channelId does not match channelServer"):e.channelServer=this.#M,t(new _e(e))):n("SBChannelHandle missing channelId")}))}create(e){return O(null!==e,"[create channel] Invalid parameter (null)"),new Promise((async(t,n)=>{try{var r;if(e instanceof _e){const t=e;await t.ready,t.channelServer||(t.channelServer=this.#M),r=await t.getStorageToken(o)}else try{r=c(e)}catch(e){return void n("Invalid parameter to create() - need a token or a budget channel")}O(r,"[create channel] Failed to get storage token for the provided channel");const a=await(new _e).ready;a.channelServer=this.#M,a.create(r).then((e=>{t(e)})).catch((e=>{n(e)}))}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),n(t)}}))}connect(e,t){if(O(e&&e.channelId&&e.userPrivateKey,"[connect] Invalid parameter (missing info)"),e.channelServer&&e.channelServer!==this.#M)throw new P(`[Snackabra.connect] channel server in handle ('${e.channelServer}') does not match what SB was set up with ('${this.#M}')`);const n={...e,[Ke]:!0,channelServer:this.#M};return b&&console.log("++++ Snackabra.connect() ++++",n),t?new Ue(n,t):new _e(n)}get storage(){return this.#D}async getStorageServer(){return this.#D.getStorageServer()}get crypto(){return De}get version(){return this.#R}}a([be],Ne.prototype,"storage",null),a([be],Ne.prototype,"getStorageServer",null);var He={Snackabra:Ne,SBMessage:Oe,Channel:_e,SBCrypto:ve,SB384:xe,arrayBufferToBase64url:U,base64ToArrayBuffer:$,arrayBufferToBase62:Y,base62ToArrayBuffer:X,sbCrypto:De,version:s,setDebugLevel:m};return globalThis.SB||(globalThis.SB=He),console.warn(`==== SNACKABRA jslib (re)loaded, version '${globalThis.SB.version}' ====`),t})()));