!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>ce,ChannelEndpoint:()=>he,ChannelSocket:()=>le,MessageBus:()=>i,SB:()=>pe,SB384:()=>ae,SBCrypto:()=>Y,SBMessage:()=>ie,SBObjectHandleClass:()=>ye,Snackabra:()=>ue,_appendBuffer:()=>U,_assertBase64:()=>w,_sb_assert:()=>y,_sb_exception:()=>h,_sb_resolve:()=>d,arrayBuffer32ToBase62:()=>D,arrayBufferToBase64:()=>R,assemblePayload:()=>q,base62ToArrayBuffer32:()=>I,base62ToBase64:()=>T,base64ToArrayBuffer:()=>O,base64ToBase62:()=>N,cleanBase32mi:()=>G,compareBuffers:()=>P,decodeB64Url:()=>X,encodeB64Url:()=>Z,encryptedContentsMakeBinary:()=>a,extractPayload:()=>W,extractPayloadV1:()=>F,getRandomValues:()=>u,isBase62Encoded:()=>L,jsonParseWrapper:()=>z,partition:()=>V,sbCrypto:()=>se,simpleRand256:()=>$,simpleRandomString:()=>J,version:()=>o});var n=function(e,t,n,o){var r,s=arguments.length,a=s<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,o);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(s<3?r(a):s>3?r(t,n,a):r(t,n))||a);return s>3&&a&&Object.defineProperty(t,n,a),a};const o="1.0.x",r=[{channel_server:"https://channel.384co.workers.dev",channel_ws:"wss://channel.384co.workers.dev",storage_server:"https://storage.384co.workers.dev",shard_server:"https://shard.3.8.4.land"},{channel_server:"https://r.384co.workers.dev",channel_ws:"wss://r.384co.workers.dev",storage_server:"https://s.384co.workers.dev"}];var s=!1;function a(e){try{let t,n;if(s&&(console.log("=+=+=+=+ processing content"),console.log(e.content.constructor.name)),"string"==typeof e.content)try{t=O(decodeURIComponent(e.content))}catch(e){throw new Error("EncryptedContents is string format but not base64 (?)")}else{const n=e.content.constructor.name;y("ArrayBuffer"===n||"Uint8Array"===n,"undetermined content type in EncryptedContents object"),t=e.content}if(s&&console.log("=+=+=+=+ processing nonce"),"string"==typeof e.iv)s&&(console.log("got iv as string:"),console.log(structuredClone(e.iv))),n=O(decodeURIComponent(e.iv)),s&&(console.log("this was turned into array:"),console.log(structuredClone(n)));else if("Uint8Array"===e.iv.constructor.name||"ArrayBuffer"===e.iv.constructor.name)s&&console.log("it's an array already"),n=new Uint8Array(e.iv);else{s&&console.log("probably a dictionary");try{n=new Uint8Array(Object.values(e.iv))}catch(t){s&&(console.error("ERROR: cannot figure out format of iv (nonce), here's the input object:"),console.error(e.iv)),y(!1,"undetermined iv (nonce) type, see console")}}return s&&(console.log("decided on nonce as:"),console.log(n)),y(12==n.length,`unwrap(): nonce should be 12 bytes but is not (${n.length})`),{content:t,iv:n}}catch(e){throw console.error("encryptedContentsMakeBinary() failed:"),console.error(e),console.trace(),console.log(e.stack),e}}class i{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function c(e,t){return t?fetch(e,t):fetch(e,{method:"GET"})}function l(e){return e instanceof Error?e:new Error(String(e))}function h(e,t){throw new Error("<< SB lib error ("+e+": "+t+") >>")}function d(e){return e.then?e:new Promise((t=>t(e)))}function y(e,t){if(!e)throw new Error(`<< SB assertion error: ${t} >>`)}async function g(e){const t=new ae(e);await t.ready;const n=t.exportable_pubKey,o=t.exportable_privateKey,r=t.ownerChannelId,s=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=await crypto.subtle.exportKey("jwk",s),i=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]),c=await crypto.subtle.exportKey("jwk",i.privateKey);return{channelData:{roomId:r,ownerKey:JSON.stringify(n),encryptionKey:JSON.stringify(a),signKey:JSON.stringify(c)},exportable_privateKey:o}}function u(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{y(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}const p=/([A-Za-z0-9+/_\-=]{64})([01]{42})/,f=/^([A-Za-z0-9+/_\-=]*)$/;function w(e){const t=f.exec(e);return!!t&&t[0]===e}function b(e){const t=f.exec(e);return y(t&&t[0]===e,"ensureSafe() tripped: something is not URI safe"),e}const m=[],v=[],k=[],S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",K=S+"+/",C=S+"-_",A="=",_=16383;for(let e=0,t=K.length;e<t;++e)m[e]=K[e],v[e]=C[e],k[K.charCodeAt(e)]=e;function O(e){if(!w(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,o]=function(e){const t=e.length;let n=e.indexOf(A);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),r=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,o));let s=0;const a=o>0?n-4:n;let i;for(i=0;i<a;i+=4)t=k[e.charCodeAt(i)]<<18|k[e.charCodeAt(i+1)]<<12|k[e.charCodeAt(i+2)]<<6|k[e.charCodeAt(i+3)],r[s++]=t>>16&255,r[s++]=t>>8&255,r[s++]=255&t;return 2===o&&(t=k[e.charCodeAt(i)]<<2|k[e.charCodeAt(i+1)]>>4,r[s++]=255&t),1===o&&(t=k[e.charCodeAt(i)]<<10|k[e.charCodeAt(i+1)]<<4|k[e.charCodeAt(i+2)]>>2,r[s++]=t>>8&255,r[s++]=255&t),r}function E(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function j(e,t,n,o){let r;const s=new Array((o-n)/3);for(let a=n,i=0;a<o;a+=3,i++)r=(t.getUint8(a)<<16&16711680)+(t.getUint8(a+1)<<8&65280)+(255&t.getUint8(a+2)),s[i]=E(e,r);return s.join("")}k["-".charCodeAt(0)]=62,k["_".charCodeAt(0)]=63;const B=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function P(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=B(e),o=B(t);if(n.byteLength!==o.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==o.getUint8(e))return!1;return!0}function R(e,t="url"){if(null==e)return h("L509","arrayBufferToBase64() -> null paramater"),"";{const n=B(e),o=n.byteLength,r=o%3,s=o-r,a=new Array(Math.floor(s/_)+Math.sign(r)),i="url"==t?v:m,c="";let l=0;for(let e=0;e<s;e+=_)a[l++]=j(i,n,e,e+_>s?s:e+_);if(1===r){const e=n.getUint8(o-1);a[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===r){const e=(n.getUint8(o-2)<<8)+n.getUint8(o-1);a[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return a.join("")}}const x="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",M=/^(a32\.)?[0-9A-Za-z]{43}$/;function I(e){if(!M.test(e))throw new Error(`base62ToArrayBuffer32: string must match: ${M}`);e=e.slice(4);let t=0n;for(let n=0;n<e.length;n++)t=62n*t+BigInt(x.indexOf(e[n]));if(t>2n**256n-1n)throw new Error("base62ToArrayBuffer32: value exceeds 256 bits.");const n=new ArrayBuffer(32),o=new DataView(n);for(let e=0;e<8;e++){const n=Number(BigInt.asUintN(32,t));o.setUint32(4*(8-e-1),n),t>>=32n}return n}function D(e){if(32!==e.byteLength)throw new Error("arrayBuffer32ToBase62: buffer must be exactly 32 bytes (256 bits).");let t="";for(let n=BigInt("0x"+Array.from(new Uint8Array(e)).map((e=>e.toString(16).padStart(2,"0"))).join(""));n>0n;n/=62n)t=x[Number(n%62n)]+t;return"a32."+t.padStart(43,"0")}function T(e){return R(I(e))}function N(e){return D(O(e))}function L(e){return M.test(e)}function U(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function $(){return crypto.getRandomValues(new Uint8Array(1))[0]}const H="0123456789abcdefyhEjkLmNHpFrRTUW";function J(e,t){if("base32mi"==t){const t=crypto.getRandomValues(new Uint8Array(e));let n="";for(let o=0;o<e;o++)n+=H[31&t[o]];return n}return h("simpleRandomString","code "+t+" not supported"),""}function G(e){return e.replace(/[OoQD]/g,"0").replace(/[lIiJ]/g,"1").replace(/[Zz]/g,"2").replace(/[A]/g,"4").replace(/[Ss]/g,"5").replace(/[G]/g,"6").replace(/[t]/g,"7").replace(/[B]/g,"8").replace(/[gq]/g,"9").replace(/[C]/g,"c").replace(/[Y]/g,"y").replace(/[KxX]/g,"k").replace(/[M]/g,"m").replace(/[n]/g,"N").replace(/[P]/g,"p").replace(/[uvV]/g,"U").replace(/[w]/g,"w")}function V(e,t){throw`partition() not tested on TS yet - (${e}, ${t})`}function z(e,t){if(null==e)return null;try{return JSON.parse(e)}catch(n){try{let t="",n="",o=e;for(;o!=(n=t,t=o,o=o?.match(/^(['"])(.*)\1$/m)?.[2]);)return JSON.parse(`'${n}'`)}catch{try{return JSON.parse(e.slice(1,-1))}catch{throw new Error(`JSON.parse() error at ${t} (tried eval and slice)\nString was: ${e}`)}}}}function F(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=z((new TextDecoder).decode(e.slice(4,4+t)),"L476");let o=4+t;const r={};for(const t in n)r.key&&(r[t]=e.slice(o,o+n[t]),o+=n[t]);return r}catch(e){return console.error(e),{}}}function q(e){try{const t={version:"002"};let n=0,o=0;for(const r in e)n++,t[n.toString()]={name:r,start:o,size:e[r].byteLength},o+=e[r].byteLength;const r=(new TextEncoder).encode(JSON.stringify(t)),s=new Uint32Array([r.byteLength]);let a=U(new Uint8Array(s.buffer),new Uint8Array(r));for(const t in e)a=U(new Uint8Array(a),e[t]);return a}catch(e){return console.error(e),null}}function W(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=z((new TextDecoder).decode(e.slice(4,4+t)),"L533"),o=4+t;switch(n.version||(n.version="001"),n.version){case"001":return F(e);case"002":{const t=[];for(let r=1;r<Object.keys(n).length;r++){const s=r.toString();if(n[s]){const r=n[s].start,a=n[s].size;t[n[s].name]=e.slice(o+r,o+r+a)}else console.log(`found nothing for index ${r}`)}return t}default:throw new Error("Unsupported payload version ("+n.version+") - fatal")}}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function Z(e){return e.replaceAll("+","-").replaceAll("/","_")}function X(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;if(t){if(1===t)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");e+=new Array(5-t).join("=")}return e}class Y{generateIdKey(e){return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),o=e.slice(32);t({id:R(n),key:R(o)})}))}catch(e){n(e)}}))}extractPubKey(e){try{const t={...e};return delete t.d,delete t.dp,delete t.dq,delete t.q,delete t.qi,t.key_ops=[],t}catch(e){return console.error(e),null}}async#t(e){const t=/^[0-9A-Za-z]+$/;let n=0,o=R(e);for(;!t.test(o);){if(n++>160)throw new Error("generateChannelHash() - exceeded 160 iterations:");o=R(e=await crypto.subtle.digest("SHA-384",e))}return R(e)}async#n(e,t){let n=0,o=R(e);for(;o!==t;){if(n++>160)return!1;o=R(e=await crypto.subtle.digest("SHA-384",e))}return!0}async generateChannelId(e){if(e&&e.x&&e.y){const t=U(O(X(e.x)),O(X(e.y)));return await this.#t(t)}return"InvalidJsonWebKey"}async verifyChannelId(e,t){if(e){let n=e.x,o=e.y;if(!n||!o)try{const t=JSON.parse(e);t.x&&(n=t.x),t.y&&(o=t.y)}catch{return!1}const r=U(O(X(n)),O(X(o)));return await this.#n(r,t)}return!1}generateKeys(){return new Promise((async(e,t)=>{try{e(await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]))}catch(e){t(e)}}))}importKey(e,t,n,o,r){const s={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};return"jwk"===e?crypto.subtle.importKey("jwk",t,s[n],o,r):crypto.subtle.importKey(e,t,s[n],o,r)}exportKey(e,t){return crypto.subtle.exportKey(e,t)}deriveKey(e,t,n,o,r){return new Promise((async(s,a)=>{const i={AES:{name:"AES-GCM",length:256},HMAC:{name:"HMAC",hash:"SHA-256",length:256}};try{s(await crypto.subtle.deriveKey({name:"ECDH",public:t},e,i[n],o,r))}catch(s){console.error(s,e,t,n,o,r),a(s)}}))}encrypt(e,t,n,o="encryptedContents"){return new Promise((async(r,s)=>{try{null===e&&s(new Error("no contents"));const a=n&&null!==n?n:crypto.getRandomValues(new Uint8Array(12));"string"==typeof e&&(e=(new TextEncoder).encode(e)),crypto.subtle.encrypt({name:"AES-GCM",iv:a},t,e).then((e=>{r("encryptedContents"===o?{content:b(R(e)),iv:b(R(a))}:e)}))}catch(e){s(e)}}))}wrap(e,t,n){return new Promise((o=>{let r;r="string"===n?se.str2ab(t):t,se.encrypt(r,e).then((e=>{o(e)}))}))}unwrap(e,t,n){return s&&(console.log("SBCrypto.unwrap(), got k/o:"),console.log(e),console.log(t)),new Promise((async(o,r)=>{try{const{content:i,iv:c}=a(t);s&&(console.log("======== calling subtle.decrypt with iv, k, t (AES-GCM):"),console.log(c),console.log(e),console.log(i),console.log("======== (end of subtle.decrypt parameters)")),crypto.subtle.decrypt({name:"AES-GCM",iv:c},e,i).then((e=>{"string"===n?o((new TextDecoder).decode(e)):"arrayBuffer"===n&&o(e)})).catch((e=>{console.error(`unwrap(): failed to decrypt - rejecting: ${e}`),console.trace(),r(e)}))}catch(e){console.error(`unwrap(): unknown issue - rejecting: ${e}`),console.trace(),r(e)}}))}sign(e,t){return new Promise((async(n,o)=>{try{const r=(new TextEncoder).encode(t);let s;try{s=await crypto.subtle.sign("HMAC",e,r),n(b(R(s)))}catch(e){o(e)}}catch(e){o(e)}}))}verify(e,t,n){return new Promise(((o,r)=>{try{crypto.subtle.verify("HMAC",e,O(t),se.str2ab(n)).then((e=>{o(e)}))}catch(e){r(l(e))}}))}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}compareKeys(e,t){return null!=e&&null!=t&&"object"==typeof e&&"object"==typeof t&&e.x===t.x&&e.y===t.y}lookupKey(e,t){for(let n=0;n<t.length;n++)if(se.compareKeys(e,t[n]))return n;return-1}async channelKeyStringsToCryptoKeys(e){return new Promise((async(t,n)=>{let o=z(e.ownerKey,"L1513");Promise.all([se.importKey("jwk",o,"ECDH",!1,[]),se.importKey("jwk",z(e.encryptionKey,"L2250"),"AES",!1,["encrypt","decrypt"]),se.importKey("jwk",z(e.signKey,"L2251"),"ECDH",!0,["deriveKey"]),se.importKey("jwk",se.extractPubKey(z(e.signKey,"L2252")),"ECDH",!0,[])]).then((async e=>{s&&console.log("++++++++ readyPromise() processed first batch of keys");const n=e[0],r=e[1],a=e[2],i=e[3];t({ownerKey:n,ownerPubKeyX:o.x,encryptionKey:r,signKey:a,publicSignKey:i})})).catch((e=>{console.error(`readyPromise(): failed to import keys: ${e}`),n(e)}))}))}}function Q(e,t,n){if(n&&n.get){let o=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=o.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function ee(e,t,n){if(n&&n.get){let o=n.get;n.get=function(){const n=e.constructor.name;`${n}ReadyFlag`in this&&y(this.readyFlag,`${t} getter accessed but object ${n} not ready (fatal)`);const r=o.call(this);return y(null!=r,`${t} getter accessed in object type ${n} but returns NULL (fatal)`),r}}}const te=["SBMessage","SBObjectHandle"],ne=Symbol.for("SBMessage"),oe=Symbol.for("SBObjectHandle");function re(e,t){switch(t){case"SBMessage":return ne in e;case"SBObjectHandle":return oe in e}}const se=new Y;class ae{ready;sb384Ready;#o=!1;#r;#s;#a;#i;constructor(e){this.ready=new Promise((async(t,n)=>{try{if(e){this.#s=e;const t=se.extractPubKey(e);y(t,"unable to extract public key"),this.#r=t,this.#a=await se.importKey("jwk",e,"ECDH",!0,["deriveKey"])}else{const e=await se.generateKeys();this.#a=e.privateKey;const t=await Promise.all([se.exportKey("jwk",e.publicKey),se.exportKey("jwk",e.privateKey)]);this.#r=t[0],this.#s=t[1]}this.#i=await se.generateChannelId(this.#r),this.#o=!0,t(this)}catch(e){n("ERROR creating SB384 object: "+l(e))}})),this.sb384Ready=this.ready}get readyFlag(){return this.#o}get exportable_pubKey(){return this.#r}get exportable_privateKey(){return this.#s}get privateKey(){return this.#a}get _id(){return JSON.stringify(this.exportable_pubKey)}get ownerChannelId(){return this.#i}}n([Q],ae.prototype,"readyFlag",null),n([Q,ee],ae.prototype,"exportable_pubKey",null),n([Q,ee],ae.prototype,"exportable_privateKey",null),n([Q,ee],ae.prototype,"privateKey",null),n([Q,ee],ae.prototype,"_id",null),n([Q,ee],ae.prototype,"ownerChannelId",null);class ie{ready;channel;contents;[ne]=!0;MAX_SB_BODY_SIZE=65536;constructor(e,t=""){y(t.length<this.MAX_SB_BODY_SIZE,"SBMessage(): body must be smaller than 64 KiB"),this.channel=e,this.contents={encrypted:!1,isVerfied:!1,contents:t,sign:"",image:"",imageMetaData:{}},console.log("#### SBMessage constructor"),this.ready=new Promise((n=>{console.log("#### SBMessage constructor - waiting for channelReady() on:"),console.log(e),e.channelReady.then((async()=>{console.log("#### channel ready for the SBMessage object"),this.contents.sender_pubKey=this.channel.exportable_pubKey,e.userName&&(this.contents.sender_username=e.userName);const o=this.channel.channelSignKey,r=se.sign(o,t),s=se.sign(o,this.contents.image),a=se.sign(o,JSON.stringify(this.contents.imageMetaData));Promise.all([r,s,a]).then((e=>{console.log("+++++++ SBMessage constructor - all promises resolved"),this.contents.sign=e[0],this.contents.image_sign=e[1],this.contents.imageMetadata_sign=e[2],console.log("+++++++ SBMessage RESOLVED:"),console.log(this),n(this)}))}))}))}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}class ce extends ae{channelReady;#c=!1;#l;motd="";locked=!1;owner=!1;admin=!1;adminData;verifiedGuest=!1;userName="";#h;#d;#y;#g="";#u="";#p="";constructor(e,t,n){y(n,"Channel(): as of jslib 1.1.x the channelId must be provided"),super(t),this.#l=e,this.#y=n,this.#u=e.channel_server+"/api/",this.#p=e.channel_server+"/api/room/",this.channelReady=new Promise((async(e,t)=>{await this.sb384Ready,c(this.#l.channel_server+"/api/room/"+this.#y+"/getChannelKeys",{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>(console.log("got response for ChannelEndpoint ======="),y(e.ok,"ChannelEndpoint(): failed to get channel keys (network response not ok)"),e.json()))).then((async t=>{y(!t.error,"ChannelEndpoint(): failed to get channel keys (error in response)"),await this.#f(t),this.#c=!0,e(this)})).catch((e=>{t("ChannelApi Error [1]: "+l(e))}))}))}async#w(e){this.#h=e,y(this.#h,"Channel.importKeys: no channel keys (?)"),y(this.#h.publicSignKey,"Channel.importKeys: no public sign key (?)"),y(this.privateKey,"Channel.importKeys: no private key (?)"),this.#d=await se.deriveKey(this.privateKey,this.#h.publicSignKey,"HMAC",!1,["sign","verify"])}async#f(e){await this.#w(await se.channelKeyStringsToCryptoKeys(e))}get keys(){return this.#h}get sbServer(){return this.#l}get readyFlag(){return this.#c}get api(){return this}get channelId(){return this.#y}get channelSignKey(){return this.#d}getLastMessageTimes(){return new Promise(((e,t)=>{c(this.#u+"/getLastMessageTimes",{method:"POST",body:JSON.stringify([this.channelId])}).then((e=>(e.ok||t(new Error("Network response was not OK")),e.json()))).then((t=>{e(t[this.channelId])})).catch((e=>{t(e)}))}))}getOldMessages(e=100,t=!1){return new Promise(((n,o)=>{let r="";t&&(r="&cursor="+this.#g),c(this.#p+this.channelId+"/oldMessages?currentMessagesLength="+e+r,{method:"GET"}).then((async e=>(e.ok||o(new Error("Network response was not OK")),e.json()))).then((e=>{s&&(console.log("getOldMessages"),console.log(structuredClone(Object.values(e)))),Promise.all(Object.keys(e).filter((t=>e[t].hasOwnProperty("encrypted_contents"))).map((t=>de(t,e[t].encrypted_contents,this.keys)))).then((e=>{let t=e[e.length-1];t&&(this.#g=t._id||t.id||""),n(e)}))})).catch((e=>{o(e)}))}))}async#b(e,t){s&&console.log(e),this.readyFlag||(console.log("ChannelApi.#callApi: channel not ready (we will wait)"),await this.channelReady);const n=t?"POST":"GET";return new Promise((async(o,r)=>{await this.ready;let s="";const a=(new Date).getTime().toString();s=a+"."+await se.sign(this.channelSignKey,a);let i={method:n,headers:{"Content-Type":"application/json",authorization:s}};t&&(i.body=JSON.stringify(t)),await this.ready,c(this.#p+this.channelId+e,i).then((e=>(e.ok||r(new Error("Network response was not OK")),e.json()))).then((e=>{e.error?r(new Error(e.error)):o(e)})).catch((e=>{r("ChannelApi Error [2]: "+l(e))}))}))}updateCapacity(e){return this.#b("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.#b("/getRoomCapacity")}getStorageLimit(){return this.#b("/getStorageLimit")}getMother(){return this.#b("/getMother")}getJoinRequests(){return this.#b("/getJoinRequests")}isLocked(){return new Promise((e=>this.#b("/roomLocked").then((t=>e(!0===t.locked)))))}setMOTD(e){return this.#b("/motd",{motd:e})}getAdminData(){return this.#b("/getAdminData")}downloadData(){return new Promise(((e,t)=>{this.#b("/downloadData").then((e=>e.json())).then((t=>{Promise.all(Object.keys(t).filter((e=>{const n=new RegExp(this.channelId);if(e.match(n)){const n=z(t[e],"L3318");if(n.hasOwnProperty("encrypted_contents"))return s&&console.log(n),n}})).map((e=>{const n=z(t[e],"L3327");return s&&console.log(e,n.encrypted_contents,this.keys),de(e,n.encrypted_contents,this.keys)}))).then((n=>{let o={};n.forEach((e=>{if(!e.control&&e.imageMetaData.imageId){const t=n.find((t=>t.id&&t.id==e.imageMetaData.imageId)),r=n.find((t=>t.id&&t.id==e.imageMetaData.previewId));o[`${e.imageMetaData.imageId}.f`]=t?.verificationToken,o[`${e.imageMetaData.previewId}.p`]=r?.verificationToken}})),e({storage:o,channel:t})}))})).catch((e=>{t(e)}))}))}uploadChannel(e){return this.#b("/uploadRoom",e)}authorize(e,t){return this.#b("/authorizeRoom",{roomId:this.channelId,SERVER_SECRET:t,ownerKey:e})}postPubKey(e){throw new Error("postPubKey() deprecated")}storageRequest(e){return this.#b("/storageRequest?size="+e)}lock(){return console.trace("WARNING: lock() on channel api has not been tested/debugged fully .."),new Promise((async(e,t)=>{if(null==this.keys.lockedKey&&this.admin){const n=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),o=await crypto.subtle.exportKey("jwk",n);this.#b("lockRoom").then((t=>{t.locked&&this.acceptVisitor(JSON.stringify(this.exportable_pubKey)).then((()=>{e({locked:t.locked,lockedKey:o})}))})).catch((e=>{t(e)}))}else t(new Error("no lock key or not admin"))}))}acceptVisitor(e){return console.warn("WARNING: acceptVisitor() on channel api has not been tested/debugged fully .."),new Promise((async t=>{y(this.keys.privateKey,"acceptVisitor(): no private key");const n=await se.deriveKey(this.keys.privateKey,await se.importKey("jwk",z(e,"L2276"),"ECDH",!1,[]),"AES",!1,["encrypt","decrypt"]),o=await se.encrypt(se.str2ab(JSON.stringify(this.keys.lockedKey)),n);t(this.#b("/acceptVisitor",{pubKey:e,lockedKey:JSON.stringify(o)}))}))}ownerKeyRotation(){throw new Error("ownerKeyRotation() replaced by new budd() approach")}budd(e){let{keys:t,storage:n,targetChannel:o}=e??{};return new Promise((async(e,r)=>{try{if(n||(n=1/0),o){if(t)throw new Error("[budd()]: You can't specify both a target channel and keys");e(this.#b(`/budd?targetChannel=${o}&transferBudget=${n}`))}else{const{channelData:o,exportable_privateKey:s}=await g(t);let a=await this.#b(`/budd?targetChannel=${o.roomId}&transferBudget=${n}`,o);a.success?e({channelId:o.roomId,key:s}):r(JSON.stringify(a))}}catch(e){r(e)}}))}}n([Q,ee],ce.prototype,"keys",null),n([Q,ee],ce.prototype,"sbServer",null),n([Q,ee],ce.prototype,"readyFlag",null),n([Q,ee],ce.prototype,"api",null),n([Q,ee],ce.prototype,"channelId",null),n([Q,ee],ce.prototype,"channelSignKey",null),n([ee],ce.prototype,"getOldMessages",null),n([ee],ce.prototype,"updateCapacity",null),n([ee],ce.prototype,"getCapacity",null),n([ee],ce.prototype,"getStorageLimit",null),n([ee],ce.prototype,"getMother",null),n([ee],ce.prototype,"getJoinRequests",null),n([function(e,t,n){if(n&&n.value){const o=n.value;n.value=function(...r){try{return o.call(this,...r)}catch(o){return console.log(`ExceptionReject: ${l(o)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${l(o)}`)))}}}}],ce.prototype,"isLocked",null),n([ee],ce.prototype,"setMOTD",null),n([ee],ce.prototype,"getAdminData",null),n([ee],ce.prototype,"downloadData",null),n([ee],ce.prototype,"uploadChannel",null),n([ee],ce.prototype,"authorize",null),n([ee],ce.prototype,"postPubKey",null),n([ee],ce.prototype,"storageRequest",null),n([ee],ce.prototype,"lock",null),n([ee],ce.prototype,"acceptVisitor",null),n([ee],ce.prototype,"ownerKeyRotation",null),n([ee],ce.prototype,"budd",null);class le extends ce{ready;#m=!1;#v;#l;#k;#S=[];#K=!1;constructor(e,t,n,o){super(e,n,o),y(e.channel_ws,"ChannelSocket(): no websocket server name provided");const r=e.channel_ws+"/api/room/"+o+"/websocket";this.#k=t,this.#l=e,this.#v={url:r,ready:!1,closed:!1,timeout:2e3},this.ready=this.#C()}#A(e){this.#K&&console.log(structuredClone(e));const t=z(e,"L1489");if(this.#K&&(console.log("... json unwrapped version of raw message:"),console.log(Object.assign({},t))),t.ack){const e=this.#S[t._id];e&&(this.#K&&console.log(`++++++++ found matching ack for id ${t._id} (on first check?)`),delete this.#S[t._id],e("success"))}else if(t.nack)this.#v.closed=!0;else if("function"==typeof this.#k){const e=t;try{let n=Object.entries(e)[0][1];if("encrypted_contents"===Object.keys(n)[0]){const e=Object.entries(t)[0][0],o=n.encrypted_contents.iv;o&&w(o)&&16==o.length?n.encrypted_contents.iv=O(o):console.error("processMessage() - iv is malformed, should be 16-char b64 string (ignoring)"),this.#K&&(console.log("vvvvvv - calling deCryptChannelMessage() with arg1, arg2, arg3:"),console.log(structuredClone(e)),console.log(structuredClone(n.encrypted_contents)),console.log(structuredClone(this.keys)),console.log("^^^^^^ - (end parameter list)")),de(e,n.encrypted_contents,this.keys).then((e=>{this.#K&&console.log(Object.assign({},e)),this.#k(e)})).catch((()=>{console.log("Error processing message, dropping it")}))}else if("ack"===n.type){this.#K&&console.log("++++++++ Received 'ack'");const e=n._id,t=this.#S[e];t?(this.#K&&console.log(`++++++++ found matching ack for id ${e}`),delete this.#S[e],t("success")):console.info(`WARNING: did not find matching ack for id ${e}`)}else console.log("++++++++ #processMessage: can't decipher message, passing along unchanged:"),console.log(Object.assign({},e)),this.#k(e)}catch(t){console.log(`++++++++ #processMessage: caught exception while decyphering (${t}), passing it along unchanged`),this.#k(e)}}else h("ChannelSocket","received message but there is no handler")}#C(){const e=this.#v.url;let t=!1;return new Promise(((n,o)=>{let r=this;s&&(console.log("++++++++ readyPromise() has url:"),console.log(e)),this.#v.websocket||(this.#v.websocket=new WebSocket(this.#v.url)),3===this.#v.websocket.readyState?this.#v.websocket=new WebSocket(e):2===this.#v.websocket.readyState&&(console.log("STRANGE - trying to use a ChannelSocket that is in the process of closing ..."),this.#v.websocket=new WebSocket(e)),this.#v.websocket.addEventListener("open",(()=>{this.#v.closed=!1,this.channelReady.then((()=>{y(this.exportable_pubKey,"ChannelSocket.readyPromise(): no exportable pub key?"),this.#v.init={name:JSON.stringify(this.exportable_pubKey)},s&&(console.log("++++++++ readyPromise() constructed init:"),console.log(this.#v.init)),this.#v.websocket.send(JSON.stringify(this.#v.init))}))})),this.#v.websocket.addEventListener("message",(async function e(o){if(t)return void console.warn("WARNING: firstMessageEventHandler() called recursively (?)");t=!0,s&&(console.log("++++++++ readyPromise() received ChannelKeysMessage:"),console.log(o));const a=z(o.data,"L2239");s&&console.log(a),y(a.ready,"got roomKeys but channel reports it is not ready (?)"),r.motd=a.motd,r.locked=a.roomLocked;const i=z(a.keys.ownerKey,"L2246");y(r.keys.ownerPubKeyX===i.x,"ChannelSocket.readyPromise(): owner key mismatch??"),y(r.readyFlag,"#ChannelReadyFlag is false, parent not ready (?)"),r.owner=se.compareKeys(i,r.exportable_pubKey),r.admin=r.owner,r.#v.websocket.removeEventListener("message",e),r.#v.websocket.addEventListener("message",(e=>{r.#A(e.data)})),s&&console.log("++++++++ readyPromise() all done - resolving!"),r.#m=!0,t=!1,n(r)})),this.#v.websocket.addEventListener("close",(e=>{this.#v.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?o(`No such channel on this server (${this.#l.channel_server})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.#l.channel_server}`),o("wbSocket() closed before it was opened (?)")})),this.#v.websocket.addEventListener("error",(e=>{this.#v.closed=!0,console.log("ChannelSocket() error: ",e),o("ChannelSocket creation error (see log)")}))}))}get status(){if(!this.#v.websocket)return"CLOSED";switch(this.#v.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#k=e}get onMessage(){return this.#k}set enableTrace(e){this.#K=e,console.log(`Tracing ${e?"en":"dis"}abled`)}send(e){let t="string"==typeof e?new ie(this,e):e;return y(this.#v.websocket,"ChannelSocket.send() called before ready"),this.#v.closed&&(this.#K&&console.info("send() triggered reset of #readyPromise() (normal)"),this.ready=this.#C()),new Promise(((e,n)=>{t.ready.then((t=>{this.ready.then((()=>{switch(this.#K&&console.log(Object.assign({},t)),this.#m||n("ChannelSocket.send() is confused - ready or not?"),this.#v.websocket.readyState){case 1:this.#K&&(console.log("Wrapping message contents:"),console.log(Object.assign({},t.contents))),se.wrap(this.keys.encryptionKey,JSON.stringify(t.contents),"string").then((t=>{this.#K&&(console.log("ChannelSocket.send():"),console.log(Object.assign({},t)));const o=JSON.stringify({encrypted_contents:t});this.#K&&(console.log("++++++++ ChannelSocket.send() got this from wrap:"),console.log(structuredClone(o)),console.log("++++++++ ChannelSocket.send() then got this from JSON.stringify:"),console.log(Object.assign({},t))),crypto.subtle.digest("SHA-256",(new TextEncoder).encode(o)).then((t=>{const r=R(t),s={timestamp:Date.now(),type:"ack",_id:r};this.#S[r]=e,this.#K&&(console.log("++++++++ ChannelSocket.send() this message:"),console.log(structuredClone(o))),this.#v.websocket.send(o),this.#v.websocket.send(JSON.stringify(s)),setTimeout((()=>{if(this.#S[r]){delete this.#S[r];const e=`Websocket request timed out (no ack) after ${this.#v.timeout}ms (${r})`;console.error(e),n(e)}else this.#K&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#v.timeout)}))}));break;case 3:case 0:case 2:const o="socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING";h("ChannelSocket",o),n(o)}}))}))}))}get exportable_owner_pubKey(){return this.keys.ownerKey}}n([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&te.includes(n)&&y(re(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],le.prototype,"send",null),n([Q,ee],le.prototype,"exportable_owner_pubKey",null);class he extends ce{constructor(e,t,n){super(e,t,n)}send(e,t){return new Promise(((e,t)=>{t("ChannelEndpoint.send(): send outside ChannelSocket not yet implemented")}))}set onMessage(e){y(!1,"ChannelEndpoint.onMessage: send/receive outside ChannelSocket not yet implemented")}}function de(e,t,n){return new Promise(((o,r)=>{const s=p.exec(e),i=n.encryptionKey;if(s){let e={type:"encrypted",channelID:s[1],timestampPrefix:s[2],_id:s[1]+s[2],encrypted_contents:a(t)};se.unwrap(i,e.encrypted_contents,"string").then((t=>{let s={...e,...z(t,"L1977")};s.contents&&(s.text=s.contents),s.user={name:s.sender_username?s.sender_username:"Unknown",_id:s.sender_pubKey},s.verificationToken&&!s.sender_pubKey?console.info("WARNING: message with verification token is lacking sender identity.\n         This may not be allowed in the future."):se.importKey("jwk",s.sender_pubKey,"ECDH",!0,[]).then((e=>{se.deriveKey(n.signKey,e,"HMAC",!1,["sign","verify"]).then((e=>{se.verify(e,s.sign,s.contents).then((t=>{t||(console.log("***** signature is NOT correct message (rejecting)"),console.log("verifyKey:"),console.log(Object.assign({},e)),console.log("m2.sign"),console.log(Object.assign({},s.sign)),console.log("m2.contents"),console.log(structuredClone(s.contents)),console.log("Message:"),console.log(Object.assign({},s)),console.trace(),r(null)),o(s)}))}))}))}))}else console.log("++++++++ #processMessage: ERROR - cannot parse channel ID / timestamp, invalid message"),console.log(Object.assign({},e)),console.log(Object.assign({},t)),r(null)}))}class ye{version="1";#_="b";#O;#E;#j;#B;#P;iv;salt;fileName;dateAndTime;shardServer;fileType;lastModified;actualSize;savedSize;constructor(e){const{version:t,type:n,id:o,key:r,id32:s,key32:a,verification:i,iv:c,salt:l,fileName:h,dateAndTime:d,shardServer:y,fileType:g,lastModified:u,actualSize:p,savedSize:f}=e;t&&(this.version=t),n&&(this.#_=n),this.id=o,this.key=r,s&&(this.id32=s),a&&(this.key32=a),i&&(this.#P=i),this.iv=c,this.salt=l,this.fileName=h,this.dateAndTime=d,this.shardServer=y,this.fileType=g,this.lastModified=u,this.actualSize=p,this.savedSize=f}#R(){this.#O&&this.#O}set id(e){w(e),this.#O=e,this.#j=N(e)}get id(){return y(this.#O,"object handle identifier is undefined"),this.#O}set key(e){w(e),this.#E=e,this.#B=N(e)}get key(){return y(this.#E,"object handle identifier is undefined"),this.#E}set id32(e){if(!L(e))throw new Error("Invalid base62 encoded ID");this.#j=e,this.#O=T(e)}set key32(e){if(!L(e))throw new Error("Invalid base62 encoded Key");this.#B=e,this.#E=T(e)}get id32(){return y(this.#j,"object handle id (32) is undefined"),this.#j}get key32(){return y(this.#B,"object handle key (32) is undefined"),this.#B}set verification(e){this.#P=e,this.#R()}get verification(){return y(this.#P,"object handle verification is undefined"),this.#P}get type(){return this.#_}}class ge{server;shardServer;channelServer;constructor(e,t,n){this.server=e+"/api/v1",this.channelServer=t+"/api/room/",this.shardServer=n?n+"/api/v1":"https://shard.3.8.4.land/api/v1"}#x(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let o=U(e,new Uint8Array(n-t).buffer);return new DataView(o).setUint32(n-4,t),s&&(console.log("#padBuf bytes:"),console.log(o.slice(-4))),o}#M(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const o=new DataView(t).getUint32(0,!0);return o<n&&(s&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=o),s&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}#I(e,t){return new Promise(((n,o)=>{try{se.importKey("raw",O(decodeURIComponent(e)),"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){o(e)}}))}#D(e,t){return new Promise(((n,o)=>{c(this.server+"/storeRequest?name="+e+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=W(e);n({salt:new Uint8Array(t.salt),iv:new Uint8Array(t.iv)})})).catch((e=>{console.log(`ERROR: ${e}`),o(e)}))}))}#T(e,t,n,o,r,s,a){return new Promise(((i,l)=>{this.#I(n,a).then((n=>{se.encrypt(e,n,s,"arrayBuffer").then((e=>{c(this.channelServer+r+"/storageRequest?size="+e.byteLength).then((e=>e.json())).then((n=>{n.hasOwnProperty("error")&&l("storage token request error");let r=JSON.stringify(n);this.storeData(o,t,s,a,r,e).then((e=>{e.error&&l(`storeObject() failed: ${e.error}`),e.image_id!=t&&l(`received imageId ${e.image_id} but expected ${t}`),i(e.verification_token)})).catch((e=>{console.log("ERROR in _storeObject(): ${e}"),l(e)}))}))}))}))}))}getObjectMetadata(e,t){return new Promise(((n,o)=>{const r=this.#x(e);se.generateIdKey(r).then((e=>{this.#D(e.id,t).then((o=>{const s={[oe]:!0,version:"1",type:t,id:e.id,key:e.key,iv:o.iv,salt:o.salt,paddedBuffer:r};n(s)})).catch((e=>o(e)))}))}))}storeObject(e,t,n,o){return new Promise(((r,a)=>{e instanceof Uint8Array&&(s&&console.log("converting Uint8Array to ArrayBuffer"),e=new Uint8Array(e).buffer),e instanceof ArrayBuffer||"ArrayBuffer"==e.constructor.name||(s&&console.log("buf must be an ArrayBuffer:"),console.log(e),a("buf must be an ArrayBuffer"));const i=e.byteLength;if(o){const e={[oe]:!0,version:"1",type:t,id:o.id,key:o.key,iv:o.iv,salt:o.salt,actualSize:i,verification:this.#T(o.paddedBuffer,o.id,o.key,t,n,o.iv,o.salt)};r(e)}else{const o=this.#x(e);se.generateIdKey(o).then((e=>{this.#D(e.id,t).then((s=>{const a={[oe]:!0,version:"1",type:t,id:e.id,key:e.key,iv:s.iv,salt:s.salt,actualSize:i,verification:this.#T(o,e.id,e.key,t,n,s.iv,s.salt)};r(a)})).catch((e=>a(e)))}))}}))}storeRequest(e){return new Promise(((t,n)=>{c(this.server+"/storeRequest?name="+e).then((e=>(e.ok||n(new Error("Network response was not OK")),e.arrayBuffer()))).then((e=>{t(e)})).catch((e=>{n(e)}))}))}storeData(e,t,n,o,r,s){return new Promise(((a,i)=>{c(this.server+"/storeData?type="+e+"&key="+b(t),{method:"POST",body:q({iv:n,salt:o,image:s,storageToken:(new TextEncoder).encode(r),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||i("response from storage server was not OK"),e.json()))).then((e=>{a(e)})).catch((e=>{i(e)}))}))}#N(e,t){return new Promise(((n,o)=>{try{let t=z(se.ab2str(new Uint8Array(e)),"L3062");t.error&&o(`#processData() error: ${t.error}`),s&&(console.log("#processData() JSON.parse() returned:"),console.log(t),console.warn("should this happen?"))}catch(e){}finally{const o=W(e);s&&(console.log("Payload is:"),console.log(o));const r=new Uint8Array(o.iv),a=new Uint8Array(o.salt),i=t.iv?"string"==typeof t.iv?O(t.iv):t.iv:void 0,c=t.salt?"string"==typeof t.salt?O(t.salt):t.salt:void 0;i&&!P(r,i)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${R(i)}`),console.log(`server iv: ${R(o.iv)}`)),c&&!P(a,c)&&(console.error("WARNING: salt from server differs from local copy (will use server)"),console.log(` object ID: ${t.id}`),console.log("server salt:"),console.log("data.salt as b64:"),console.log(R(o.salt)),console.log("data.salt unprocessed:"),console.log(o.salt),console.log("'salt' as b64:"),console.log(R(a)),console.log("salt unprocessed:"),console.log(a),console.log("local salt:"),t.salt?"string"==typeof t.salt?(console.log("h.salt is in string form (unprocessed):"),console.log(t.salt)):(console.log("h.salt is in arrayBuffer or Uint8Array"),console.log("h.salt as b64:"),console.log(R(t.salt)),console.log("h.salt unprocessed:"),console.log(t.salt)):console.log("h.salt is undefined"),console.log("handleSalt as b64:"),console.log(R(c)),console.log("handleSalt unprocessed:"),console.log(c)),s&&(console.log("will use nonce and salt of:"),console.log(`iv: ${R(r)}`),console.log(`salt : ${R(a)}`)),this.#I(t.key,a).then((e=>{const t=o.image;s&&(console.log("data.image:      "),console.log(o.image),console.log("encrypted_image: "),console.log(t)),se.unwrap(e,{content:t,iv:r},"arrayBuffer").then((e=>{const t=this.#M(e);s&&(console.log(" unwrapped img: "),console.log(t)),n(t)}))}))}}))}fetchData(e,t="arrayBuffer"){return new Promise(((n,o)=>{try{s&&(console.log("Calling fetchData():"),console.log(e),console.log(t)),e||o("SBObjectHandle is null or undefined"),"string"==typeof e.verification&&(e.verification=new Promise((t=>{t(e.verification)}))),e.verification.then((r=>{y(r,"fetchData(): missing verification token (?)");const a=e.shardServer?e.shardServer+"/api/v1":this.shardServer?this.shardServer:this.server;s&&console.log("fetching from server: "+a),c(a+"/fetchData?id="+b(e.id)+"&type="+e.type+"&verification_token="+r,{method:"GET"}).then((e=>(e.ok||o(new Error("Network response was not OK")),e.arrayBuffer()))).then((t=>this.#N(t,e))).then((e=>{n("string"===t?se.ab2str(new Uint8Array(e)):e)}))}))}catch(e){o(e)}}))}async retrieveImage(e,t,n,o,r){console.trace("retrieveImage()"),console.log(e);const s=n||e.previewId,a=o||e.previewKey,i=r||"p",c=t.find((e=>e.id&&e.id==s));if(console.log(c),c){y(c.verificationToken,"retrieveImage(): verificationToken missing (?)"),y(c.id,"retrieveImage(): id missing (?)");const e={type:i,id:c.id,key:a,verification:new Promise(((e,t)=>{c.verificationToken?e(c.verificationToken):t("retrieveImage(): verificationToken missing (?)")}))},t=await this.fetchData(e);return console.log(t),{url:"data:image/jpeg;base64,"+R(t,"b64")}}return{error:"Failed to fetch data - missing control message for that image"}}}class ue{#L;#U;#$;constructor(e,t=!1){e&&(this.#$=Object.assign({},e),this.#L=new ge(e.storage_server,e.channel_server,e.shard_server?e.shard_server:void 0),t&&(s=!0),s&&console.log("++++ Snackabra constructor ++++ setting DBG to TRUE ++++"))}connect(e,t,n){return s&&t&&console.log(t),s&&n&&console.log(n),new Promise((async o=>{this.#$?o(new le(this.#$,e,t,n)):o(Promise.any(r.map((o=>new le(o,e,t,n).ready))))}))}create(e,t,n){return new Promise((async(o,r)=>{try{const{channelData:s,exportable_privateKey:a}=await g(n);s.SERVER_SECRET=t;const i=(new TextEncoder).encode(JSON.stringify(s));let l=await c(e.channel_server+"/api/room/"+s.roomId+"/uploadRoom",{method:"POST",body:i});l=await l.json(),l.success?o({channelId:s.roomId,key:a}):r(JSON.stringify(l))}catch(e){r(e)}}))}get channel(){return this.#U}get storage(){return this.#L}get crypto(){return se}}var pe={Snackabra:ue,SBMessage:ie,Channel:ce,SBCrypto:Y,SB384:ae,arrayBufferToBase64:R,sbCrypto:se,version:o};return globalThis.SB||(globalThis.SB=pe),console.log("************ SNACKABRA jslib loaded **************"),console.log(globalThis.SB.version),t})()));