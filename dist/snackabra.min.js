!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>Oe,ChannelSocket:()=>xe,KeyPrefix:()=>ie,MessageBus:()=>b,NEW_CHANNEL_MINIMUM_BUDGET:()=>a,Protocol_AES_GCM_256:()=>Me,Protocol_ECDH:()=>_e,SB:()=>Ue,SB384:()=>Pe,SBChannelKeys:()=>Re,SBCrypto:()=>ue,SBMessage:()=>Ie,SBObjectHandle:()=>je,Snackabra:()=>Le,StorageApi:()=>Te,arrayBufferToBase62:()=>Z,arrayBufferToBase64:()=>U,assemblePayload:()=>re,b62regex:()=>G,base62:()=>N,base62ToArrayBuffer:()=>X,base62ToBase64:()=>Q,base62regex:()=>z,base64ToArrayBuffer:()=>x,base64ToBase62:()=>ee,compareBuffers:()=>m,decodeB64Url:()=>$,encodeB64Url:()=>F,extractPayload:()=>oe,getRandomValues:()=>S,hydrateKey:()=>de,isBase62Encoded:()=>V,jsonParseWrapper:()=>v,msgTtlToSeconds:()=>p,msgTtlToString:()=>w,sbCrypto:()=>Be,setDebugLevel:()=>g,stripChannelMessage:()=>d,validate_ChannelApiBody:()=>h,validate_ChannelMessage:()=>y,validate_SBChannelData:()=>l,validate_SBChannelHandle:()=>i,version:()=>s});var n,r=function(e,t,n,r){var s,a=arguments.length,o=a<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(o=(a<3?s(o):a>3?s(t,n,o):s(t,n))||o);return a>3&&o&&Object.defineProperty(t,n,o),o};const s="2.0.0-alpha.5 (build 41)",a=33554432;function o(e){return e.channelId&&43===e.channelId.length&&e.userPrivateKey&&"string"==typeof e.userPrivateKey&&e.userPrivateKey.length>0&&(!e.channelServer||"string"==typeof e.channelServer)&&(!e.channelData||c(e.channelData))}function i(e){if(e){if(e[me])return e;if(o(e))return{...e,[me]:!0};throw f&&console.error("invalid SBChannelHandle ... trying to ingest:\n",e),new Error("invalid SBChannelHandle")}throw new Error("invalid SBChannelHandle (null or undefined)")}function c(e){return e.channelId&&43===e.channelId.length&&e.ownerPublicKey&&"string"==typeof e.ownerPublicKey&&e.ownerPublicKey.length>0&&(!e.storageToken||e.storageToken.length>0)}function l(e){if(e){if(c(e))return e;throw u&&console.error("invalid SBChannelData ... trying to ingest:\n",e),new Error("invalid SBChannelData")}throw new Error("invalid SBChannelData (null or undefined)")}function h(e){if(e){if(e[ve])return e;if(e.channelId&&43===e.channelId.length&&e.path&&"string"==typeof e.path&&e.path.length>0&&e.userId&&"string"==typeof e.userId&&43===e.userId.length&&e.userPublicKey&&e.userPublicKey.length>0&&(!e.isOwner||"boolean"==typeof e.isOwner)&&(!e.apiPayloadBuf||e.apiPayloadBuf instanceof ArrayBuffer)&&e.timestamp&&Number.isInteger(e.timestamp)&&e.sign&&e.sign instanceof ArrayBuffer)return{...e,[ve]:!0};throw u&&console.error("invalid ChannelApiBody ... trying to ingest:\n",e),new Error("invalid ChannelApiBody")}throw new Error("invalid ChannelApiBody (null or undefined)")}function y(e){if(e){if(e[be])return e;if(!(e.f&&"string"==typeof e.f&&43===e.f.length&&e.c&&e.c instanceof ArrayBuffer&&e.ts&&Number.isInteger(e.ts)&&e.iv&&e.iv instanceof Uint8Array&&12===e.iv.length&&e.s&&e.s instanceof ArrayBuffer&&(!e.salt||e.salt instanceof ArrayBuffer))||e._id&&("string"!=typeof e._id||86!==e._id.length)||e.ready&&"boolean"!=typeof e.ready||e.timestampPrefix&&("string"!=typeof e.timestampPrefix||26!==e.timestampPrefix.length)||e.channelId&&("string"!=typeof e.channelId||43!==e.channelId.length)||e.i2&&("string"!=typeof e.i2||!/^[a-zA-Z0-9_]{4}$/.test(e.i2))||e.ttl&&!(Number.isInteger(e.ttl)&&e.ttl>=0&&e.ttl<=15))throw f&&console.error("invalid ChannelMessage ... trying to ingest:\n",e),new Error("invalid ChannelMessage");return{...e,[be]:!0}}throw new Error("invalid ChannelMessage (null or undefined)")}function d(e){const t={};if(!e.f)throw new Error("ERROR: missing 'f' ('from') in message");if(t.f=e.f,!e.c)throw new Error("ERROR: missing 'ec' ('encrypted contents') in message");if(t.c=e.c,!e.iv)throw new Error("ERROR: missing 'iv' ('nonce') in message");if(t.iv=e.iv,!e.salt)throw new Error("ERROR: missing 'salt' in message");if(t.salt=e.salt,!e.s)throw new Error("ERROR: missing 's' ('signature') in message");if(t.s=e.s,!e.ts)throw new Error("ERROR: missing 'ts' ('timestamp') in message");return t.ts=e.ts,e.ttl&&15!==e.ttl&&(t.ttl=e.ttl),e.t&&(t.t=e.t),e.i2&&"____"!==e.i2&&(t.i2=e.i2),t}var u=!1,f=!1;function g(e,t){t&&(f=e&&t),(u=e)&&console.warn("++++ [setDebugLevel]: setting DBG to TRUE ++++"),f&&console.warn("++++ [setDebugLevel]: ALSO setting DBG2 to TRUE (verbose) ++++")}globalThis.configuration&&!0===globalThis.configuration.DEBUG&&((u=!0)&&console.warn("++++ Setting DBG to TRUE based on 'configuration.DEBUG' ++++"),!0===globalThis.configuration.DEBUG2&&(f=!0,u&&console.warn("++++ ALSO setting DBG2 (verbose) ++++")));const p=[0,-1,-1,60,300,1800,7200,86400,604800,-1,-1,-1,-1,-1,1/0],w=["Ephemeral","<reserved>","<reserved>","One minute","Five minutes","Thirty minutes","Two hours","24 hours","7 days (one week)","<reserved>","<reserved>","<reserved>","<reserved>","<reserved>","Permastore (no TTL)"];class b{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function v(e,t,n){for(;e&&"string"==typeof e;)try{e=JSON.parse(e,n)}catch(n){throw new Error(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}function m(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=L(e),r=L(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function S(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{E(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}function k(e,t){return new Promise(((n,r)=>{try{fetch(e,t??{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>{n(e)})).catch((e=>{throw e}))}catch(e){const t=`[SBFetch] Error (fetch exception, might be normal operation): ${e}`;console.warn(t),r(t)}}))}function C(e){const t=" ***ERRORMSGSTART*** ",n=" ***ERRORMSGEND*** ";return e instanceof Error?(u&&console.error("[WrapError] Error: \n",e),new Error(t+e.message+n)):new Error(t+String(e)+n)}function E(e,t){if(!e){const e=` <<<<[_sb_assert] assertion failed: '${t}'>>>> `;throw u&&console.trace(e),new Error(e)}}function B(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}const A=/^([A-Za-z0-9+/_\-=]*)$/,K=[],P=[],R=[],D="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",I=D+"+/",M=D+"-_",_="=",O=16383;for(let e=0,t=I.length;e<t;++e)K[e]=I[e],P[e]=M[e],R[I.charCodeAt(e)]=e;function x(e){if(!A.test(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,r]=function(e){const t=e.length;let n=e.indexOf(_);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),s=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,r));let a=0;const o=r>0?n-4:n;let i;for(i=0;i<o;i+=4)t=R[e.charCodeAt(i)]<<18|R[e.charCodeAt(i+1)]<<12|R[e.charCodeAt(i+2)]<<6|R[e.charCodeAt(i+3)],s[a++]=t>>16&255,s[a++]=t>>8&255,s[a++]=255&t;return 2===r&&(t=R[e.charCodeAt(i)]<<2|R[e.charCodeAt(i+1)]>>4,s[a++]=255&t),1===r&&(t=R[e.charCodeAt(i)]<<10|R[e.charCodeAt(i+1)]<<4|R[e.charCodeAt(i+2)]>>2,s[a++]=t>>8&255,s[a++]=255&t),s}function j(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function T(e,t,n,r){let s;const a=new Array((r-n)/3);for(let o=n,i=0;o<r;o+=3,i++)s=(t.getUint8(o)<<16&16711680)+(t.getUint8(o+1)<<8&65280)+(255&t.getUint8(o+2)),a[i]=j(e,s);return a.join("")}R["-".charCodeAt(0)]=62,R["_".charCodeAt(0)]=63;const L=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function U(e,t="url"){if(null==e)return function(e,t){throw new Error("[_sb_exception] << SB lib error (L893: arrayBufferToBase64() -> null paramater) >>")}(),"";{const n=L(e),r=n.byteLength,s=r%3,a=r-s,o=new Array(Math.floor(a/O)+Math.sign(s)),i="url"==t?P:K,c="";let l=0;for(let e=0;e<a;e+=O)o[l++]=T(i,n,e,e+O>a?a:e+O);if(1===s){const e=n.getUint8(r-1);o[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===s){const e=(n.getUint8(r-2)<<8)+n.getUint8(r-1);o[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return o.join("")}}function F(e){return e.replaceAll("+","-").replaceAll("/","_")}function $(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;return t&&(E(1!==t,"InvalidLengthError: Input base64url string is the wrong length to determine padding"),e+=new Array(5-t).join("=")),e}const N="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",H=N[0],G=/^[A-Za-z0-9]*$/,z=G;function V(e){return G.test(e)}const q=32,W=new Map,J=new Map;for(let e=1;e<=q;e++){const t=Math.ceil(8*e/Math.log2(62));W.set(e,t),J.set(t,e)}const Y=W.get(q);function Z(e){function t(e,t){let n="",r=0n;for(const t of e)r=r<<8n|BigInt(t);for(;r>0n;r/=62n)n=N[Number(r%62n)]+n;return n.padStart(W.get(t),H)}const n=e instanceof ArrayBuffer?new Uint8Array(e):e;let r="";for(let e,s=n.byteLength,a=0;s>0;a+=e,s-=e)e=s>=q?q:s,r+=t(n.slice(a,a+e),e);return r}function X(e){if(!G.test(e))throw new Error("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");function t(e,t){try{let n=0n,r=new Uint8Array(t);for(let t=0;t<e.length;t++)n=62n*n+BigInt(N.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new Error("base62ToArrayBuffer: Invalid Base62 string.");for(let e=t-1;e>=0;e--,n>>=8n)r[e]=Number(0xffn&n);return r}catch(e){throw new Error("base62ToArrayBuffer: Invalid Base62 string.")}}try{let n=0,r=new Uint8Array(6*e.length/8);for(let s,a,o=0;o<e.length;o+=s,n+=a.byteLength)s=Math.min(e.length-o,Y),a=t(e.slice(o,o+s),J.get(s)),r.set(a,n);return r.buffer.slice(0,n)}catch(e){throw e}}function Q(e){return U(X(e))}function ee(e){return Z(x(e))}function te(e){if(null===e)return"0";if(void 0===e)return"u";if(Array.isArray(e))return"a";if(e instanceof ArrayBuffer)return"x";if(e instanceof Uint8Array)return"8";if("boolean"==typeof e)return"b";if(e instanceof DataView)return"v";if(e instanceof Date)return"d";if(e instanceof Map)return"m";if("number"==typeof e)return"number"==typeof(t=e)&&t>=-2147483648&&t<=2147483647&&t%1==0?"i":"n";var t;if(null!==e&&"object"==typeof e&&e.constructor===Object)return"o";if(e instanceof Set)return"t";if("string"==typeof e)return"s";throw console.error("[getType] Unsupported for object:",e),new Error("Unsupported type")}function ne(e){try{const t={};let n=0,r=0,s=[];for(const a in e)if(e.hasOwnProperty(a)){const o=e[a],i=te(o);switch(i){case"o":const e=ne(o);if(!e)throw new Error(`Failed to assemble payload for ${a}`);s.push(e);break;case"n":const t=new Uint8Array(8);new DataView(t.buffer).setFloat64(0,o),s.push(t.buffer);break;case"i":const n=new Uint8Array(4);new DataView(n.buffer).setInt32(0,o),s.push(n.buffer);break;case"d":const r=new Uint8Array(8);new DataView(r.buffer).setFloat64(0,o.getTime()),s.push(r.buffer);break;case"b":const c=new Uint8Array(1);c[0]=o?1:0,s.push(c.buffer);break;case"s":const l=(new TextEncoder).encode(o);s.push(l);break;case"x":s.push(o);break;case"8":s.push(o.buffer);break;case"m":const h=new Array;o.forEach(((e,t)=>{h.push([t,e])}));const y=ne(h);if(!y)throw new Error(`Failed to assemble payload for ${a}`);s.push(y);break;case"a":const d=new Array;o.forEach((e=>{d.push(e)}));const u=ne(d);if(!u)throw new Error(`Failed to assemble payload for ${a}`);s.push(u);break;case"t":const f=new Array;o.forEach((e=>{f.push(e)}));const g=ne(f);if(!g)throw new Error(`Failed to assemble payload for ${a}`);s.push(g);break;case"0":case"u":s.push(new ArrayBuffer(0));break;default:throw console.error(`[assemblePayload] Unsupported type: ${i}`),new Error(`Unsupported type: ${i}`)}const c=s[s.length-1].byteLength;n++,t[n.toString()]={n:a,s:r,z:c,t:i},r+=c}const a=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([a.byteLength]);let i=B(new Uint8Array(o.buffer),new Uint8Array(a));for(let e=0;e<s.length;e++)i=B(new Uint8Array(i),s[e]);return i}catch(e){return console.error(e),null}}function re(e){return u&&e instanceof ArrayBuffer&&console.warn("[assemblePayload] Warning: data is already an ArrayBuffer, make sure you are not double-encoding"),ne({ver003:!0,payload:e})}function se(e,t){switch(t){case"o":return ae(e);case"n":return new DataView(e).getFloat64(0);case"i":return new DataView(e).getInt32(0);case"d":return new Date(new DataView(e).getFloat64(0));case"b":return 1===new Uint8Array(e)[0];case"s":return(new TextDecoder).decode(e);case"a":const n=ae(e);if(!n)throw new Error(`Failed to assemble payload for ${t}`);return Object.values(n);case"m":const r=ae(e);if(!r)throw new Error(`Failed to assemble payload for ${t}`);const s=new Map;for(const e in r)s.set(r[e][0],r[e][1]);return s;case"t":const a=ae(e);if(!a)throw new Error(`Failed to assemble payload for ${t}`);const o=new Set;for(const e in a)o.add(a[e]);return o;case"x":return e;case"8":return new Uint8Array(e);case"0":return null;case"u":return;default:throw new Error(`Unsupported type: ${t}`)}}function ae(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=v((new TextDecoder).decode(e.slice(4,4+t)),"L1290"),r=4+t,s={};for(let t=1;t<=Object.keys(n).length;t++){const a=t.toString();if(n[a]){const t=n[a],o=t.s,i=t.z,c=t.t,l=e.slice(r+o,r+o+i);s[t.n]=se(l,c)}else console.log(`found nothing for index ${t}`)}return s}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function oe(e){return ae(e)}var ie,ce;function le(e){"string"==typeof e&&(e=x(e));const t=new Uint8Array(e);return 1==(1&t[t.length-1])?1:0}function he(e){try{if(e.length<=4)return;const t=e.slice(0,4),n=e.slice(4);switch(t.slice(0,3)){case ie.SBPublicKey:switch(t[3]){case ce.Uncompressed:{const e=X(n);if(96!==e.byteLength)return;const t=e.slice(48,96);return{x:U(e.slice(0,48)),y:U(t),ySign:le(t)}}case ce.CompressedEven:case ce.CompressedOdd:{const e=t[3]===ce.CompressedEven?0:1,r=X(n);if(48!==r.byteLength)return;const{x:s,y:a}=Ke(U(r),e);return{x:s,y:a,ySign:e}}default:console.error("KeySubPrefix not recognized")}break;case ie.SBPrivateKey:switch(t[3]){case ce.Uncompressed:{const e=X(n);if(144!==e.byteLength)return;const t=e.slice(48,96);return{x:U(e.slice(0,48)),y:U(t),ySign:le(t),d:U(e.slice(96,144))}}case ce.CompressedEven:case ce.CompressedOdd:{const e=t[3]===ce.CompressedEven?0:1,r=X(n);if(96!==r.byteLength)return;const s=r.slice(0,48),{x:a,y:o}=Ke(U(s),e);return{x:a,y:o,ySign:e,d:U(r.slice(48,96))}}case ce.Dehydrated:return void console.error("parseSB384string() - you need to rehydrate first ('hydrateKey()')");default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}return}catch(e){return void console.error("parseSB384string() - malformed input, exception: ",e)}}function ye(e,t,n){if(!e||64!==e.length||!t||64!==t.length||void 0===n)return;const r=new Uint8Array(96);return r.set(x(e),0),r.set(x(t),48),ie.SBPrivateKey+(0===n?ce.CompressedEven:ce.CompressedOdd)+Z(r)}function de(e,t){if(e.length<=4)return;const n=e.slice(0,4);switch(n.slice(0,3)){case ie.SBPublicKey:return e;case ie.SBPrivateKey:switch(n[3]){case ce.Uncompressed:case ce.CompressedEven:case ce.CompressedOdd:return e;case ce.Dehydrated:{if(!t)return void console.error("hydrateKey() - you need to provide pubKey to hydrate");const n=U(X(e.slice(4)).slice(0,48)),r=he(t);return r&&r.x&&void 0!==r.ySign?ye(r.x,n,r.ySign):void console.error("hydrateKey() - failed to parse public key")}default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}}!function(e){e.SBPublicKey="PNk",e.SBPrivateKey="Xj3",e.SBDehydratedKey="XjZ"}(ie||(ie={})),function(e){e.CompressedEven="2",e.CompressedOdd="3",e.Uncompressed="4",e.Dehydrated="x"}(ce||(ce={}));class ue{generateIdKey(e){if(!(e instanceof ArrayBuffer))throw new TypeError("Input must be an ArrayBuffer");return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({id_binary:n,key_material:r})}))}catch(e){n(e)}}))}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new Error("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,s){try{let a;const o={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new Error("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),a=await crypto.subtle.importKey("jwk",e,o[n],r,s)}else a=await crypto.subtle.importKey(e,t,o[n],r,s);return a}catch(a){const o=`... importKey() error: ${a}:`;throw u&&(console.error(o),console.log(e),console.log(t),console.log(n),console.log(r),console.log(s)),new Error(o)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{u&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}async encrypt(e,t,n){if(null===e)throw new Error("no contents");if(!n.iv)throw new Error("no nonce");return n.name?E("AES-GCM"===n.name,"Must be AES-GCM (L1951)"):n.name="AES-GCM",crypto.subtle.encrypt(n,t,e)}async wrap(e,t,n,r,s,a){E(e&&t&&n&&s,"wrapMessage(): missing required parameter(2)");const o=re(e);E(o,"wrapMessage(): failed to assemble payload"),E(o.byteLength<De,`wrapMessage(): body must be smaller than ${De/1024} KiB (we got ${o.byteLength/1024} KiB)})`),E(r,"wrapMessage(): missing salt");const i=crypto.getRandomValues(new Uint8Array(12)),c=25*Math.round(Date.now()/25),l=new DataView(new ArrayBuffer(8));l.setFloat64(0,c);var h={f:t,c:await Be.encrypt(o,n,{iv:i,additionalData:l}),iv:i,salt:r,s:await Be.sign(s,o),ts:c};if(f&&console.log("wrap() message is\n",h),a&&(a.sendTo&&(h.t=a.sendTo),a.ttl&&(h.ttl=a.ttl),a.subChannel))throw new Error("wrapMessage(): subChannel not yet supported");try{h=y(h)}catch(e){const t=`wrapMessage(): failed to validate message: ${e}`;throw console.error(t),new Error(t)}return h}unwrap(e,t){return new Promise((async(n,r)=>{try{if(!t.ts)throw new Error("unwrap() - no timestamp in encrypted message");const{c:r,iv:s}=t;E(r,"[unwrap] No contents in encrypted message (probably an error)");const a=new DataView(new ArrayBuffer(8));a.setFloat64(0,t.ts),n(await crypto.subtle.decrypt({name:"AES-GCM",iv:s,additionalData:a},e,r))}catch(e){u&&console.error(`unwrap(): cannot unwrap/decrypt - rejecting: ${e}`),r(e)}}))}sign(e,t){return crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-384"}},e,t)}verify(e,t,n){return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},e,t,n)}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}}function fe(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function ge(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name,s=e.constructor.ReadyFlag;E(s in this,"'readyFlagSymbol' missing yet getter accessed with @Ready pattern (fatal)"),E(this[s],`'${n}.${t}' getter accessed but object not 'ready' (fatal)`);const a=r.call(this);return E(null!=a,`'${n}.${t}' getter accessed but return value will be NULL (fatal)`),a}}}function pe(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;return"owner"in this&&E(!0===this.owner,`${t} getter or method accessed for object ${n} but callee is not channel owner`),r.call(this)}}}const we=["SBMessage","SBObjectHandle","SBChannelHandle","ChannelApiBody"],be=Symbol("SB_CHANNEL_MESSAGE_SYMBOL"),ve=Symbol("SB_CHANNEL_API_BODY_SYMBOL"),me=Symbol("SBChannelHandle"),Se=Symbol.for("SBMessage"),ke=Symbol.for("SBObjectHandle");function Ce(e,t){switch(t){case"SBMessage":return Se in e;case"SBObjectHandle":case"SBChannelHandle":return ke in e;default:return!1}}const Ee="SBMessageCache";"indexedDB"in globalThis&&(globalThis.sbMessageCache=new class{dbName;readyPromise;db;constructor(e,t=1){this.dbName=e,this.readyPromise=new Promise(((n,r)=>{if(!("indexedDB"in globalThis))return console.warn("IndexedDB is not supported in this environment. SBCache will not be functional."),void r("IndexedDB not supported");const s=indexedDB.open(e,t);s.onsuccess=()=>{this.db=s.result,n(this)},s.onerror=()=>{r(`Database error ('${e}): `+s.error)}}))}getObjStore(e,t="readonly"){e||(e=this.dbName),E(this.db,"Internal Error [L2009]");const n=this.db?.transaction(Ee,t),r=n?.objectStore(Ee);return E(r,"Internal Error [L2013]"),r}async add(e,t){return new Promise((async(n,r)=>{const s=this.getObjStore("readwrite").put({key:e,value:t});s.onsuccess=()=>{n()},s.onerror=()=>{r("[add] Received error accessing keys")}}))}async get(e){return new Promise((async(t,n)=>{await this.readyPromise;const r=this.getObjStore().get(e);r.onsuccess=()=>{t(r.result?.value)},r.onerror=()=>{n("[get] Received error accessing keys")}}))}getLowerUpper(e,t,n){const r=t.padEnd(26,"3");return[e+(n?`_${n}_`:"______")+t,r]}async getKnownMessageKeys(e,t,n){return new Promise((async(r,s)=>{await this.readyPromise;const a=this.getObjStore(),[o,i]=this.getLowerUpper(e,t,n),c=IDBKeyRange.bound(o,i,!1,!1),l=a?.getAllKeys(c);l||r(new Set),l.onsuccess=()=>{r(new Set(l.result))},l.onerror=()=>{s("[getKnownMessageKeys] Received error accessing keys")}}))}async getKnownMessages(e,t,n){return new Promise((async(r,s)=>{await this.readyPromise;const a=this.getObjStore(),[o,i]=this.getLowerUpper(e,t,n),c=IDBKeyRange.bound(o,i,!1,!1),l=a?.getAll(c);l||r(new Map),l.onsuccess=()=>{r(new Map(l.result))},l.onerror=()=>{s("[getKnownMessages] Received error accessing keys")}}))}}(Ee,1));const Be=new ue,Ae="============================================================\n";function Ke(e,t){const n=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),r=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),s=(n+1n)/4n,a=new Uint8Array(x(e)),o="0x"+Array.from(a,(e=>e.toString(16).padStart(2,"0"))).join("");var i=BigInt(o),c=function(e,t,n){if(1n===n)return 0n;let r=1n;for(e%=n;t>0n;)t%2n===1n&&(r=r*e%n),t>>=1n,e=e*e%n;return r}(i*i*i-3n*i+r,s,n);c%2n!==BigInt(t)&&(c=n-c);const l=c.toString(16).padStart(96,"0");return{x:e,y:U(new Uint8Array(l.match(/.{1,2}/g).map((e=>parseInt(e,16)))))}}class Pe{sb384Ready;static ReadyFlag=Symbol("SB384ReadyFlag");#t;#n;#r;#s;#a;#o;#i;#c;#l;constructor(e,t){this[Pe.ReadyFlag]=!1,this.sb384Ready=new Promise((async(n,r)=>{try{if(e)if(e instanceof CryptoKey){const n=await Be.exportKey("jwk",e);E(n&&n.x&&n.y,"INTERNAL"),n.d?(this.#t=!0,this.#a=n.d):(this.#t=!1,E(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#r=n.y}else if(e&&e instanceof Object&&"kty"in e){const n=e;E(n&&n.x&&n.y,"Cannot parse format of JWK key"),e.d?(this.#t=!0,this.#a=n.d):(this.#t=!1,E(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#r=n.y}else{if("string"!=typeof e)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=he(e);if(!n)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey | SBUserPublicKey | SBUserPrivateKey, or omitted)");const{x:r,y:s,d:a}=n;a?(this.#t=!0,this.#a=a):(this.#t=!1,E(!t,"ERROR creating SB384 object: key provided is not the requested private")),E(r&&s,"INTERNAL"),this.#n=r,this.#r=s}}else{f&&console.log("SB384() - generating new key pair");const e=await Be.generateKeys(),t=await Be.exportKey("jwk",e.privateKey);E(t&&t.x&&t.y&&t.d,"INTERNAL"),this.#t=!0,this.#n=t.x,this.#r=t.y,this.#a=t.d,f&&console.log("#### FROM SCRATCH",this.#t)}if(f&&console.log("SB384() constructor; x/y/d:\n",this.#n,"\n",this.#r,"\n",this.#a),this.#t&&(this.#o=await Be.importKey("jwk",this.jwkPrivate,"ECDH",!0,["deriveKey"])),this.#i=await Be.importKey("jwk",this.jwkPublic,"ECDH",!0,[]),this.#t){const e={...this.jwkPrivate,key_ops:["sign"]};f&&console.log("starting jwk (private):\n",e),this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["sign"])}else{const e={...this.jwkPublic,key_ops:["verify"]};f&&console.log("starting jwk (public):\n",e),this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["verify"])}const r=B(x(this.#n),x(this.#r));this.#l=Z(await crypto.subtle.digest("SHA-256",r)),f&&console.log("SB384() constructor; hash:\n",this.#l),this.#s=le(this.#r),f&&console.log("SB384() - constructor wrapping up",this),this[Pe.ReadyFlag]=!0,n(this)}catch(e){r("ERROR creating SB384 object failed: "+C(e))}}))}get SB384ReadyFlag(){return this[Pe.ReadyFlag]}get ready(){return this.sb384Ready}get private(){return this.#t}get hash(){return this.#l}get userId(){return this.hash}get ownerChannelId(){return this.hash}get privateKey(){if(!this.private)throw new Error("this is a public key, there is no 'privateKey' value");return this.#o}get signKey(){return this.#c}get publicKey(){return this.#i}get jwkPrivate(){return E(this.#t,"jwkPrivate() - not a private key"),E(this.#n&&this.#r&&this.#a,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:["deriveKey"],kty:"EC",x:this.#n,y:this.#r,d:this.#a}}get jwkPublic(){return E(this.#n&&this.#r,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:this.#n,y:this.#r}}get ySign(){return E(null!==this.#s,"ySign() - ySign is not available (fatal)"),this.#s}get userPublicKey(){return E(this.#n&&void 0!==this.#s,"userPublicKey() - sufficient key info is not available (fatal)"),ie.SBPublicKey+(0===this.#s?ce.CompressedEven:ce.CompressedOdd)+ee(this.#n)}get userPrivateKey(){E(this.#t,"userPrivateKey() - not a private key, there is no userPrivateKey");const e=ye(this.#n,this.#a,this.#s);return E(void 0!==e,"userPrivateKey() - failed to construct key, probably missing info (fatal)"),e}get userPrivateKeyDehydrated(){return E(this.#t&&this.#a,"userPrivateKey() - not a private key, and/or 'd' is missing, there is no userPrivateKey"),ie.SBPrivateKey+ce.Dehydrated+ee(this.#a)}}r([fe,ge],Pe.prototype,"private",null),r([fe,ge],Pe.prototype,"hash",null),r([fe,ge],Pe.prototype,"userId",null),r([fe,ge],Pe.prototype,"ownerChannelId",null),r([fe,ge],Pe.prototype,"privateKey",null),r([fe,ge],Pe.prototype,"signKey",null),r([fe,ge],Pe.prototype,"publicKey",null),r([fe],Pe.prototype,"jwkPrivate",null),r([fe],Pe.prototype,"jwkPublic",null),r([fe],Pe.prototype,"ySign",null),r([fe],Pe.prototype,"userPublicKey",null),r([fe],Pe.prototype,"userPrivateKey",null),r([fe],Pe.prototype,"userPrivateKeyDehydrated",null);class Re extends Pe{#h;sbChannelKeysReady;static ReadyFlag=Symbol("SBChannelKeysReadyFlag");#y;channelServer;constructor(e){if(null===e)throw new Error("SBChannelKeys constructor: you cannot pass 'null'");if(e)if("string"==typeof e)super(e,!0);else{if(!o(e))throw new Error("SBChannelKeys() constructor: invalid parameter (must be SBChannelHandle or SBUserPrivateKey)");{const t=i(e);super(t.userPrivateKey,!0),t.channelServer&&(this.channelServer=t.channelServer,"/"===this.channelServer[this.channelServer.length-1]&&(this.channelServer=this.channelServer.slice(0,-1))),this.#h=t.channelId,this.#y=t.channelData}}else super();this[Re.ReadyFlag]=!1,this.sbChannelKeysReady=new Promise((async(e,t)=>{try{if(u&&console.log("SBChannelKeys() constructor."),await this.sb384Ready,E(this.private,"Internal Error (L2476)"),this.#h){if(!this.#y){if(!this.channelServer)throw new Error("SBChannelKeys() constructor: either key is owner key, or handle contains channelData, or channelServer is provided ...");u&&console.log("++++ SBChannelKeys being initialized from server");var n=await this.callApi("/getChannelKeys");E((n=l(n)).channelId===this.#h,"Internal Error (L2493)"),this.#y=n}}else this.#h=this.ownerChannelId,this.#y={channelId:this.#h,ownerPublicKey:this.userPublicKey};this[Re.ReadyFlag]=!0,e(this)}catch(e){t("[SBChannelKeys] constructor failed. "+C(e))}}))}get ready(){return this.sbChannelKeysReady}get SBChannelKeysReadyFlag(){return this[Re.ReadyFlag]}get channelData(){return this.#y}get owner(){return this.private&&this.ownerChannelId&&this.channelId&&this.ownerChannelId===this.channelId}get channelId(){return this.#h}get handle(){return{[me]:!0,channelId:this.channelId,userPrivateKey:this.userPrivateKey,channelServer:this.channelServer,channelData:this.channelData}}callApi(e,t){return E(this.channelServer,"[ChannelApi.callApi] channelServer is unknown"),u&&console.log("ChannelApi.callApi: calling fetch with path:",e,"body:",t),E(this.#h&&e,"Internal Error (L2528)"),new Promise((async(n,r)=>{await this.sb384Ready;const s=25*Math.round(Date.now()/25),a=new ArrayBuffer(8);new DataView(a).setFloat64(0,s);const o=B(a,(new TextEncoder).encode(e).buffer),i=t?re(t):void 0,c=await Be.sign(this.signKey,i?B(o,i):o),l={channelId:this.#h,path:e,userId:this.userId,userPublicKey:this.userPublicKey,timestamp:s,sign:c};i&&(l.apiPayloadBuf=i);const y={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:re(h(l))};f&&console.log("==== ChannelApi.callApi: calling fetch with init:\n",y),function(e,t){return new Promise(((n,r)=>{k(e,t).then((async t=>{var s;t&&t.ok||r("[SBApiFetch] Network response was not 'ok' (fatal)");const a=t.headers.get("content-type");if(a){if(-1!==a.indexOf("application/json")){const e=await t.json();f&&console.log(`[SBApiFetch] json ('${e}'):\n`,e),s=v(e,"L489")}else{if(-1===a.indexOf("application/octet-stream"))return void r("SBApiFetch] Server responded with unknown content-type header (?)");s=oe(await t.arrayBuffer()).payload}if(!s||s.error||s.success&&!s.success){let e="[SBApiFetch] Network or Server error or cannot parse response";t.status&&(e+=" ["+t.status+"]"),s?.error&&(e+=": "+s.error),u&&console.error("[SBApiFetch] error:\n",e),r(new Error(e))}else f&&console.log("[SBApiFetch] Success:\n",Ae,e,"\n",Ae,s,"\n",Ae),n(s)}else r("[SBApiFetch] Server response missing content-type header (?)")})).catch((e=>{r(e)}))}))}(this.channelServer+"/api/v2/channel/"+this.#h+e,y).then((e=>{n(e)})).catch((e=>{r("[Channel.callApi] Error: "+C(e))}))}))}}r([fe,ge],Re.prototype,"channelData",null),r([fe,ge],Re.prototype,"owner",null),r([fe,ge],Re.prototype,"channelId",null),r([fe,ge],Re.prototype,"handle",null);const De=98304;class Ie{channel;contents;options;[Se]=!0;sbMessageReady;static ReadyFlag=Symbol("SBMessageReadyFlag");#d;salt;constructor(e,t,n={}){this.channel=e,this.contents=t,this.options=n,this.salt=crypto.getRandomValues(new Uint8Array(16)).buffer,this.sbMessageReady=new Promise((async t=>{if(await e.channelReady,this.options.protocol||(this.options.protocol=e.protocol),!this.options.protocol)throw new Error("SBMessage() - no protocol provided");this.#d=await Be.wrap(this.contents,this.channel.userId,await this.options.protocol.encryptionKey(this),this.salt,this.channel.signKey,n),this[Ie.ReadyFlag]=!0,t(this)}))}get ready(){return this.sbMessageReady}get SBMessageReadyFlag(){return this[Ie.ReadyFlag]}get message(){return this.#d}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}r([ge],Ie.prototype,"message",null);class Me{entropy;iterations;#u;constructor(e,t=1e5){this.entropy=e,this.iterations=t,this.#u=new Promise((async(e,t)=>{const n=(new TextEncoder).encode(this.entropy);e(await crypto.subtle.importKey("raw",n,{name:"PBKDF2"},!1,["deriveKey","deriveBits"]))}))}async#f(e){if(!this.#u)throw new Error("Protocol_AES_GCM_384.key() - encryption key not ready");return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:this.iterations,hash:"SHA-384"},await this.#u,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async encryptionKey(e){return this.#f(e.salt)}async decryptionKey(e,t){if(t.salt)return this.#f(t.salt);console.warn("Salt should always be present in ChannelMessage")}}class _e{#g=new Map;constructor(){}encryptionKey(e){return new Promise((async(t,n)=>{await e.channel.ready;const r=e.channel.channelId;E(r,"Internal Error (L2565)");const s=e.options.sendTo?e.options.sendTo:e.channel.channelData.ownerPublicKey,a=r+"_"+s;if(!this.#g.has(a)){const t=await crypto.subtle.deriveKey({name:"ECDH",public:(await new Pe(s).ready).publicKey},e.channel.privateKey,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);this.#g.set(a,t),console.log("++++ Protocol_ECDH.key() - newKey:",t)}const o=this.#g.get(a);E(o,"Internal Error (L2584)"),console.log("++++ Protocol_ECDH.key() - res:",o),t(o)}))}decryptionKey(e,t){return new Promise((async(n,r)=>{console.log("CALLING Protocol_ECDH.key() - msg:",t),await e.ready;const s=e.channelId;E(s,"Internal Error (L2594)");const a=e.visitors.get(t.f);if(!a)return void console.log("**** Protocol_ECDH.key() - sentFrom is unknown");const o=s+"_"+a;if(!this.#g.has(o)){const t=await crypto.subtle.deriveKey({name:"ECDH",public:(await new Pe(a).ready).publicKey},e.privateKey,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);this.#g.set(o,t)}const i=this.#g.get(o);E(i,"Internal Error (L2611)"),console.log("++++ Protocol_ECDH.key() - res:",i),n(i)}))}}class Oe extends Re{protocol;channelReady;static ReadyFlag=Symbol("ChannelReadyFlag");locked=!1;adminData;#p="";visitors=new Map;constructor(e,t){if(null===e)throw new Error("Channel() constructor: you cannot pass 'null'");f&&console.log("Channel() constructor called with handleOrKey:",e),super(e),this.protocol=t,this.channelReady=this.sbChannelKeysReady.then((()=>(this[Oe.ReadyFlag]=!0,this))).catch((e=>{throw e}))}get ready(){return this.channelReady}get ChannelReadyFlag(){return this[Oe.ReadyFlag]}get api(){return this}create(e,t){return E(null!==e,"[Channel.create] Missing storage token"),E(t||this.channelServer,"[Channel.create] Missing channel server"),t=t||this.channelServer,new Promise((async(n,r)=>{await this.channelReady,this.channelData.storageToken=e,u&&console.log("Will try to create channel with channelData:",this.channelData),this.callApi("/create",this.channelData).then((()=>{this.channelServer=t,E(this.channelData&&this.channelData.channelId&&this.userPrivateKey,"Internal Error [L2546]"),n({[me]:!0,channelId:this.channelData.channelId,userPrivateKey:this.userPrivateKey,channelServer:this.channelServer,channelData:this.channelData})})).catch((e=>{r("Channel.create() failed: "+C(e))}))}))}async deCryptChannelMessage(e,t,n){if(f&&console.log("Asked to decrypt:",t,n),n)try{const t=oe(n).payload;f&&console.log("++++ deCryptChannelMessage: msgBuf:\n",t);const r=y(t),s=r.f;if(!s)return;if(!this.visitors.has(s)){u&&console.log("++++ deCryptChannelMessage: need to update visitor table ...");const e=await this.callApi("/getPubKeys");if(!(e&&e instanceof Map))return;u&&console.log(Ae,"visitorMap:\n",e,"\n",Ae);for(const[t,n]of e)u&&console.log("++++ deCryptChannelMessage: adding visitor:",t,n),this.visitors.set(t,n)}E(this.visitors.has(s),`Cannot find sender userId hash ${s} in public key map`);const a=await(e.protocol?.decryptionKey(this,r));if(!a)return;const o=oe(await Be.unwrap(a,r)).payload;return f&&console.log("++++ deCryptChannelMessage: decrypted message:\n",o),o}catch(e){return void(u&&console.error("Message was not a payload of a ChannelMessage:\n",e))}}getLastMessageTimes(){throw new Error("Channel.getLastMessageTimes(): not supported in 2.0 yet")}getMessageKeys(e=100,t=!1){return new Promise((async(n,r)=>{E(this.channelId,"Channel.getMessageKeys: no channel ID (?)");let s=t?"&cursor="+this.#p:"";const a=await this.callApi("/getMessageKeys?currentMessagesLength="+e+s);E(a,"Channel.getMessageKeys: no messages (empty/null response)"),f&&console.log("getMessageKeys\n",a),n(a)}))}getMessages(e){return new Promise((async(t,n)=>{E(this.channelId,"Channel.getMessages: no channel ID (?)");const r=await this.callApi("/getMessages",e);E(r,"Channel.getMessages: no messages (empty/null response)"),f&&console.log(Ae,Ae,"getMessages - here are the raw ones\n",r,Ae,Ae);const s=new Map;for(const[e,t]of r.entries()){if(!this.protocol)throw new Error("Channel.getMessages(): need protocol to decrypt messages");const n=await this.deCryptChannelMessage(this,e,t);n&&s.set(e,n)}f&&console.log(Ae,"and here are decrypted ones, hopefully\n",Ae,s,"\n",Ae),t(s)}))}async send(e){const t=e instanceof Ie?e:new Ie(this,e);return await t.ready,this.callApi("/send",t.message)}getChannelKeys(){return this.callApi("/getChannelKeys")}getPubKeys(){return this.callApi("/getPubKeys")}updateCapacity(e){return this.callApi("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.callApi("/getRoomCapacity")}getStorageLimit(){return this.callApi("/getStorageLimit")}getMother(){return this.callApi("/getMother")}getJoinRequests(){return this.callApi("/getJoinRequests")}isLocked(){return new Promise((e=>this.callApi("/roomLocked").then((t=>{this.locked=!0===t.locked,e(this.locked)}))))}storageRequest(e){return this.callApi("/storageRequest?size="+e)}lock(){return this.callApi("/lockChannel")}acceptVisitor(e){return this.callApi("/acceptVisitor",{userId:e})}async getStorageToken(e){const t=await this.callApi(`/storageRequest?size=${e}`);return E(t.hasOwnProperty("token"),`[getStorageToken] cannot parse response ('${JSON.stringify(t)}')`),u&&console.log("getStorageToken():\n",t),t.token}budd(e){let{keys:t,storage:n,targetChannel:r}=e??{};return new Promise((async(s,a)=>{e&&e.hasOwnProperty("storage")&&void 0===e.storage&&a("If you omit 'storage' it defaults to Infinity, but you cannot set 'storage' to undefined");try{if(n||(n=1/0),r){if(this.channelId==r)throw new Error("[budd()]: You can't specify the same channel as targetChannel");if(t)throw new Error("[budd()]: You can't specify both a target channel and keys");s(this.callApi(`/budd?targetChannel=${r}&transferBudget=${n}`))}else{const e=new Pe(t);await e.ready;const r={[me]:!0,userPrivateKey:e.userPrivateKey,channelServer:this.channelServer,channelId:e.hash};let o=await this.callApi(`/budd?targetChannel=${r.channelId}&transferBudget=${n}`,r);o.success?s(r):a(JSON.stringify(o))}}catch(e){a(e)}}))}}r([fe,ge],Oe.prototype,"api",null),r([ge],Oe.prototype,"send",null),r([ge],Oe.prototype,"getChannelKeys",null),r([ge],Oe.prototype,"getPubKeys",null),r([ge,pe],Oe.prototype,"updateCapacity",null),r([ge,pe],Oe.prototype,"getCapacity",null),r([ge],Oe.prototype,"getStorageLimit",null),r([ge,pe],Oe.prototype,"getMother",null),r([ge,pe],Oe.prototype,"getJoinRequests",null),r([function(e,t,n){if(n&&n.value){const r=n.value;n.value=function(...s){try{return r.call(this,...s)}catch(r){return console.log(`ExceptionReject: ${C(r)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${C(r)}`)))}}}}],Oe.prototype,"isLocked",null),r([ge],Oe.prototype,"storageRequest",null),r([ge,pe],Oe.prototype,"lock",null),r([ge,pe],Oe.prototype,"acceptVisitor",null),r([ge],Oe.prototype,"getStorageToken",null),r([ge,pe],Oe.prototype,"budd",null);class xe extends Oe{channelSocketReady;static ReadyFlag=Symbol("ChannelSocketReadyFlag");#w;#b;#v=this.#m;#S=new Map;#k=!1;constructor(e,t){if(E(t,"ChannelSocket(): no onMessage handler provided"),!e.hasOwnProperty("channelId")||!e.hasOwnProperty("userPrivateKey"))throw new Error("ChannelSocket(): first argument must be valid SBChannelHandle");if(!e.channelServer)throw new Error("ChannelSocket(): no channel server provided (required)");super(e),this[n.ReadyFlag]=!1,this.#b=e.channelServer.replace(/^http/,"ws"),this.#v=t;const r=this.#b+"/api/v2/channel/"+e.channelId+"/websocket";this.#w={url:r,ready:!1,closed:!1,timeout:2e3},this.channelSocketReady=this.#C()}#m(e){E(!1,"NO MESSAGE HANDLER")}async#E(e){u&&console.log("Received socket message:",e)}#C(){return new Promise((async(e,t)=>{u&&console.log("++++ STARTED ChannelSocket.readyPromise()");const r=this.#w.url;this.#w.websocket&&3!==this.#w.websocket.readyState&&2!==this.#w.websocket.readyState||(this.#w.websocket=new WebSocket(r)),this.#w.websocket.addEventListener("message",this.#E),this.#w.websocket.addEventListener("open",(async()=>{this.#w.closed=!1,await this.ready,u&&console.log("++++++++ readyPromise() sending init"),this.#w.websocket.send(JSON.stringify({ready:!0}))})),this.#w.websocket.addEventListener("close",(e=>{this.#w.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.channelServer})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.channelServer}`),t("wbSocket() closed before it was opened (?)")})),this.#w.websocket.addEventListener("error",(e=>{this.#w.closed=!0,console.log("ChannelSocket() error: ",e),t("ChannelSocket creation error (see log)")})),setTimeout((()=>{if(this[n.ReadyFlag])u&&console.log("ChannelSocket() - this socket resolved",this);else{const e="ChannelSocket() - this socket is not resolving (waited 10s) ...";console.warn(e),t(e)}}),1e4),this[n.ReadyFlag]=!0,e(this)}))}get ready(){return this.channelSocketReady}get ChannelSocketReadyFlag(){return this[n.ReadyFlag]}get status(){if(!this.#w.websocket)return"CLOSED";switch(this.#w.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#v=e}get onMessage(){return this.#v}set enableTrace(e){this.#k=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}send(e){const t=e instanceof Ie?e:new Ie(this,e);return E(this.#w.websocket,"ChannelSocket.send() called before ready"),this.#w.closed&&(this.#k&&console.info("send() triggered reset of #readyPromise() (normal)"),this.channelSocketReady=this.#C(),this[n.ReadyFlag]=!1),new Promise((async(e,n)=>{switch(await t.ready,await this.ready,this.ChannelSocketReadyFlag||n("ChannelSocket.send() is confused - ready or not?"),this.#w.websocket.readyState){case 1:this.#k&&console.log("++++++++ ChannelSocket.send() will send message:",Object.assign({},t.message));const r=re(t.message);E(r,"ChannelSocket.send(): failed to assemble message");const s=U(await crypto.subtle.digest("SHA-256",r));this.#k&&(console.log("++++++++ ChannelSocket.send():Which has hash:"),console.log(s)),this.#S.set(s,e),this.#w.websocket.send(r),setTimeout((()=>{if(this.#S.has(s)){this.#S.delete(s);const e=`Websocket request timed out (no ack) after ${this.#w.timeout}ms (${s})`;console.error(e),n(e)}else this.#k&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#w.timeout);break;case 3:case 0:case 2:n("socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING")}}))}}n=xe,r([ge],xe.prototype,"onMessage",null),r([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&we.includes(n)&&E(Ce(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],xe.prototype,"send",null);class je{version="2";#B="b";#A;#K;#P;shardServer;iv;salt;fileName;dateAndTime;fileType;lastModified;actualSize;savedSize;constructor(e){const{version:t,type:n,id:r,key:s,verification:a,iv:o,salt:i,fileName:c,dateAndTime:l,fileType:h,lastModified:y,actualSize:d,savedSize:u}=e;if(n&&(this.#B=n),t)this.version=t;else if(s&&r)if(V(s)&&V(r))this.version="2";else{if(!A.test(s)||!A.test(r))throw new Error("Unable to determine version from key and id");this.version="1"}else this.version="2";r&&(this.id=r),s&&(this.key=s),a&&(this.verification=a),this.iv=o,this.salt=i,this.fileName=c,this.dateAndTime=l,this.fileType=h,this.lastModified=y,this.actualSize=d,this.savedSize=u}set id_binary(e){if(!e)throw new Error("Invalid id_binary");if(32!==e.byteLength)throw new Error("Invalid id_binary length");this.#A=e,Object.defineProperty(this,"id64",{get:()=>U(this.#A),enumerable:!1,configurable:!1}),Object.defineProperty(this,"id32",{get:()=>Z(this.#A),enumerable:!1,configurable:!1})}set key_binary(e){if(!e)throw new Error("Invalid key_binary");if(32!==e.byteLength)throw new Error("Invalid key_binary length");this.#K=e,Object.defineProperty(this,"key64",{get:()=>U(this.#K),enumerable:!1,configurable:!1}),Object.defineProperty(this,"key32",{get:()=>Z(this.#K),enumerable:!1,configurable:!1})}set id(e){if("string"==typeof e){if("1"===this.version){if(!A.test(e))throw new Error("Requested version 1, but id is not b64");this.id_binary=x(e)}else if("2"===this.version){if(!V(e))throw new Error("Requested version 2, but id is not b62");this.id_binary=X(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid ID type");if(32!==e.byteLength)throw new Error("Invalid ID length");this.id_binary=e}}set key(e){if("string"==typeof e){if("1"===this.version){if(!A.test(e))throw new Error("Requested version 1, but key is not b64");this.#K=x(e)}else if("2"===this.version){if(!V(e))throw new Error("Requested version 2, but key is not b62");this.#K=X(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid key type");if(32!==e.byteLength)throw new Error("Invalid key length");this.#K=e}}get id(){if(E(this.#A,"object handle id is undefined"),"1"===this.version)return U(this.#A);if("2"===this.version)return Z(this.#A);throw new Error("Invalid or missing version (internal error, should not happen)")}get key(){if(E(this.#K,"object handle key is undefined"),"1"===this.version)return U(this.#K);if("2"===this.version)return Z(this.#K);throw new Error("Invalid or missing version (internal error, should not happen)")}get id64(){throw new Error("Invalid id_binary")}get id32(){throw new Error("Invalid id_binary")}get key64(){throw new Error("Invalid key_binary")}get key32(){throw new Error("Invalid key_binary")}set verification(e){this.#P=e}get verification(){return E(this.#P,"object handle verification is undefined"),this.#P}get type(){return this.#B}}class Te{storageServer;constructor(e){E("string"==typeof e,"StorageApi() constructor requires a string (for storageServer)"),this.storageServer=e}#R(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=B(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),f&&console.log("#padBuf bytes:",r.slice(-4)),r}#D(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(f&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=r),f&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}#I(e,t){return new Promise(((n,r)=>{try{Be.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}#M(e,t){return new Promise(((n,r)=>{k(this.storageServer+"/api/v1/storeRequest?name="+Z(e)+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=oe(e).payload;n({salt:t.salt,iv:t.iv})})).catch((e=>{console.warn(`**** ERROR: ${e}`),r(e)}))}))}async#_(e,t,n,r,s,a,o){return new Promise((async(i,c)=>{try{const l=await this.#I(n,o),h=await Be.encrypt(e,l,{iv:a}),y=await s.getStorageToken(h.byteLength),d=await this.storeObject(r,t,a,o,y,h);d.error&&c(`storeObject() failed: ${d.error}`),d.image_id!=t&&c(`received imageId ${d.image_id} but expected ${t}`),i(d.verification_token)}catch(e){const t=`storeObject() failed: ${e}`;console.error(t),c(t)}}))}storeObject(e,t,n,r,s,a){return new Promise(((o,i)=>{if("string"!=typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeData()";console.error(e),i("errMsg")}k(this.storageServer+"/storeData?type="+e+"&key="+t,{method:"POST",body:re({iv:n,salt:r,image:a,storageToken:(new TextEncoder).encode(s),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||i("response from storage server was not OK"),e.json()))).then((e=>{o(e)})).catch((e=>{i(e)}))}))}storeData(e,t,n){return new Promise(((r,s)=>{if("string"==typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeObject()";console.error(e),s("errMsg")}e instanceof Uint8Array&&(f&&console.log("converting Uint8Array to ArrayBuffer"),e=new Uint8Array(e).buffer),e instanceof ArrayBuffer||"ArrayBuffer"==e.constructor.name||(f&&console.log("buf must be an ArrayBuffer:"),console.log(e),s("buf must be an ArrayBuffer"));const a=e.byteLength,o=n instanceof Oe?n:new Oe(n),i=this.#R(e);Be.generateIdKey(i).then((e=>{this.#M(e.id_binary,t).then((n=>{const s=Z(e.id_binary),c=Z(e.key_material),l={[ke]:!0,version:"2",type:t,id:s,key:c,iv:n.iv,salt:n.salt,actualSize:a,verification:this.#_(i,s,e.key_material,t,o,n.iv,n.salt)};r(l)})).catch((e=>s(e)))}))}))}#O(e,t){return new Promise(((n,r)=>{try{let t=v(Be.ab2str(new Uint8Array(e)),"L3062");t.error&&r(`#processData() error: ${t.error}`)}catch(e){}finally{const r=oe(e).payload;u&&(console.log("Payload (#processData) is:"),console.log(r));const a=new Uint8Array(r.iv),o=new ArrayBuffer(r.salt),i=t.iv?"string"==typeof t.iv?x(t.iv):t.iv:void 0,c=t.salt?"string"==typeof t.salt?x(t.salt):t.salt:void 0;var s;if(i&&!m(a,i)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${U(i)}`),console.log(`server iv: ${U(r.iv)}`)),c&&!m(o,c)&&(console.error("WARNING: salt from server differs from local copy (will use server)"),t.salt?"string"==typeof t.salt?(console.log("h.salt is in string form (unprocessed):"),console.log(t.salt)):(console.log("h.salt is in arrayBuffer or Uint8Array"),console.log("h.salt as b64:"),console.log(U(t.salt)),console.log("h.salt unprocessed:"),console.log(t.salt)):console.log("h.salt is undefined"),console.log("handleSalt as b64:"),console.log(U(c)),console.log("handleSalt unprocessed:"),console.log(c)),f&&(console.log("will use nonce and salt of:"),console.log(`iv: ${U(a)}`),console.log(`salt : ${U(o)}`)),"1"===t.version)s=x(t.key);else{if("2"!==t.version)throw new Error("Invalid or missing version (internal error, should not happen)");s=X(t.key)}this.#I(s,o).then((e=>{const t=r.image;f&&(console.log("data.image:      "),console.log(r.image),console.log("encrypted_image: "),console.log(t)),Be.unwrap(e,{c:t,iv:a}).then((e=>{const t=this.#D(e);u&&(console.log("#processData(), unwrapped img: "),console.log(t)),n(t)}))}))}}))}async#x(e,t,n,r){const s={method:"GET"};return new Promise((async(a,o)=>{k(e+t,s).then((e=>e.ok?e.arrayBuffer():null)).then((e=>null===e?null:this.#O(e,n))).then((e=>{null===e&&a(null),a("string"===r?Be.ab2str(new Uint8Array(e)):e)})).catch((e=>null))}))}fetchData(e,t="arrayBuffer"){return new Promise((async(n,r)=>{const s=new je(e);s||r("SBObjectHandle is null or undefined");const a=await s.verification,o=this.storageServer+"/api/v1";u&&console.log("fetchData(), fetching from server: "+o);const i="/fetchData?id="+s.id+"&type="+s.type+"&verification_token="+a,c=await this.#x(o,i,s,t);null!==c?(u&&console.log(`[fetchData] success: fetched from '${o}'`,c),n(c)):r("fetchData() failed")}))}}class Le{channelServer;storageServer;#j;#T=s;sbFetch=k;constructor(e,t,n){console.warn(`==== CREATING Snackabra object generation: ${this.#T} ====`),E("string"==typeof e,"[Snackabra] Invalid parameter type for constructor"),t&&!0===t&&(u=!0),u&&n&&!0===n&&(f=!0),u&&console.warn("++++ Snackabra constructor: setting DBG to TRUE ++++"),f&&console.warn("++++ Snackabra constructor: ALSO setting DBG2 to TRUE (verbose) ++++"),this.channelServer=e,this.storageServer="TODO",this.#j=new Te(this.storageServer)}attach(e){return new Promise(((t,n)=>{e.channelId?(e.channelServer?e.channelServer!==this.channelServer&&n("SBChannelHandle channelId does not match channelServer"):e.channelServer=this.channelServer,t(new Oe(e))):n("SBChannelHandle missing channelId")}))}create(e){return E(null!==e,"[create channel] Invalid parameter (null)"),new Promise((async(t,n)=>{try{let r;if("string"==typeof e)r=e;else if(e instanceof Oe){const t=e;await t.ready,t.channelServer||(t.channelServer=this.channelServer),r=await t.getStorageToken(a)}else n("Invalid parameter to create() - need a token or a budget channel");E(r,"[create channel] Failed to get storage token for the provided channel");const s=await(new Oe).ready;s.channelServer=this.channelServer,s.create(r).then((e=>{t(e)})).catch((e=>{n(e)}))}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),n(t)}}))}connect(e,t){if(E(e&&e.channelId&&e.userPrivateKey,"[connect] Invalid parameter (missing info)"),e.channelServer&&e.channelServer!==this.channelServer)throw new Error("SBChannelHandle channelId does not match channelServer (use a different Snackabra object)");const n={...e,[me]:!0,channelServer:this.channelServer};return u&&console.log("++++ Snackabra.connect() ++++",n),t?new xe(n,(e=>{console.log("MESSAGE (not caught):",e)})):new Oe(n)}get storage(){if("string"==typeof this.#j)throw new Error("StorageApi not initialized");return this.#j}get crypto(){return Be}get version(){return this.#T}}var Ue={Snackabra:Le,SBMessage:Ie,Channel:Oe,SBCrypto:ue,SB384:Pe,arrayBufferToBase64:U,base64ToArrayBuffer:x,arrayBufferToBase62:Z,base62ToArrayBuffer:X,sbCrypto:Be,version:s,setDebugLevel:g};return globalThis.SB||(globalThis.SB=Ue),console.warn(`==== SNACKABRA jslib (re)loaded, version '${globalThis.SB.version}' ====`),t})()));