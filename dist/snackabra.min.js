!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>ke,ChannelSocket:()=>Ee,KeyPrefix:()=>ce,MessageBus:()=>l,NEW_CHANNEL_MINIMUM_BUDGET:()=>s,SB:()=>Be,SB384:()=>ve,SBChannelKeys:()=>me,SBCrypto:()=>le,SBMessage:()=>Se,SBObjectHandle:()=>Ae,Snackabra:()=>Ke,StorageApi:()=>Ce,_assemblePayload:()=>ee,arrayBuffer32ToBase62:()=>V,arrayBufferToBase62:()=>N,arrayBufferToBase64:()=>M,assemblePayload:()=>te,assemblePayload2:()=>X,base62ToArrayBuffer:()=>H,base62ToArrayBuffer32:()=>G,base62ToBase64:()=>z,base64ToArrayBuffer:()=>P,base64ToBase62:()=>W,compareBuffers:()=>j,decodeB64Url:()=>ie,encodeB64Url:()=>ae,encryptedContentsMakeBinary:()=>g,extractPayload:()=>oe,extractPayload2:()=>ne,getRandomValues:()=>f,isBase62Encoded:()=>q,jsonParseWrapper:()=>Y,msgTtlToSeconds:()=>i,msgTtlToString:()=>c,partition:()=>Z,sbCrypto:()=>be,version:()=>r});var n=function(e,t,n,r){var s,o=arguments.length,a=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(a=(o<3?s(a):o>3?s(t,n,a):s(t,n))||a);return o>3&&a&&Object.defineProperty(t,n,a),a};const r="2.0.0-alpha.5 (build 22b)",s=33554432;var o=!0,a=!1;const i=[0,60,300,1200,3600,14400,64800,259200,1036800,4147200,31622400,0,0,0,0,1/0],c=["Ephemeral","One minute","Five minutes","Twenty minutes","One hour","4 hours","18 hours","72 hours","12 days","48 days","One year","<reserved>","<reserved>","<reserved>","<reserved>","Permastore (no limit)"];class l{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function h(e,t){return new Promise(((n,r)=>{try{fetch(e,t??{method:"GET"}).then((e=>{n(e)})).catch((e=>{const t=`[SBFetch] Error (fetch through a reject, might be normal): ${e}`;console.warn(t),r(t)}))}catch(e){const t=`[SBFetch] Error (fetch exception, might be normal operation): ${e}`;console.warn(t),r()}}))}function y(e){return e instanceof Error?e:new Error(String(e))}function d(e,t){throw new Error("[_sb_exception] << SB lib error ("+e+": "+t+") >>")}function u(e,t){if(!e){const e=`[_sb_assert] << SB assertion error: ${t} >>`;throw o&&console.trace(e),new Error(e)}}function g(e){try{let t,n;if(a&&(console.log("=+=+=+=+ processing content"),console.log(e.content.constructor.name)),"string"==typeof e.content)try{t=P(decodeURIComponent(e.content))}catch(e){throw new Error("EncryptedContents is string format but not base64 (?)")}else{const n=e.content.constructor.name;u("ArrayBuffer"===n||"Uint8Array"===n,"undetermined content type in EncryptedContents object"),t=e.content}if(a&&console.log("=+=+=+=+ processing nonce"),"string"==typeof e.iv)a&&(console.log("got iv as string:"),console.log(structuredClone(e.iv))),n=P(decodeURIComponent(e.iv)),a&&(console.log("this was turned into array:"),console.log(structuredClone(n)));else if("Uint8Array"===e.iv.constructor.name||"ArrayBuffer"===e.iv.constructor.name)a&&console.log("it's an array already"),n=new Uint8Array(e.iv);else{a&&console.log("probably a dictionary");try{n=new Uint8Array(Object.values(e.iv))}catch(t){o&&(console.error("ERROR: cannot figure out format of iv (nonce), here's the input object:"),console.error(e.iv)),u(!1,"undetermined iv (nonce) type, see console")}}return a&&(console.log("decided on nonce as:"),console.log(n)),u(12==n.length,`encryptedContentsMakeBinary(): nonce should be 12 bytes but is not (${n.length})`),{content:t,iv:n,timestamp:e.timestamp}}catch(e){const t=`encryptedContentsMakeBinary() failed: ${e}`;throw o&&console.error(t),new Error(t)}}function f(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{u(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}const p=/([A-Za-z0-9+/_\-=]{64})([01]{42})/,w=/^([A-Za-z0-9+/_\-=]*)$/;function b(e){return w.test(e)}const v=b,m=[],S=[],k=[],E="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",A=E+"+/",C=E+"-_",K="=",B=16383;for(let e=0,t=A.length;e<t;++e)m[e]=A[e],S[e]=C[e],k[A.charCodeAt(e)]=e;function P(e){if(!b(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,r]=function(e){const t=e.length;let n=e.indexOf(K);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),s=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,r));let o=0;const a=r>0?n-4:n;let i;for(i=0;i<a;i+=4)t=k[e.charCodeAt(i)]<<18|k[e.charCodeAt(i+1)]<<12|k[e.charCodeAt(i+2)]<<6|k[e.charCodeAt(i+3)],s[o++]=t>>16&255,s[o++]=t>>8&255,s[o++]=255&t;return 2===r&&(t=k[e.charCodeAt(i)]<<2|k[e.charCodeAt(i+1)]>>4,s[o++]=255&t),1===r&&(t=k[e.charCodeAt(i)]<<10|k[e.charCodeAt(i+1)]<<4|k[e.charCodeAt(i+2)]>>2,s[o++]=t>>8&255,s[o++]=255&t),s}function R(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function O(e,t,n,r){let s;const o=new Array((r-n)/3);for(let a=n,i=0;a<r;a+=3,i++)s=(t.getUint8(a)<<16&16711680)+(t.getUint8(a+1)<<8&65280)+(255&t.getUint8(a+2)),o[i]=R(e,s);return o.join("")}k["-".charCodeAt(0)]=62,k["_".charCodeAt(0)]=63;const I=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function j(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=I(e),r=I(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function M(e,t="url"){if(null==e)return d("L893","arrayBufferToBase64() -> null paramater"),"";{const n=I(e),r=n.byteLength,s=r%3,o=r-s,a=new Array(Math.floor(o/B)+Math.sign(s)),i="url"==t?S:m,c="";let l=0;for(let e=0;e<o;e+=B)a[l++]=O(i,n,e,e+B>o?o:e+B);if(1===s){const e=n.getUint8(r-1);a[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===s){const e=(n.getUint8(r-2)<<8)+n.getUint8(r-1);a[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return a.join("")}}const D="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",x=/^(a32\.)?[0-9A-Za-z]{43}$/,T=/^[0-9a-zA-Z]*$/,_=new Map([[32,43],[16,22],[8,11],[4,6]]),L=new Map(Array.from(_,(([e,t])=>[t,e]))),$=Array.from(L.keys()).sort(((e,t)=>e-t));function U(e,t){if(e.byteLength!==t||!_.has(t))throw new Error("[arrayBufferToBase62] Decoding error");let n="";for(let t=BigInt("0x"+Array.from(new Uint8Array(e)).map((e=>e.toString(16).padStart(2,"0"))).join(""));t>0n;t/=62n)n=D[Number(t%62n)]+n;return n.padStart(_.get(t),"0")}function N(e){let t=e.byteLength;if(t%4!=0)throw new Error("[arrayBufferToBase62] Must be multiple of 4 bytes (32 bits).");let n=0,r="";for(;t>0;){let s=2**Math.min(Math.floor(Math.log2(t)),5);r+=U(e.slice(n,n+s),s),n+=s,t-=s}return r}function F(e,t){let n=0n;try{for(let t=0;t<e.length;t++)n=62n*n+BigInt(D.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new Error(`base62ToArrayBuffer: value exceeds ${8*t} bits.`);const r=new ArrayBuffer(t),s=new DataView(r);for(let e=0;e<t/4;e++){const r=Number(BigInt.asUintN(32,n));s.setUint32(4*(t/4-e-1),r),n>>=32n}return r}catch(e){throw console.error("[_base62ToArrayBuffer] Error: ",e),e}}function H(e){if(!T.test(e))throw new Error("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");let t,n=0,r=0,s=43,o=new Uint8Array(e.length);try{for(;n<e.length;){if(t=$.filter((t=>t<=e.length-n)).pop(),s<43&&t>=s)throw new Error("cannot decypher b62 string (incorrect length)");s=t;let a=e.slice(n,n+t);const i=new Uint8Array(F(a,L.get(t)));o.set(i,r),n+=t,r+=i.byteLength}return o.buffer.slice(0,r)}catch(e){throw console.error("[base62ToArrayBuffer] Error:",e),e}}function G(e){if(!x.test(e))throw new Error(`base62ToArrayBuffer32: string must match: ${x}, value provided was ${e}`);return H(e)}function V(e){if(32!==e.byteLength)throw new Error("arrayBufferToBase62: buffer must be exactly 32 bytes (256 bits).");return N(e)}function z(e){return M(G(e))}function W(e){return N(P(e))}function q(e){return x.test(e)}function J(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function Z(e,t){throw`partition() not tested on TS yet - (${e}, ${t})`}function Y(e,t,n){for(;e&&"string"==typeof e;)try{e=JSON.parse(e,n)}catch(n){throw new Error(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}function X(e){try{const t={version:"002"};let n=0,r=0;for(const s in e)n++,t[n.toString()]={name:s,start:r,size:e[s].byteLength},r+=e[s].byteLength;const s=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([s.byteLength]);let a=J(new Uint8Array(o.buffer),new Uint8Array(s));for(const t in e)a=J(new Uint8Array(a),e[t]);return a}catch(e){return console.error(e),null}}function Q(e){return Array.isArray(e)?"a":e instanceof ArrayBuffer?"x":"boolean"==typeof e?"b":e instanceof DataView?"v":e instanceof Date?"d":e instanceof Map?"m":"number"==typeof e?"number"==typeof(t=e)&&t>=-2147483648&&t<=2147483647&&t%1==0?"i":"n":null!==e&&"object"==typeof e&&e.constructor===Object?"o":e instanceof Set?"t":"string"==typeof e?"s":!ArrayBuffer.isView(e)||e instanceof DataView?"Unknown":"T";var t}function ee(e){try{const t={};let n=0,r=0,s=[];for(const o in e)if(e.hasOwnProperty(o)){const a=e[o],i=Q(a);switch(i){case"o":const e=ee(a);if(!e)throw new Error(`Failed to assemble payload for ${o}`);s.push(e);break;case"n":const t=new Uint8Array(8);new DataView(t.buffer).setFloat64(0,a),s.push(t.buffer);break;case"i":const n=new Uint8Array(4);new DataView(n.buffer).setInt32(0,a),s.push(n.buffer);break;case"d":const r=new Uint8Array(8);new DataView(r.buffer).setFloat64(0,a.getTime()),s.push(r.buffer);break;case"b":const c=new Uint8Array(1);c[0]=a?1:0,s.push(c.buffer);break;case"s":const l=(new TextEncoder).encode(a);s.push(l);break;case"x":s.push(a);break;case"m":const h=new Array;a.forEach(((e,t)=>{h.push([t,e])}));const y=ee(h);if(!y)throw new Error(`Failed to assemble payload for ${o}`);s.push(y);break;case"a":const d=new Array;a.forEach((e=>{d.push(e)}));const u=ee(d);if(!u)throw new Error(`Failed to assemble payload for ${o}`);s.push(u);break;case"t":const g=new Array;a.forEach((e=>{g.push(e)}));const f=ee(g);if(!f)throw new Error(`Failed to assemble payload for ${o}`);s.push(f);break;default:throw new Error(`Unsupported type: ${i}`)}const c=s[s.length-1].byteLength;n++,t[n.toString()]={n:o,s:r,z:c,t:i},r+=c}const o=(new TextEncoder).encode(JSON.stringify(t)),a=new Uint32Array([o.byteLength]);let i=J(new Uint8Array(a.buffer),new Uint8Array(o));for(let e=0;e<s.length;e++)i=J(new Uint8Array(i),s[e]);return i}catch(e){return console.error(e),null}}function te(e){return ee({version:"003",payload:e})}function ne(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=Y((new TextDecoder).decode(e.slice(4,4+t)),"L533"),r=4+t;switch(n.version||(n.version="001"),n.version){case"001":throw new Error("extractPayload() exception: version 001 is no longer supported");case"002":{const t=[];for(let s=1;s<Object.keys(n).length;s++){const o=s.toString();if(n[o]){const s=n[o].start,a=n[o].size;t[n[o].name]=e.slice(r+s,r+s+a)}else console.log(`found nothing for index ${s}`)}return t}default:throw new Error("Unsupported payload version ("+n.version+") - fatal")}}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function re(e,t){switch(t){case"o":return se(e);case"n":return new DataView(e).getFloat64(0);case"i":return new DataView(e).getInt32(0);case"d":return new Date(new DataView(e).getFloat64(0));case"b":return 1===new Uint8Array(e)[0];case"s":return(new TextDecoder).decode(e);case"b":case"x":return e;case"a":const n=se(e);if(!n)throw new Error(`Failed to assemble payload for ${t}`);return Object.values(n);case"m":const r=se(e);if(!r)throw new Error(`Failed to assemble payload for ${t}`);const s=new Map;for(const e in r)s.set(r[e][0],r[e][1]);return s;case"t":const o=se(e);if(!o)throw new Error(`Failed to assemble payload for ${t}`);const a=new Set;for(const e in o)a.add(o[e]);return a;default:throw new Error(`Unsupported type: ${t}`)}}function se(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=Y((new TextDecoder).decode(e.slice(4,4+t)),"L1308"),r=4+t,s={};for(let t=1;t<=Object.keys(n).length;t++){const o=t.toString();if(n[o]){const t=n[o],a=t.s,i=t.z,c=t.t,l=e.slice(r+a,r+a+i);s[t.n]=re(l,c)}else console.log(`found nothing for index ${t}`)}return s}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function oe(e){return se(e)}function ae(e){return e.replaceAll("+","-").replaceAll("/","_")}function ie(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;return t&&(u(1!==t,"InvalidLengthError: Input base64url string is the wrong length to determine padding"),e+=new Array(5-t).join("=")),e}var ce;!function(e){e.SBPublicKey="PNk2",e.SBPrivateKey="Xj3p"}(ce||(ce={}));class le{generateIdKey(e){return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({id_binary:n,key_material:r})}))}catch(e){n(e)}}))}extractPubKey(e){try{const t={...e};return delete t.d,delete t.dp,delete t.dq,delete t.q,delete t.qi,t.key_ops=[],t}catch(e){return console.error(e),null}}async#t(e,t){let n=0,r=M(e);for(;r!==t;){if(n++>160)return!1;r=M(e=await crypto.subtle.digest("SHA-384",e))}return!0}async compareHashWithKey(e,t){if(!e||!t)return!1;let n=t.x,r=t.y;if(!n||!r)try{const e=Y(t,"L1787");e.x&&(n=e.x),e.y&&(r=e.y)}catch{return!1}const s=J(P(ie(n)),P(ie(r)));return N(await crypto.subtle.digest("SHA-256",s))===e||await this.#t(s,e)}async verifyChannelId(e,t){return await this.compareHashWithKey(t,e)}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new Error("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,s){try{let o;const a={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new Error("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),o=await crypto.subtle.importKey("jwk",e,a[n],r,s)}else o=await crypto.subtle.importKey(e,t,a[n],r,s);return o}catch(a){const i=`... importKey() error: ${a}:`;throw o&&(console.error(i),console.log(e),console.log(t),console.log(n),console.log(r),console.log(s)),new Error(i)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{o&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}deriveKey(e,t,n,r,s){return new Promise((async(o,a)=>{let i;switch(n){case"AES-GCM":i={name:"AES-GCM",length:256};break;case"HMAC":i={name:"HMAC",hash:"SHA-256",length:256};break;default:throw new Error(`deriveKey() - unknown type: ${n}`)}let c=t;if("private"===c.type){const e=await this.exportKey("jwk",c);u(e,"INTERNAL (L1878)"),delete e.d,delete e.alg,c=await this.importKey("jwk",e,"ECDH",!0,[]),u(c,"INTERNAL (L1882)")}u("public"===c.type,"INTERNAL (L1884)");try{o(await crypto.subtle.deriveKey({name:"ECDH",public:c},e,i,r,s))}catch(o){console.error(o,e,t,n,r,s),a(o)}}))}encrypt(e,t,n,r="encryptedContents"){return new Promise((async(s,o)=>{try{null===e&&o(new Error("no contents")),n.iv||(u("arrayBuffer"!==r,"Must provide nonce if you just want the arraybuffer back (L1959)"),n.iv=crypto.getRandomValues(new Uint8Array(12))),n.name?u("AES-GCM"===n.name,"Must be AES-GCM (L1951)"):n.name="AES-GCM","string"==typeof e&&(e=(new TextEncoder).encode(e));const a=await crypto.subtle.encrypt(n,t,e);s("encryptedContents"===r?{content:M(a),iv:M(n.iv)}:a)}catch(e){o(e)}}))}wrap(e,t,n){return new Promise((r=>{let s;s="string"===n?be.str2ab(t):t;const o=25*Math.round(Date.now()/25),a=new DataView(new ArrayBuffer(8));a.setFloat64(0,o),be.encrypt(s,e,{additionalData:a}).then((e=>{r({...e,timestamp:o})}))}))}unwrap(e,t,n){return new Promise((async(r,s)=>{try{if(!t.timestamp)throw new Error("unwrap() - no timestamp in encrypted contents");const{content:s,iv:o}=g(t),a=new DataView(new ArrayBuffer(8));a.setFloat64(0,t.timestamp);const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:o,additionalData:a},e,s);"string"===n?r((new TextDecoder).decode(i)):"arrayBuffer"===n&&r(i)}catch(e){o&&console.error(`unwrap(): cannot unwrap/decrypt - rejecting: ${e}`),s(e)}}))}async sign(e,t){return new Promise((async(n,r)=>{try{const r=(new TextEncoder).encode(t);n(M(await crypto.subtle.sign("HMAC",e,r)))}catch(e){r(e)}}))}verify(e,t,n){return new Promise(((r,s)=>{try{crypto.subtle.verify("HMAC",e,P(t),be.str2ab(n)).then((e=>{r(e)}))}catch(e){s(y(e))}}))}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}compareKeys(e,t){return null!=e&&null!=t&&"object"==typeof e&&"object"==typeof t&&e.x===t.x&&e.y===t.y}}function he(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function ye(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name,s=`${n}ReadyFlag`;u(s in this,`'${n}.${s} missing yet getter accessed with @Ready pattern (fatal)`),u(this[s],`'${n}.${t}' getter accessed but object not 'ready' (fatal)`);const o=r.call(this);return u(null!=o,`'${n}.${t}' getter accessed but return value will be NULL (fatal)`),o}}}function de(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;return"owner"in this&&u(!0===this.owner,`${t} getter or method accessed for object ${n} but callee is not channel owner`),r.call(this)}}}const ue=["SBMessage","SBObjectHandle","SBChannelHandle"],ge=Symbol("SBChannelHandle"),fe=Symbol.for("SBMessage"),pe=Symbol.for("SBObjectHandle");function we(e,t){switch(t){case"SBMessage":return fe in e;case"SBObjectHandle":case"SBChannelHandle":return pe in e;default:return!1}}const be=new le;class ve{sb384Ready;SB384ReadyFlag=!1;#n;#r;#s;#o;#a;#i;#c;constructor(e,t){this.sb384Ready=new Promise((async(n,r)=>{try{if(e)if(e instanceof CryptoKey){const n=await be.exportKey("jwk",e);u(n&&n.x&&n.y,"INTERNAL"),n.d?(this.#n=!0,this.#o=n.d):(this.#n=!1,u(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#r=n.x,this.#s=n.y}else if(e&&e instanceof Object&&"kty"in e){const n=e;u(n&&n.x&&n.y,"Cannot parse format of JWK key"),e.d?(this.#n=!0,this.#o=n.d):(this.#n=!1,u(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#r=n.x,this.#s=n.y}else{if("string"!=typeof e)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=function(e){try{if(e.length<=4)return;const t=e.slice(0,4),n=e.slice(4);switch(t){case ce.SBPublicKey:{const e=H(n);if(96!==e.byteLength)return;return{prefix:ce.SBPublicKey,x:M(e.slice(0,48)),y:M(e.slice(48,96))}}case ce.SBPrivateKey:{const e=H(n);if(144!==e.byteLength)return;return{prefix:ce.SBPrivateKey,x:M(e.slice(0,48)),y:M(e.slice(48,96)),d:M(e.slice(96,144))}}default:return}}catch(e){return void console.error("parseSB384string() - malformed input, exception: ",e)}}(e);if(!n)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey | SBUserPublicKey | SBUserPrivateKey, or omitted)");const{x:r,y:s,d:o}=n;o?(this.#n=!0,this.#o=o):(this.#n=!1,u(!t,"ERROR creating SB384 object: key provided is not the requested private")),u(r&&s,"INTERNAL"),this.#r=r,this.#s=s}}else{o&&console.log("SB384() - generating new key pair");const e=await be.generateKeys(),t=await be.exportKey("jwk",e.privateKey);u(t&&t.x&&t.y&&t.d,"INTERNAL"),this.#n=!0,this.#r=t.x,this.#s=t.y,this.#o=t.d}a&&console.log("SB384() constructor; x/y/d:\n",this.#r,"\n",this.#s,"\n",this.#o),this.#n&&(this.#a=await be.importKey("jwk",this.jwkPrivate,"ECDH",!0,["deriveKey"])),this.#i=await be.importKey("jwk",this.jwkPublic,"ECDH",!0,[]);const r=J(P(this.#r),P(this.#s));this.#c=N(await crypto.subtle.digest("SHA-256",r)),a&&console.log("SB384() constructor; hash:\n",this.#c),this.SB384ReadyFlag=!0,n(this)}catch(e){r("ERROR creating SB384 object failed: "+y(e))}})),this.sb384Ready.then((()=>{this.SB384ReadyFlag=!0,a&&console.log("SB384() - constructor wrapping up, ready:",this.SB384ReadyFlag)})).catch((e=>{throw e}))}get ready(){return this.sb384Ready}get private(){return this.#n}get hash(){return this.#c}get userId(){return this.hash}get ownerChannelId(){if(!this.private)throw new Error("ownerChannelId() - not a private key, cannot be an owner key");return this.hash}get privateKey(){if(!this.private)throw new Error("this is a public key, there is no 'privateKey' value");return this.#a}get publicKey(){return this.#i}get jwkPrivate(){return u(this.#n,"jwkPrivate() - not a private key"),u(this.#r&&this.#s&&this.#o,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:["deriveKey"],kty:"EC",x:this.#r,y:this.#s,d:this.#o}}get jwkPublic(){return u(this.#r&&this.#s,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:this.#r,y:this.#s}}get userPublicKey(){u(this.#r&&this.#s,"userPublicKey() - sufficient key info is not available (fatal)");const e=new Uint8Array(96);return e.set(P(this.#r),0),e.set(P(this.#s),48),ce.SBPublicKey+N(e)}get userPrivateKey(){u(this.#n,"userPrivateKey() - not a private key, there is no userPrivateKey"),u(this.#r&&this.#s&&this.#o,"userPrivateKey() - sufficient key info is not available (fatal)");const e=new Uint8Array(144);return e.set(P(this.#r),0),e.set(P(this.#s),48),e.set(P(this.#o),96),ce.SBPrivateKey+N(e)}}n([he,ye],ve.prototype,"private",null),n([he,ye],ve.prototype,"hash",null),n([he,ye],ve.prototype,"userId",null),n([he,ye],ve.prototype,"ownerChannelId",null),n([he,ye],ve.prototype,"privateKey",null),n([he,ye],ve.prototype,"publicKey",null),n([he],ve.prototype,"jwkPrivate",null),n([he],ve.prototype,"jwkPublic",null),n([he],ve.prototype,"userPublicKey",null),n([he],ve.prototype,"userPrivateKey",null);class me extends ve{#l;sbChannelKeysReady;SBChannelKeysReadyFlag=!1;#h;#y;#d;channelServer;#u;#g;constructor(e,t){switch(e){case"handle":{const e=t;super(e.userPrivateKey,!0),this.channelServer=e.channelServer,this.channelServer&&"/"===this.channelServer[this.channelServer.length-1]&&(this.channelServer=this.channelServer.slice(0,-1)),this.#l=e.channelId}break;case"jwk":super(t,!0),u(this.private,"Channel(): jwk provided but it's not private");break;case"new":super();break;default:throw new Error("Illegal parameters")}this.sbChannelKeysReady=new Promise((async(e,t)=>{o&&console.log("SBChannelKeys() constructor."),await this.sb384Ready;try{this.#l||(this.#l=this.ownerChannelId);const t=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]);this.#g=t.privateKey,this.#u=t.publicKey;const n=new ve(this.#g,!0);await n.ready,this.#y=await be.deriveKey(this.privateKey,this.#u,"AES-GCM",!0,["encrypt","decrypt"]),this.#d=await be.deriveKey(this.privateKey,this.#u,"HMAC",!0,["sign","verify"]),this.#h={channelId:this.#l,ownerPublicKey:this.userPublicKey,channelPublicKey:n.userPublicKey},this.SBChannelKeysReadyFlag=!0,e(this)}catch(e){t("ERROR creating SBChannelKeys object failed: "+y(e))}}))}get ready(){return this.sbChannelKeysReady}get readyFlag(){return this.SBChannelKeysReadyFlag}get channelData(){return this.#h}get owner(){return this.private&&this.ownerChannelId===this.channelId}get channelId(){return this.#l}get encryptionKey(){return this.#y}get signKey(){return this.#d}get channelPrivateKey(){return this.#g}get channelPublicKey(){return this.#u}}n([he,ye],me.prototype,"channelData",null),n([he,ye],me.prototype,"owner",null),n([he,ye],me.prototype,"channelId",null),n([he,ye],me.prototype,"encryptionKey",null),n([he,ye],me.prototype,"signKey",null),n([he,ye],me.prototype,"channelPrivateKey",null),n([he,ye],me.prototype,"channelPublicKey",null);class Se{channel;[fe]=!0;ready;contents;#y;MAX_SB_BODY_SIZE=98304;constructor(e,t=""){this.channel=e,this.contents="string"==typeof t?{contents:t,sign:""}:{contents:"",sign:""};let n=this.contents,r=JSON.stringify(n);u(r.length<this.MAX_SB_BODY_SIZE,`SBMessage(): body must be smaller than ${this.MAX_SB_BODY_SIZE/1024} KiB (we got ${r.length/1024})})`),this.ready=new Promise((t=>{e.channelReady.then((async()=>{this.#y=this.channel.encryptionKey,this.contents.senderUserId=this.channel.userId,be.sign(this.channel.privateKey,n.contents).then((e=>{this.contents.sign=e,t(this)}))}))}))}get encryptionKey(){return this.#y}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}n([ye],Se.prototype,"encryptionKey",null);class ke extends me{channelReady;#f=!1;motd="";locked=!1;adminData;verifiedGuest=!1;#p="";constructor(e){if(!e.channelServer)throw new Error("Channel(): no channel server provided");super("handle",e),this.channelReady=this.sbChannelKeysReady.then((()=>(this.#f=!0,this))).catch((e=>{throw e}))}get ready(){return this.channelReady}get readyFlag(){return this.#f}get api(){return this}async#w(e,t){return o&&console.log("#callApi:",e),this.#f||(a&&console.log("ChannelApi.#callApi: channel not ready (we will wait)"),await this.channelReady),new Promise((async(n,r)=>{this.channelId||r("ChannelApi.#callApi: no channel ID (?)"),await this.ready;let s="";const o=(new Date).getTime().toString();s=o+"."+await be.sign(this.privateKey,o);let a={method:"POST",headers:{"Content-Type":"application/json",authorization:s}},i={userId:this.userId,channelID:this.channelId,...t};a.body=JSON.stringify(i),await this.ready,h(this.channelServer+"/api/room/"+this.channelId+e,a).then((async e=>{const t=await e.json();if(!e.ok||t.error){let n="Network or Server error on Channel API call";e.status&&(n+=" ["+e.status+"]"),t.error&&(n+=": "+t.error),r(new Error(n))}else n(t)})).catch((e=>{r("ChannelApi (SBFetch) Error [2]: "+y(e))}))}))}async deCryptChannelMessage(e,t){const n=p.exec(e);let r=this.encryptionKey;if(n){let e,s={type:"encrypted",channelID:n[1],timestampPrefix:n[2],_id:n[1]+n[2],encrypted_contents:g(t)};try{e=await be.unwrap(r,s.encrypted_contents,"string")}catch(e){const t="ERROR: cannot decrypt message with either locked or unlocked key";return void(o&&console.error(t))}let a={...s,...Y(e,"L1977")};if(a.verificationToken&&!a.senderUserId)return void(o&&console.error("ERROR: message with verification token is lacking sender identity (cannot be verified)."));const i=new ve(a.senderUserId);await i.ready;const c=await be.deriveKey(this.privateKey,i.publicKey,"HMAC",!1,["sign","verify"]);return await be.verify(c,a.sign,a.contents)?a:(console.error("***** signature is NOT correct for message (rejecting)"),void(o&&(console.log("verifyKey:",Object.assign({},c)),console.log("m2.sign",Object.assign({},a.sign)),console.log("m2.contents",structuredClone(a.contents)),console.log("Message:",Object.assign({},a)))))}return console.error("++++++++ #processMessage: ERROR - cannot parse channel ID / timestamp, invalid message"),void(o&&(console.log(Object.assign({},e)),console.log(Object.assign({},t))))}getLastMessageTimes(){throw new Error("Channel.getLastMessageTimes(): not supported in 2.0 yet")}getOldMessages(e=100,t=!1){return new Promise((async(n,r)=>{this.channelId||r("Channel.getOldMessages: no channel ID (?)"),this.#f||(o&&console.log("Channel.getOldMessages: channel not ready (we will wait)"),await this.channelReady);let s="";t&&(s="&cursor="+this.#p),h(this.channelServer+"/"+this.channelId+"/oldMessages?currentMessagesLength="+e+s,{method:"GET"}).then((async e=>(e.ok||r(new Error("Network response was not OK")),e.json()))).then((e=>{o&&(console.log("getOldMessages"),console.log(e)),Promise.all(Object.keys(e).filter((t=>e[t].hasOwnProperty("encrypted_contents"))).map((t=>this.deCryptChannelMessage(t,e[t].encrypted_contents)))).then((e=>e.filter((e=>Boolean(e))))).then((e=>{let t=e[e.length-1];t&&(this.#p=t._id||""),a&&console.log(e),n(e)})).catch((e=>{const t=`Channel.getOldMessages(): failed to decrypt messages: ${e}`;console.error(t),r(t)}))})).catch((e=>{const t=`Channel.getOldMessages(): SBFetch failed: ${e}`;console.error(t),r(t)}))}))}send(e){return Promise.reject("Channel.send(): abstract method, must be implemented in subclass")}updateCapacity(e){return this.#w("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.#w("/getRoomCapacity")}getStorageLimit(){return this.#w("/getStorageLimit")}getMother(){return this.#w("/getMother")}getJoinRequests(){return this.#w("/getJoinRequests")}isLocked(){return new Promise((e=>this.#w("/roomLocked").then((t=>{this.locked=!0===t.locked,e(this.locked)}))))}setMOTD(e){return this.#w("/motd",{motd:e})}getAdminData(){return this.#w("/getAdminData")}authorize(e,t){return this.#w("/authorizeRoom",{roomId:this.channelId,SERVER_SECRET:t,ownerKey:e})}storageRequest(e){return this.#w("/storageRequest?size="+e)}acceptVisitor(e){console.warn(`WARNING: acceptVisitor(${e}) on channel api has not been tested/debugged fully ..`)}getStorageToken(e){return new Promise(((t,n)=>{this.#w(`/storageRequest?size=${e}`).then((e=>{e.hasOwnProperty("error")&&n(`storage token request error (${e.error})`),t(JSON.stringify(e))})).catch((e=>{n("ChannelApi (getStorageToken) Error [3]: "+y(e))}))}))}budd(e){let{keys:t,storage:n,targetChannel:r}=e??{};return new Promise((async(s,o)=>{e&&e.hasOwnProperty("storage")&&void 0===e.storage&&o("If you omit 'storage' it defaults to Infinity, but you cannot set 'storage' to undefined");try{if(n||(n=1/0),r){if(this.channelId==r)throw new Error("[budd()]: You can't specify the same channel as targetChannel");if(t)throw new Error("[budd()]: You can't specify both a target channel and keys");s(this.#w(`/budd?targetChannel=${r}&transferBudget=${n}`))}else{const e=new ve(t);await e.ready;const r={[ge]:!0,userPrivateKey:e.userPrivateKey,channelServer:this.channelServer,channelId:e.hash};let a=await this.#w(`/budd?targetChannel=${r.channelId}&transferBudget=${n}`,r);a.success?s(r):o(JSON.stringify(a))}}catch(e){o(e)}}))}}n([he,ye],ke.prototype,"api",null),n([ye,de],ke.prototype,"updateCapacity",null),n([ye,de],ke.prototype,"getCapacity",null),n([ye],ke.prototype,"getStorageLimit",null),n([ye,de],ke.prototype,"getMother",null),n([ye,de],ke.prototype,"getJoinRequests",null),n([function(e,t,n){if(n&&n.value){const r=n.value;n.value=function(...s){try{return r.call(this,...s)}catch(r){return console.log(`ExceptionReject: ${y(r)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${y(r)}`)))}}}}],ke.prototype,"isLocked",null),n([ye,de],ke.prototype,"setMOTD",null),n([ye,de],ke.prototype,"getAdminData",null),n([ye,de],ke.prototype,"authorize",null),n([ye],ke.prototype,"storageRequest",null),n([ye,de],ke.prototype,"acceptVisitor",null),n([ye],ke.prototype,"getStorageToken",null),n([ye,de],ke.prototype,"budd",null);class Ee extends ke{channelSocketReady;#b=!1;#v;#m;#S=this.#k;#E=new Map;#A=!1;#C=()=>{d("L2461","this should never be called")};#K=e=>{d("L2462","this should never be called")};constructor(e,t){if(u(t,"ChannelSocket(): no onMessage handler provided"),!e.hasOwnProperty("channelId")||!e.hasOwnProperty("userPrivateKey"))throw new Error("ChannelSocket(): first argument must be valid SBChannelHandle");if(!e.channelServer)throw new Error("ChannelSocket(): no channel server provided (required)");super(e),this.#m=e.channelServer.replace(/^http/,"ws"),this.#S=t;const n=this.#m+"/api/room/"+this.channelId+"/websocket";this.#v={url:n,ready:!1,closed:!1,timeout:2e3},this.channelSocketReady=this.#B()}#k(e){u(!1,"NO MESSAGE HANDLER")}#B(){return o&&console.log("++++ CREATING ChannelSocket.readyPromise()"),new Promise(((e,t)=>{o&&console.log("++++ STARTED ChannelSocket.readyPromise()"),this.#C=e;const n=this.#v.url;o&&(console.log("++++++++ readyPromise() has url:"),console.log(n)),this.#v.websocket||(this.#v.websocket=new WebSocket(this.#v.url)),3===this.#v.websocket.readyState?this.#v.websocket=new WebSocket(n):2===this.#v.websocket.readyState&&(console.warn("STRANGE - trying to use a ChannelSocket that is in the process of closing ..."),this.#v.websocket=new WebSocket(n)),this.#v.websocket.addEventListener("open",(()=>{this.#v.closed=!1,this.channelReady.then((()=>{u(this.userId,"ChannelSocket.readyPromise(): no userId of channel owner/user?"),this.#v.init={userId:this.userId},o&&(console.log("++++++++ readyPromise() constructed init:"),console.log(this.#v.init)),this.#v.websocket.send(JSON.stringify(this.#v.init))}))})),this.#K=this.#P.bind(this),this.#v.websocket.addEventListener("message",this.#K),this.#v.websocket.addEventListener("close",(e=>{this.#v.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.channelServer})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.channelServer}`),t("wbSocket() closed before it was opened (?)")})),this.#v.websocket.addEventListener("error",(e=>{this.#v.closed=!0,console.log("ChannelSocket() error: ",e),t("ChannelSocket creation error (see log)")})),setTimeout((()=>{this.#b?o&&(console.log("ChannelSocket() - this socket resolved"),console.log(this)):(console.warn("ChannelSocket() - this socket is not resolving (waited 10s) ..."),console.log(this),t("ChannelSocket() - this socket is not resolving (waited 10s) ..."))}),1e4)}))}async#R(e){let t=e.data;this.#A&&(console.log("... raw unwrapped message:"),console.log(structuredClone(t)));const n=Y(t,"L1489");this.#A&&(console.log("... json unwrapped version of raw message:"),console.log(Object.assign({},n))),"function"!=typeof this.#S&&d("ChannelSocket","received message but there is no handler");const r=n;try{const e=Object.entries(r)[0][1];if("encrypted_contents"===Object.keys(e)[0]){o&&console.log("++++++++ #processMessage: received message:",e.encrypted_contents.content);const t=M(await crypto.subtle.digest("SHA-256",(new TextEncoder).encode(e.encrypted_contents.content)));a&&console.log("Received message with hash:",t);const r=this.#E.get(t);r&&(this.#A&&console.log(`++++++++ #processMessage: found matching ack for id ${t}`),this.#E.delete(t),r("success"));const s=Object.entries(n)[0][0],i=e.encrypted_contents.iv;if(i&&b(i)&&16==i.length){e.encrypted_contents.iv=P(i);try{const t=await this.deCryptChannelMessage(s,e.encrypted_contents);if(!t)return;this.#A&&(console.log("++++++++ #processMessage: passing to message handler:"),console.log(Object.assign({},t))),this.#S(t)}catch{console.warn("Error decrypting message, dropping (ignoring) message")}}else console.error("#processMessage: - iv is malformed, should be 16-char b64 string (ignoring)")}else console.warn("++++++++ #processMessage: can't decipher message, passing along unchanged:"),console.log(Object.assign({},r)),this.onMessage(r)}catch(e){console.log(`++++++++ #processMessage: caught exception while decyphering (${e}), passing it along unchanged`),this.onMessage(r)}}#O(e){console.warn("WARNING: firstMessageEventHandler() called recursively (?)"),console.warn(e)}#P(e){this.#A&&console.log("FIRST MESSAGE HANDLER CALLED");const t=this.#O.bind(this);this.#v.websocket.addEventListener("message",t),this.#v.websocket.removeEventListener("message",this.#K);const n=Y(e.data,"L2239");o&&console.log("++++++++ readyPromise() received ChannelKeysMessage:",n),u(n.ready,`got roomKeys but channel reports it is not ready [${n}]`),this.motd=n.motd,u(this.readyFlag,"#ChannelReadyFlag is false, parent not ready (?)"),this.locked=n.roomLocked,this.adminData=this.api.getAdminData(),this.#v.websocket.addEventListener("message",this.#R.bind(this)),this.#v.websocket.removeEventListener("message",t),o&&console.log("++++++++ readyPromise() all done - resolving!"),this.#b=!0,this.#C(this)}get ready(){return this.channelSocketReady}get readyFlag(){return this.#b}get status(){if(!this.#v.websocket)return"CLOSED";switch(this.#v.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#S=e}get onMessage(){return this.#S}set enableTrace(e){this.#A=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}send(e){let t="string"==typeof e?new Se(this,e):e;return u(this.#v.websocket,"ChannelSocket.send() called before ready"),this.#v.closed&&(this.#A&&console.info("send() triggered reset of #readyPromise() (normal)"),this.channelSocketReady=this.#B(),this.#b=!0),new Promise(((e,n)=>{t.ready.then((t=>{this.ready.then((()=>{switch(this.#b||n("ChannelSocket.send() is confused - ready or not?"),this.#v.websocket.readyState){case 1:this.#A&&console.log("++++++++ ChannelSocket.send(): Wrapping message contents:",Object.assign({},t.contents)),be.wrap(t.encryptionKey,JSON.stringify(t.contents),"string").then((t=>{const r=JSON.stringify({encrypted_contents:t});this.#A&&(console.log("++++++++ ChannelSocket.send(): sending message:"),console.log(t.content.slice(0,100)+"  ...  "+t.content.slice(-100))),crypto.subtle.digest("SHA-256",(new TextEncoder).encode(t.content)).then((t=>{const s=M(t);this.#A&&(console.log("++++++++ ChannelSocket.send():Which has hash:"),console.log(s)),this.#E.set(s,e),this.#v.websocket.send(r),setTimeout((()=>{if(this.#E.has(s)){this.#E.delete(s);const e=`Websocket request timed out (no ack) after ${this.#v.timeout}ms (${s})`;console.error(e),n(e)}else this.#A&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#v.timeout)}))}));break;case 3:case 0:case 2:n("socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING")}}))}))}))}}n([ye],Ee.prototype,"onMessage",null),n([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&ue.includes(n)&&u(we(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],Ee.prototype,"send",null);class Ae{version="2";#I="b";#j;#M;#D;shardServer;iv;salt;fileName;dateAndTime;fileType;lastModified;actualSize;savedSize;constructor(e){const{version:t,type:n,id:r,key:s,verification:o,iv:a,salt:i,fileName:c,dateAndTime:l,fileType:h,lastModified:y,actualSize:d,savedSize:u}=e;if(n&&(this.#I=n),t)this.version=t;else if(s&&r)if(q(s)&&q(r))this.version="2";else{if(!v(s)||!v(r))throw new Error("Unable to determine version from key and id");this.version="1"}else this.version="2";r&&(this.id=r),s&&(this.key=s),o&&(this.verification=o),this.iv=a,this.salt=i,this.fileName=c,this.dateAndTime=l,this.fileType=h,this.lastModified=y,this.actualSize=d,this.savedSize=u}set id_binary(e){if(!e)throw new Error("Invalid id_binary");if(32!==e.byteLength)throw new Error("Invalid id_binary length");this.#j=e,Object.defineProperty(this,"id64",{get:()=>M(this.#j),enumerable:!1,configurable:!1}),Object.defineProperty(this,"id32",{get:()=>N(this.#j),enumerable:!1,configurable:!1})}set key_binary(e){if(!e)throw new Error("Invalid key_binary");if(32!==e.byteLength)throw new Error("Invalid key_binary length");this.#M=e,Object.defineProperty(this,"key64",{get:()=>M(this.#M),enumerable:!1,configurable:!1}),Object.defineProperty(this,"key32",{get:()=>N(this.#M),enumerable:!1,configurable:!1})}set id(e){if("string"==typeof e){if("1"===this.version){if(!v(e))throw new Error("Requested version 1, but id is not b64");this.id_binary=P(e)}else if("2"===this.version){if(!q(e))throw new Error("Requested version 2, but id is not b62");this.id_binary=G(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid ID type");if(32!==e.byteLength)throw new Error("Invalid ID length");this.id_binary=e}}set key(e){if("string"==typeof e){if("1"===this.version){if(!v(e))throw new Error("Requested version 1, but key is not b64");this.#M=P(e)}else if("2"===this.version){if(!q(e))throw new Error("Requested version 2, but key is not b62");this.#M=G(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid key type");if(32!==e.byteLength)throw new Error("Invalid key length");this.#M=e}}get id(){if(u(this.#j,"object handle id is undefined"),"1"===this.version)return M(this.#j);if("2"===this.version)return N(this.#j);throw new Error("Invalid or missing version (internal error, should not happen)")}get key(){if(u(this.#M,"object handle key is undefined"),"1"===this.version)return M(this.#M);if("2"===this.version)return N(this.#M);throw new Error("Invalid or missing version (internal error, should not happen)")}get id64(){throw new Error("Invalid id_binary")}get id32(){throw new Error("Invalid id_binary")}get key64(){throw new Error("Invalid key_binary")}get key32(){throw new Error("Invalid key_binary")}set verification(e){this.#D=e}get verification(){return u(this.#D,"object handle verification is undefined"),this.#D}get type(){return this.#I}}class Ce{storageServer;constructor(e){if("string"!=typeof e)throw new Error("[StorageApi] Invalid parameter to constructor");this.storageServer=e}#x(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=J(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),a&&console.log("#padBuf bytes:",r.slice(-4)),r}#T(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(a&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=r),a&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}#_(e,t){return new Promise(((n,r)=>{try{be.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}#L(e,t){return new Promise(((n,r)=>{h(this.storageServer+"/api/v1/storeRequest?name="+N(e)+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=oe(e);n({salt:new Uint8Array(t.salt),iv:new Uint8Array(t.iv)})})).catch((e=>{console.warn(`**** ERROR: ${e}`),r(e)}))}))}async#$(e,t,n,r,s,o,a){return new Promise((async(i,c)=>{try{const l=await this.#_(n,a),h=await be.encrypt(e,l,{iv:o},"arrayBuffer"),y=await s.getStorageToken(h.byteLength),d=await this.storeObject(r,t,o,a,y,h);d.error&&c(`storeObject() failed: ${d.error}`),d.image_id!=t&&c(`received imageId ${d.image_id} but expected ${t}`),i(d.verification_token)}catch(e){const t=`storeObject() failed: ${e}`;console.error(t),c(t)}}))}storeObject(e,t,n,r,s,o){return new Promise(((a,i)=>{if("string"!=typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeData()";console.error(e),i("errMsg")}h(this.storageServer+"/storeData?type="+e+"&key="+t,{method:"POST",body:te({iv:n,salt:r,image:o,storageToken:(new TextEncoder).encode(s),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||i("response from storage server was not OK"),e.json()))).then((e=>{a(e)})).catch((e=>{i(e)}))}))}storeData(e,t,n){return new Promise(((r,s)=>{if("string"==typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeObject()";console.error(e),s("errMsg")}e instanceof Uint8Array&&(a&&console.log("converting Uint8Array to ArrayBuffer"),e=new Uint8Array(e).buffer),e instanceof ArrayBuffer||"ArrayBuffer"==e.constructor.name||(a&&console.log("buf must be an ArrayBuffer:"),console.log(e),s("buf must be an ArrayBuffer"));const o=e.byteLength,i=n instanceof ke?n:new ke(n),c=this.#x(e);be.generateIdKey(c).then((e=>{this.#L(e.id_binary,t).then((n=>{const s=N(e.id_binary),a=N(e.key_material),l={[pe]:!0,version:"2",type:t,id:s,key:a,iv:n.iv,salt:n.salt,actualSize:o,verification:this.#$(c,s,e.key_material,t,i,n.iv,n.salt)};r(l)})).catch((e=>s(e)))}))}))}#U(e,t){return new Promise(((n,r)=>{try{let t=Y(be.ab2str(new Uint8Array(e)),"L3062");t.error&&r(`#processData() error: ${t.error}`)}catch(e){}finally{const r=oe(e);o&&(console.log("Payload (#processData) is:"),console.log(r));const i=new Uint8Array(r.iv),c=new Uint8Array(r.salt),l=t.iv?"string"==typeof t.iv?P(t.iv):t.iv:void 0,h=t.salt?"string"==typeof t.salt?P(t.salt):t.salt:void 0;var s;if(l&&!j(i,l)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${M(l)}`),console.log(`server iv: ${M(r.iv)}`)),h&&!j(c,h)&&(console.error("WARNING: salt from server differs from local copy (will use server)"),t.salt?"string"==typeof t.salt?(console.log("h.salt is in string form (unprocessed):"),console.log(t.salt)):(console.log("h.salt is in arrayBuffer or Uint8Array"),console.log("h.salt as b64:"),console.log(M(t.salt)),console.log("h.salt unprocessed:"),console.log(t.salt)):console.log("h.salt is undefined"),console.log("handleSalt as b64:"),console.log(M(h)),console.log("handleSalt unprocessed:"),console.log(h)),a&&(console.log("will use nonce and salt of:"),console.log(`iv: ${M(i)}`),console.log(`salt : ${M(c)}`)),"1"===t.version)s=P(t.key);else{if("2"!==t.version)throw new Error("Invalid or missing version (internal error, should not happen)");s=G(t.key)}this.#_(s,c).then((e=>{const t=r.image;a&&(console.log("data.image:      "),console.log(r.image),console.log("encrypted_image: "),console.log(t)),be.unwrap(e,{content:t,iv:i},"arrayBuffer").then((e=>{const t=this.#T(e);o&&(console.log("#processData(), unwrapped img: "),console.log(t)),n(t)}))}))}}))}async#N(e,t,n,r){const s={method:"GET"};return new Promise((async(o,a)=>{h(e+t,s).then((e=>e.ok?e.arrayBuffer():null)).then((e=>null===e?null:this.#U(e,n))).then((e=>{null===e&&o(null),o("string"===r?be.ab2str(new Uint8Array(e)):e)})).catch((e=>null))}))}fetchData(e,t="arrayBuffer"){return new Promise((async(n,r)=>{const s=new Ae(e);s||r("SBObjectHandle is null or undefined");const a=await s.verification,i=this.storageServer+"/api/v1";o&&console.log("fetchData(), fetching from server: "+i);const c="/fetchData?id="+s.id+"&type="+s.type+"&verification_token="+a,l=await this.#N(i,c,s,t);null!==l?(o&&console.log(`[fetchData] success: fetched from '${i}'`,l),n(l)):r("fetchData() failed")}))}}class Ke{channelServer;storageServer;#F;#H=r;sbFetch=h;constructor(e,t,n){if(console.warn(`==== CREATING Snackabra object generation: ${this.#H} ====`),t&&!0===t&&(o=!0),o&&n&&!0===n&&(a=!0),o&&console.warn("++++ Snackabra constructor ++++ setting DBG to TRUE ++++"),a&&console.warn("++++ Snackabra constructor ++++ ALSO setting DBG2 to TRUE ++++"),"string"!=typeof e)throw new Error("[Snackabra] Invalid parameter type for constructor");this.channelServer=e,this.storageServer="TODO",this.#F=new Ce(this.storageServer)}attach(e){return new Promise(((t,n)=>{e.channelId?(e.channelServer?e.channelServer!==this.channelServer&&n("SBChannelHandle channelId does not match channelServer"):e.channelServer=this.channelServer,t(new ke(e))):n("SBChannelHandle missing channelId")}))}create(e,t){return new Promise((async(n,r)=>{try{let o,a;if(!(e instanceof ve)){const t=`Wrong parameters to create channel: ${e}`;return console.error(t),void r(t)}a=new me("jwk",e.jwkPrivate),o=await t.getStorageToken(s),o||r("[create channel] Failed to get storage token for the provided channel"),a.channelData.storageToken=o;const i=(new TextEncoder).encode(JSON.stringify(a.channelData));let c=await h(this.channelServer+"/api/v2/channel/"+a.channelId+"/create",{method:"POST",body:i});if(c=await c.json(),!c.success){const e=`Creating channel did not succeed (${JSON.stringify(c)})`;return console.error(e),void r(e)}n({[ge]:!0,channelId:a.channelId,userPrivateKey:a.userPrivateKey,channelServer:this.channelServer})}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),r(t)}}))}connect(e,t){const n={[ge]:!0,channelId:e.channelId,userPrivateKey:e.userPrivateKey,channelServer:this.channelServer};return o&&console.log("++++ Snackabra.connect() ++++",n),new Ee(n,t||(e=>{console.log("MESSAGE (not caught):",e)}))}get storage(){if("string"==typeof this.#F)throw new Error("StorageApi not initialized");return this.#F}get crypto(){return be}get version(){return this.#H}}var Be={Snackabra:Ke,SBMessage:Se,Channel:ke,SBCrypto:le,SB384:ve,arrayBufferToBase64:M,sbCrypto:be,version:r};return globalThis.SB||(globalThis.SB=Be),console.warn(`==== SNACKABRA jslib loaded ${globalThis.SB.version} ====`),t})()));